
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>8.2. Geometric Transformations &#8212; Introduction to Digital Engineering</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css?v=ca93fcec" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/myfile.css?v=564be945" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'chapter_08/ENGG680_C08S02';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="8.3. Image Thresholding" href="ENGG680_C08S03.html" />
    <link rel="prev" title="8.1. Getting Started with OpenCV" href="ENGG680_C08S01.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../Introduction.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Introduction to Digital Engineering - Home"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Introduction to Digital Engineering - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_01/ENGG680_C01.html">1. Introduction to Python Programming</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_01/ENGG680_C01S01.html">1.1. Variable names, Expressions and statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_01/ENGG680_C01S02.html">1.2. Fundamental Concepts and Operations in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_01/ENGG680_C01S03.html">1.3. Functions</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_02/ENGG680_C02.html">2. Control Flow: Conditionals, Recursion, and Iteration</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_02/ENGG680_C02S01.html">2.1. Conditionals and recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_02/ENGG680_C02S02.html">2.2. Iteration</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_03/ENGG680_C03.html">3. Data Structures and File Handling in Python</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_03/ENGG680_C03S01.html">3.1. Strings in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_03/ENGG680_C03S02.html">3.2. Python Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_03/ENGG680_C03S03.html">3.3. Python Dictionaries: Key-Value Pairs in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_03/ENGG680_C03S04.html">3.4. Python Tuples: Immutable Sequences in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_03/ENGG680_C03S05.html">3.5. Python Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_03/ENGG680_C03S06.html">3.6. Files in Python (Optional Section)</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_04/ENGG680_C04.html">4. Classes and Objects</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_04/ENGG680_C04S01.html">4.1. Introduction to Classes and Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_04/ENGG680_C04S02.html">4.2. Inheritance and Polymorphism</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_04/ENGG680_C04S03.html">4.3. Encapsulation and Abstraction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_04/ENGG680_C04S04.html">4.4. Copying Objects (Optional Section)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_04/ENGG680_C04S05.html">4.5. Magic Methods (Dunder Methods) in Python (Optional Section)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_04/ENGG680_C04S06.html">4.6. Examples of Classes (Optional Section)</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_05/ENGG680_C05.html">5. Introduction to NumPy</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_05/ENGG680_C05S01.html">5.1. Basics of Numpy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_05/ENGG680_C05S02.html">5.2. NumPy Function Reference and Usage Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_05/ENGG680_C05S03.html">5.3. Advanced Numpy Concepts (Optional Section)</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_06/ENGG680_C06.html">6. Working with Data using Pandas</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_06/ENGG680_C06S01.html">6.1. An Introduction to Pandas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_06/ENGG680_C06S02.html">6.2. DataFrame and Series Indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_06/ENGG680_C06S03.html">6.3. Pandas Data Selection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_06/ENGG680_C06S04.html">6.4. Handling Missing Data in Pandas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_06/ENGG680_C06S05.html">6.5. Combining Datasets using Pandas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_06/ENGG680_C06S06.html">6.6. Aggregation and Grouping in Pandas</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_07/ENGG680_C07.html">7. Data Visualization using Python</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_07/ENGG680_C07S01.html">7.1. Getting started with Matplotlib</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_07/ENGG680_C07S02.html">7.2. Matplotlib Styles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_07/ENGG680_C07S03.html">7.3. Matplotlib interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_07/ENGG680_C07S04.html">7.4. Adjusting the Plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_07/ENGG680_C07S05.html">7.5. Seaborn plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_07/ENGG680_C07S06.html">7.6. Python Plotting Guide</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="ENGG680_C08.html">8. An Introduction to Computer Vision</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ENGG680_C08S01.html">8.1. Getting Started with OpenCV</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">8.2. Geometric Transformations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ENGG680_C08S03.html">8.3. Image Thresholding</a></li>
<li class="toctree-l2"><a class="reference internal" href="ENGG680_C08S04.html">8.4. Image Filtering</a></li>
<li class="toctree-l2"><a class="reference internal" href="ENGG680_C08S05.html">8.5. Drawing Functions (Optional Section)</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_09/ENGG680_C09.html">9. An Introduction to Machine Learning</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_09/ENGG680_C09S01.html">9.1. Prologue: Statistical Metrics and Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_09/ENGG680_C09S02.html">9.2. An Introduction to Linear Regression</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_09/ENGG680_C09S03.html">9.3. Multiple Linear Regression</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_09/ENGG680_C09S04.html">9.4. Logistic Regression</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_09/ENGG680_C09S05.html">9.5. K-Nearest Neighbors (K-NN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_09/ENGG680_C09S06.html">9.6. Resampling Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_09/ENGG680_C09S07.html">9.7. Support Vector Machines</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_10/ENGG680_C10.html">10. Tree-Based Methods</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_10/ENGG680_C10S01.html">10.1. Fundamental Structure of Decision Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_10/ENGG680_C10S02.html">10.2. Regression Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_10/ENGG680_C10S03.html">10.3. Classification Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_10/ENGG680_C10S04.html">10.4. Regression Trees and Linear Models (Optional Section)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_10/ENGG680_C10S05.html">10.5. Enhancing Decision Trees with Bagging: An Introduction (Optional Section)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_10/ENGG680_C10S06.html">10.6. Random Forests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_10/ENGG680_C10S07.html">10.7. Gradient Boosting</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_11/ENGG680_C11.html">11. Dimensionality Reduction and Feature Selection</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_11/ENGG680_C11S01.html">11.1. Introduction to Dimensionality Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_11/ENGG680_C11S02.html">11.2. Principal Components Analysis (PCA)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_11/ENGG680_C11S03.html">11.3. t-Distributed Stochastic Neighbor Embedding (t-SNE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_11/ENGG680_C11S04.html">11.4. Linear and Quadratic Discriminant Analyses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_11/ENGG680_C11S05.html">11.5. Recursive Feature Elimination (RFE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_11/ENGG680_C11S06.html">11.6. Practical Considerations in Dimensionality Reduction</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_12/ENGG680_C12.html">12. Introduction to Deep Learning</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_12/ENGG680_C12S01.html">12.1. Understanding Deep Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_12/ENGG680_C12S02.html">12.2. Fundamentals of Neural Networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_12/ENGG680_C12S03.html">12.3. TensorFlow Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_12/ENGG680_C12S04.html">12.4. Introduction to Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_12/ENGG680_C12S05.html">12.5. Tensors in Various Operations (Ops)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_12/ENGG680_C12S06.html">12.6. Building a linear Regression Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_12/ENGG680_C12S07.html">12.7. Building a Logistic Regression Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_12/ENGG680_C12S08.html">12.8. Multilayer Perceptron (MLP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_12/ENGG680_C12S09.html">12.9. Deep Learning Architectures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_12/ENGG680_C12S10.html">12.10. Image classification with TensorFlow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_12/ENGG680_C12S11.html">12.11. Image Augmentations with TensorFlow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_12/ENGG680_C12S12.html">12.12. Enhancing Image Classification Precision Through TensorFlow and Data Augmentation Strategies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_12/ENGG680_C12S13.html">12.13. Brief Overview of Additional Topics</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../References.html">13. References</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Geometric Transformations</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#sample-images">8.2.1. Sample Images</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#affine-transformations">8.2.2. Affine Transformations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#how-to-derive-an-affine-transformation">8.2.2.1. How to Derive an Affine Transformation?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#getaffinetransform">8.2.2.2. getAffineTransform</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#image-wrap">8.2.2.3. Image Wrap</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#getrotationmatrix2d">8.2.2.4. getRotationMatrix2D</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#resizing-images-with-opencv">8.2.3. Resizing Images with OpenCV</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#warp-perspective-optional-content">8.2.4. Warp Perspective (Optional Content)</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="geometric-transformations">
<h1><span class="section-number">8.2. </span>Geometric Transformations<a class="headerlink" href="#geometric-transformations" title="Link to this heading">#</a></h1>
<section id="sample-images">
<h2><span class="section-number">8.2.1. </span>Sample Images<a class="headerlink" href="#sample-images" title="Link to this heading">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">sklearn.datasets.load_sample_images()</span></code> is a function available in scikit-learn, a widely used Python machine learning library <span id="id1">[<a class="reference internal" href="../References.html#id53" title="scikit-learn Developers. Scikit-learn user guide. https://scikit-learn.org/stable/user_guide.html, 2023. [Online; accessed 01-August-2023].">scikit-learn Developers, 2023</a>]</span>. Detailed information about this function can be found <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_sample_images.html">here</a>. This function is used to load a collection of sample images, which can be useful for testing and experimenting with image-based machine learning algorithms and data analysis pipelines.</p>
<p>When you call <code class="docutils literal notranslate"><span class="pre">load_sample_images()</span></code>, it retrieves a predefined set of sample images that are bundled with the scikit-learn library. These images cover a range of subjects and formats, providing a diverse set of data for practicing and developing image processing, computer vision, and machine learning techniques.</p>
<p>The loaded images are usually provided as a dictionary-like object, containing the images themselves, information about the images, and sometimes additional metadata. This allows you to quickly access and work with the sample images for various tasks.
If you’re interested, you can access the detailed documentation for this image dataset <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_sample_images.html#sklearn.datasets.load_sample_images">here</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import necessary libraries</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  <span class="c1"># Import the plotting library</span>

<span class="c1"># Set font properties for plots</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.family&#39;</span><span class="p">:</span> <span class="s1">&#39;Calibri&#39;</span><span class="p">,</span> <span class="s1">&#39;axes.titlesize&#39;</span><span class="p">:</span> <span class="mi">16</span><span class="p">})</span>

<span class="c1"># Define a function to display images with titles and optional settings</span>
<span class="k">def</span> <span class="nf">ImShow</span><span class="p">(</span><span class="n">Images</span><span class="p">,</span> <span class="n">Names</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Images&#39;</span><span class="p">,</span> <span class="n">grayscale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">9.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Display a pair of images side by side.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    Images (list): List of two images to be displayed.</span>
<span class="sd">    Names (list): List of two names or labels for the images.</span>
<span class="sd">    title (str, optional): Title for the figure. Defaults to &#39;Images&#39;.</span>
<span class="sd">    grayscale (bool, optional): If True, display images in grayscale. Defaults to False.</span>
<span class="sd">    figsize (tuple, optional): Figure size (width, height) in inches. Defaults to (9.5, 4).</span>

<span class="sd">    Returns:</span>
<span class="sd">    matplotlib.figure.Figure: The figure containing the displayed images.</span>
<span class="sd">    numpy.ndarray: The array of subplots for further manipulation.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Create a figure with two subplots</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>  <span class="c1"># Create a figure with 1 row and 2 columns of subplots</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># Flatten the subplots for easier manipulation</span>

    <span class="c1"># Iterate over the first two images</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="c1"># Display the image in grayscale if grayscale is True, otherwise in color</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Images</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span> <span class="k">if</span> <span class="n">grayscale</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Set aspect ratio to 1 (square aspect)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>  <span class="c1"># Turn off axis</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">Names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>  <span class="c1"># Set image title with bold font</span>

    <span class="k">if</span> <span class="n">title</span><span class="p">:</span>
        <span class="c1"># Set main title if provided</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>  <span class="c1"># Adjust layout for better spacing</span>

    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>

<span class="c1"># Load sample images</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_sample_images</span>  <span class="c1"># Import a function to load sample images</span>

<span class="n">Images</span> <span class="o">=</span> <span class="n">load_sample_images</span><span class="p">()[</span><span class="s1">&#39;images&#39;</span><span class="p">]</span>  <span class="c1"># Load the sample images</span>
<span class="c1"># Extract image names from file paths, removing extension and converting to title case</span>
<span class="n">Names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.jpg&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">load_sample_images</span><span class="p">()[</span><span class="s1">&#39;filenames&#39;</span><span class="p">]]</span>

<span class="c1"># Display the original images</span>
<span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">(</span><span class="n">Images</span><span class="p">,</span> <span class="n">Names</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Sample Images&#39;</span><span class="p">)</span>  <span class="c1"># Call the ImShow function to display images</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/efa1f2fef11b6466585f1fdf75a660ed126d6b7dfbe897a62fa2fbc485f6ab5e.png" src="../_images/efa1f2fef11b6466585f1fdf75a660ed126d6b7dfbe897a62fa2fbc485f6ab5e.png" />
</div>
</div>
</section>
<section id="affine-transformations">
<h2><span class="section-number">8.2.2. </span>Affine Transformations<a class="headerlink" href="#affine-transformations" title="Link to this heading">#</a></h2>
<p>An affine transformation is a fundamental concept in image processing used to represent various geometric operations. It combines linear transformations (matrix multiplication) with translations (vector addition) to achieve versatile effects <span id="id2">[<a class="reference internal" href="../References.html#id50" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>:</p>
<ol class="arabic simple">
<li><p><strong>Rotations</strong>: Employing linear transformations to rotate the image.</p></li>
<li><p><strong>Translations</strong>: Achieved by adding a vector, effectively shifting the image.</p></li>
<li><p><strong>Scale Operations</strong>: Applying linear transformations to resize the image.</p></li>
</ol>
<p>At its core, an affine transformation describes the relationship between two images. This transformation is typically represented by a 2x3 matrix <span id="id3">[<a class="reference internal" href="../References.html#id50" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>:</p>
<div class="amsmath math notranslate nohighlight" id="equation-1d76af15-6bb7-4460-aa56-3173a7f12390">
<span class="eqno">(8.2)<a class="headerlink" href="#equation-1d76af15-6bb7-4460-aa56-3173a7f12390" title="Permalink to this equation">#</a></span>\[\begin{equation}
A = \begin{bmatrix} a_{00} &amp; a_{01} \\ a_{10} &amp; a_{11} \end{bmatrix}_{2 \times 2} \quad B = \begin{bmatrix} b_{00} \\ b_{10} \end{bmatrix}_{2 \times 1}
\end{equation}\]</div>
<p>We combine these matrices to form a 2x3 matrix:</p>
<div class="amsmath math notranslate nohighlight" id="equation-70b418c1-b862-4ed0-9b1d-d1ba0a937f4f">
<span class="eqno">(8.3)<a class="headerlink" href="#equation-70b418c1-b862-4ed0-9b1d-d1ba0a937f4f" title="Permalink to this equation">#</a></span>\[\begin{equation}
M = \begin{bmatrix} A &amp; B \end{bmatrix} = \begin{bmatrix} a_{00} &amp; a_{01} &amp; b_{00} \\ a_{10} &amp; a_{11} &amp; b_{10} \end{bmatrix}_{2 \times 3}
\end{equation}\]</div>
<p>To transform a 2D vector <span class="math notranslate nohighlight">\(X = \begin{bmatrix} x \\ y \end{bmatrix}\)</span> using A and B, we can use:</p>
<div class="amsmath math notranslate nohighlight" id="equation-92ff1993-c768-4e5b-bdbf-ed186346d62c">
<span class="eqno">(8.4)<a class="headerlink" href="#equation-92ff1993-c768-4e5b-bdbf-ed186346d62c" title="Permalink to this equation">#</a></span>\[\begin{equation}
T = A \cdot X + B
\end{equation}\]</div>
<p>This results in:</p>
<div class="amsmath math notranslate nohighlight" id="equation-08e3d9c7-3fa5-4f0f-92f3-c1800f474336">
<span class="eqno">(8.5)<a class="headerlink" href="#equation-08e3d9c7-3fa5-4f0f-92f3-c1800f474336" title="Permalink to this equation">#</a></span>\[\begin{equation}
T = \begin{bmatrix} a_{00}x + a_{01}y + b_{00} \\ a_{10}x + a_{11}y + b_{10} \end{bmatrix}
\end{equation}\]</div>
<p>The aforementioned transformation may be alternatively expressed as follows. Given an input 2D vector <span class="math notranslate nohighlight">\(\mathbf{X} = \begin{bmatrix} x \\ y \end{bmatrix}\)</span>, the <a class="reference external" href="https://hatefdastour.github.io/notes/Linear_Algebra/chapter_05/Linear_Transformations.html">transformation</a> <span class="math notranslate nohighlight">\(T\)</span> can be succinctly defined as:</p>
<div class="amsmath math notranslate nohighlight" id="equation-320e1c81-70bb-41af-aae5-4969e2761fd1">
<span class="eqno">(8.6)<a class="headerlink" href="#equation-320e1c81-70bb-41af-aae5-4969e2761fd1" title="Permalink to this equation">#</a></span>\[\begin{equation}
\begin{bmatrix}x' \\ y' \end{bmatrix}= M \mathbf{X^*}
= \begin{bmatrix} a_{00}x + a_{01}y + b_{00} \\ a_{10}x + a_{11}y + b_{10} \end{bmatrix}
\end{equation} \]</div>
<p>Where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(M\)</span> denotes the 2x3 matrix:</p></li>
</ul>
<div class="amsmath math notranslate nohighlight" id="equation-24cf2f25-7d7d-425f-99c2-fc1e9a829fc0">
<span class="eqno">(8.7)<a class="headerlink" href="#equation-24cf2f25-7d7d-425f-99c2-fc1e9a829fc0" title="Permalink to this equation">#</a></span>\[\begin{equation}
M = \begin{bmatrix} A &amp; B \end{bmatrix} = \begin{bmatrix} a_{00} &amp; a_{01} &amp; b_{00} \\ a_{10} &amp; a_{11} &amp; b_{10} \end{bmatrix}_{2 \times 3}
\end{equation}\]</div>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{X}\)</span> represents the input vector:</p></li>
</ul>
<div class="amsmath math notranslate nohighlight" id="equation-239993dc-84d4-4fef-a86d-d1cbca63588d">
<span class="eqno">(8.8)<a class="headerlink" href="#equation-239993dc-84d4-4fef-a86d-d1cbca63588d" title="Permalink to this equation">#</a></span>\[\begin{equation} \mathbf{X} = \begin{bmatrix} x \\y \end{bmatrix}
\end{equation}\]</div>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{X^*}\)</span> signifies an augmented form of the input vector:</p></li>
</ul>
<div class="amsmath math notranslate nohighlight" id="equation-113c859a-fa05-4722-8669-ad781aedf020">
<span class="eqno">(8.9)<a class="headerlink" href="#equation-113c859a-fa05-4722-8669-ad781aedf020" title="Permalink to this equation">#</a></span>\[\begin{equation} \mathbf{X} = \begin{bmatrix} x \\y \\ 1 \end{bmatrix}
\end{equation}\]</div>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(x'\)</span> and <span class="math notranslate nohighlight">\(y'\)</span> denote the transformed coordinates, which are the outcomes of applying the affine transformation <span class="math notranslate nohighlight">\(T\)</span> to the input vector <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>.</p></li>
</ul>
<p>Affine transformations provide a powerful framework for image manipulation, enabling operations such as rotation, translation, scaling, and more. They form the basis for transforming images efficiently and systematically.</p>
<ul class="simple">
<li><p><strong>Translation Transformations:</strong></p></li>
</ul>
<div class="amsmath math notranslate nohighlight" id="equation-15bffc81-d9a9-480f-82aa-646abb73a337">
<span class="eqno">(8.10)<a class="headerlink" href="#equation-15bffc81-d9a9-480f-82aa-646abb73a337" title="Permalink to this equation">#</a></span>\[\begin{equation}
A = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix}_{2 \times 2} \quad B = \begin{bmatrix} b_{00} \\ b_{10} \end{bmatrix}_{2 \times 1}
\end{equation}\]</div>
<ul class="simple">
<li><p><strong>Rotation Transformations (for positive angles being clockwise rotations:)</strong></p></li>
</ul>
<div class="amsmath math notranslate nohighlight" id="equation-f2f7c0d3-6fa0-42e6-8c76-0c70d1ddad3b">
<span class="eqno">(8.11)<a class="headerlink" href="#equation-f2f7c0d3-6fa0-42e6-8c76-0c70d1ddad3b" title="Permalink to this equation">#</a></span>\[\begin{equation}
A = \begin{bmatrix} \cos(\theta) &amp; -\sin(\theta) \\ \sin(\theta) &amp; \cos(\theta) \end{bmatrix}_{2 \times 2} \quad B = \begin{bmatrix} 0 \\ 0 \end{bmatrix}_{2 \times 1}
\end{equation}\]</div>
<ul class="simple">
<li><p><strong>Scaling Transformations:</strong>
\begin{equation}
A = \begin{bmatrix} a_{00} &amp; 0 \ 0 &amp; a_{11} \end{bmatrix}<em>{2 \times 2} \quad B = \begin{bmatrix} b</em>{00} \ b_{10} \end{bmatrix}_{2 \times 1}
\end{equation}</p></li>
</ul>
<section id="how-to-derive-an-affine-transformation">
<h3><span class="section-number">8.2.2.1. </span>How to Derive an Affine Transformation?<a class="headerlink" href="#how-to-derive-an-affine-transformation" title="Link to this heading">#</a></h3>
<p>An Affine Transformation represents a fundamental relationship between two images. This connection can be established through different means, generally falling into two categories [OpenCV Developers, 2023]:</p>
<ol class="arabic simple">
<li><p><strong>When We Know Both <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(T\)</span></strong>: In this scenario, we possess knowledge about both sets of points, X and T, and we are aware that these points are related. Our objective is to find the transformation matrix, denoted as <span class="math notranslate nohighlight">\(M\)</span>.</p></li>
<li><p><strong>When We Know <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(M\)</span></strong>: If we have information about the transformation matrix <span class="math notranslate nohighlight">\(M\)</span> and the original set of points <span class="math notranslate nohighlight">\(X\)</span>, we can easily obtain the transformed set of points <span class="math notranslate nohighlight">\(T\)</span> by applying the transformation equation <span class="math notranslate nohighlight">\(T = MX\)</span>. This information for <span class="math notranslate nohighlight">\(M\)</span> can either be explicit, represented as a 2-by-3 matrix, or it may be inferred from a geometric relationship between points.</p></li>
</ol>
<p>To elucidate the concept further, let’s delve into the scenario described in point (b). When <span class="math notranslate nohighlight">\(M\)</span> is the relationship that connects two images, we can analyze the simplest case where <span class="math notranslate nohighlight">\(M\)</span> relates three distinct points in both images. Consider the visual representation below <span id="id4">[<a class="reference internal" href="../References.html#id50" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>:</p>
<figure class="align-center" id="id9">
<a class="reference internal image-reference" href="../_images/Warp_Affine_0.png"><img alt="../_images/Warp_Affine_0.png" src="../_images/Warp_Affine_0.png" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.5 </span><span class="caption-text">Image courtesy of <span id="id5">[<a class="reference internal" href="../References.html#id50" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</span><a class="headerlink" href="#id9" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In the image, points 1, 2, and 3 form a triangle in image 1. This same triangle, when mapped into image 2 through the Affine Transformation, undergoes a noticeable change. By determining the Affine Transformation using these three chosen points (which can be selected as needed), we can establish this discovered relationship for all pixels within an image.</p>
<p>This methodology empowers us to apply the same transformation across the entire image, enabling geometric alterations such as rotations, translations, and scaling. Understanding this relationship between points and the transformation matrix forms the foundation for systematically manipulating images with Affine Transformations.</p>
</section>
<section id="getaffinetransform">
<h3><span class="section-number">8.2.2.2. </span>getAffineTransform<a class="headerlink" href="#getaffinetransform" title="Link to this heading">#</a></h3>
<p>The function <code class="docutils literal notranslate"><span class="pre">cv2.getAffineTransform(src,</span> <span class="pre">dst)</span></code> is a part of the OpenCV library in Python, and it’s used to calculate the Affine Transformation matrix that maps points from one plane (source, <code class="docutils literal notranslate"><span class="pre">src</span></code>) to another plane (destination, <code class="docutils literal notranslate"><span class="pre">dst</span></code>). The Affine Transformation is a linear transformation that involves rotation, translation, and scaling. This transformation matrix can then be used to warp or transform images, shapes, or sets of points from the source plane to the destination plane <span id="id6">[<a class="reference internal" href="../References.html#id19" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="../References.html#id50" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p>Here’s a breakdown of the function parameters and return value:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src</span></code>: The source points, which is a 3x2 array of floating-point coordinates representing the original points in the source plane. It should contain three points (rows), each with two coordinates (columns).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The destination points, which is also a 3x2 array of floating-point coordinates. These represent the corresponding points in the destination plane. Just like the source points, it should contain three points with two coordinates each.</p></li>
</ol>
<p>The function calculates the Affine Transformation matrix that best maps the source points to the destination points. This matrix is denoted by the return value <code class="docutils literal notranslate"><span class="pre">retval</span></code>, which is a 2x3 floating-point matrix representing the transformation. The <code class="docutils literal notranslate"><span class="pre">retval</span></code> matrix can be used for various purposes, such as warping images using <code class="docutils literal notranslate"><span class="pre">cv2.warpAffine()</span></code> or transforming sets of points.</p>
<p>To use the Affine Transformation matrix obtained from <code class="docutils literal notranslate"><span class="pre">cv2.getAffineTransform()</span></code>, you’ll typically apply it to an image or points using the <code class="docutils literal notranslate"><span class="pre">cv2.warpAffine()</span></code> function, which performs the actual transformation. This function uses the calculated matrix to apply the transformation to the image or points. You can find the full description of this function <a class="reference external" href="https://docs.opencv.org/3.4/d4/d61/tutorial_warp_affine.html">here</a>.</p>
</section>
<section id="image-wrap">
<h3><span class="section-number">8.2.2.3. </span>Image Wrap<a class="headerlink" href="#image-wrap" title="Link to this heading">#</a></h3>
<p>The function you’re referring to, <code class="docutils literal notranslate"><span class="pre">cv2.warpAffine()</span></code>, is part of the OpenCV library, which is a popular computer vision and image processing library in Python. This specific function is used for geometric image transformations, particularly affine transformations. Let’s break down the parameters and its purpose:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">warpAffine</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">dsize</span><span class="p">[,</span> <span class="n">dst</span><span class="p">[,</span> <span class="n">flags</span><span class="p">[,</span> <span class="n">borderMode</span><span class="p">[,</span> <span class="n">borderValue</span><span class="p">]]]])</span> <span class="o">-&gt;</span> <span class="n">dst</span>
</pre></div>
</div>
<p>Here’s what each parameter does:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src</span></code>: This is the input image, which is the source image you want to apply the transformation to. It should be a NumPy array (image) in most cases.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">M</span></code>: This parameter represents the transformation matrix. It’s a 2x3 matrix that defines the affine transformation. The matrix includes parameters like scaling, rotation, translation, and shearing. The transformation matrix <code class="docutils literal notranslate"><span class="pre">M</span></code> is used to specify how each pixel in the source image should be mapped to the destination image.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dsize</span></code>: This is the size (width and height) of the output image (destination image) you want to create after applying the transformation. It’s specified as a tuple (width, height).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code> (optional): This is the output image where the transformed image will be stored. If not provided, a new image will be created to store the result.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">flags</span></code> (optional): This parameter specifies the interpolation method to be used during the transformation. Different methods can be used to determine the pixel values of the output image at locations that do not exactly map to locations in the source image.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">borderMode</span></code> (optional): This parameter determines how to handle pixels that fall outside the boundaries of the source image. It defines the border mode.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">borderValue</span></code> (optional): When a pixel is outside the source image boundaries, this parameter specifies the value that should be used for the pixel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">dst</span></code>: This indicates that the function returns the destination image, which contains the result of the affine transformation.</p></li>
</ol>
<p>You can find the full description of this function <a class="reference external" href="https://docs.opencv.org/3.4/d4/d61/tutorial_warp_affine.html">here</a>.</p>
<p><font color='Blue'><b>Example</b></font>:
In this illustrative code snippet, we showcase Affine Image Transformation using <code class="docutils literal notranslate"><span class="pre">cv2.getAffineTransform</span></code> in Python, including the definition of source and destination points, calculation of the Affine Transformation matrix, and visualization of the original and transformed images. We use the sklearn <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_sample_images.html#sklearn.datasets.load_sample_images">image dataset</a> to demonstrate basic operations using Open CV.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_sample_image</span>

<span class="c1"># Load an example image</span>
<span class="n">Img</span> <span class="o">=</span> <span class="n">load_sample_image</span><span class="p">(</span><span class="s1">&#39;flower.jpg&#39;</span><span class="p">)</span>
<span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">Img</span><span class="o">.</span><span class="n">shape</span>

<span class="c1"># Define the source points (original triangle)</span>
<span class="n">src_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">200</span><span class="p">]])</span>

<span class="c1"># Define the destination points (how the triangle should be transformed)</span>
<span class="n">dst_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">]])</span>

<span class="c1"># Calculate the Affine Transformation matrix using cv2.getAffineTransform</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">getAffineTransform</span><span class="p">(</span><span class="n">src_pts</span><span class="p">,</span> <span class="n">dst_pts</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Affine Transformation Matrix (M) =&#39;</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>

<span class="c1"># Apply the Affine Transformation to the image</span>
<span class="n">Out</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">warpAffine</span><span class="p">(</span><span class="n">Img</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">))</span>

<span class="c1"># Display the original and transformed images with titles</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">(</span><span class="n">Images</span><span class="o">=</span><span class="p">[</span><span class="n">Img</span><span class="p">,</span> <span class="n">Out</span><span class="p">],</span>
                 <span class="n">Names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Original Image&#39;</span><span class="p">,</span> <span class="s1">&#39;Transformed Image&#39;</span><span class="p">],</span>
                 <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Example: Affine Transformation&#39;</span><span class="p">,</span> <span class="n">grayscale</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Mark the source and destination points on the images</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">src_pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">src_pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>  <span class="c1"># Mark source points on the original image</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">dst_pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dst_pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>  <span class="c1"># Mark destination points on the transformed image</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Affine Transformation Matrix (M) = [[  1.27   0.6  -83.33]
 [ -0.33   1.    66.67]]
</pre></div>
</div>
<img alt="../_images/56ff4c3a9792aa687687235f8e1c788bcbb91e2921903ce5d05fd93d06e007ae.png" src="../_images/56ff4c3a9792aa687687235f8e1c788bcbb91e2921903ce5d05fd93d06e007ae.png" />
</div>
</div>
<p>Given an input 2D vector <span class="math notranslate nohighlight">\(\mathbf{X} = \begin{bmatrix} x \\ y \end{bmatrix}\)</span>, the transformation <span class="math notranslate nohighlight">\(T\)</span> can be expressed as:</p>
<div class="amsmath math notranslate nohighlight" id="equation-f74ce908-1a69-4c00-a678-a59ec428cc4f">
<span class="eqno">(8.12)<a class="headerlink" href="#equation-f74ce908-1a69-4c00-a678-a59ec428cc4f" title="Permalink to this equation">#</a></span>\[\begin{equation}\begin{bmatrix}x' \\ y' \end{bmatrix} = M  \mathbf{X^{*}} \end{equation}\]</div>
<p>Where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(M\)</span> is the following 2x3 matrix:</p></li>
</ul>
<div class="amsmath math notranslate nohighlight" id="equation-c80fd202-8d05-4dc7-8be1-260e2e2083c7">
<span class="eqno">(8.13)<a class="headerlink" href="#equation-c80fd202-8d05-4dc7-8be1-260e2e2083c7" title="Permalink to this equation">#</a></span>\[\begin{equation} M = \begin{bmatrix} 1.27 &amp; 0.6 &amp; -83.33 \\ -0.33 &amp; 1.0 &amp; 66.67 \end{bmatrix} \end{equation}\]</div>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{X}\)</span> represents the input vector:</p></li>
</ul>
<div class="amsmath math notranslate nohighlight" id="equation-7f563b41-09aa-4cb1-81ec-183f8bdeab84">
<span class="eqno">(8.14)<a class="headerlink" href="#equation-7f563b41-09aa-4cb1-81ec-183f8bdeab84" title="Permalink to this equation">#</a></span>\[\begin{equation} \mathbf{X} = \begin{bmatrix} x \\y \end{bmatrix}
\end{equation}\]</div>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{X^*}\)</span> signifies an augmented form of the input vector:</p></li>
</ul>
<div class="amsmath math notranslate nohighlight" id="equation-3465eacf-e31b-4a88-b116-1b29998505d3">
<span class="eqno">(8.15)<a class="headerlink" href="#equation-3465eacf-e31b-4a88-b116-1b29998505d3" title="Permalink to this equation">#</a></span>\[\begin{equation} \mathbf{X} = \begin{bmatrix} x \\y \\ 1 \end{bmatrix}
\end{equation}\]</div>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(x'\)</span> and <span class="math notranslate nohighlight">\(y'\)</span> are the transformed coordinates, which are the result of applying the affine transformation <span class="math notranslate nohighlight">\(T\)</span> to the input vector <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>.</p></li>
</ul>
<p>To calculate <span class="math notranslate nohighlight">\(x'\)</span> and <span class="math notranslate nohighlight">\(y'\)</span>, you perform the matrix multiplication as follows:</p>
<div class="amsmath math notranslate nohighlight" id="equation-feab64ba-0e29-4ee4-89cf-b6e8c0ea34a4">
<span class="eqno">(8.16)<a class="headerlink" href="#equation-feab64ba-0e29-4ee4-89cf-b6e8c0ea34a4" title="Permalink to this equation">#</a></span>\[\begin{equation}
\begin{bmatrix}
x' \\
y'
\end{bmatrix}
=
\begin{bmatrix}
1.27 &amp; 0.6 &amp; -83.33 \\
-0.33 &amp; 1.0 &amp; 66.67
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}
\end{equation}\]</div>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\([x, y]\)</span> represents a point in the original 2D plane, typically corresponding to a pixel location in the original image.</p></li>
<li><p><span class="math notranslate nohighlight">\([x', y']\)</span> represents the transformed point in the 2D plane, which corresponds to the new location of the pixel after applying the affine transformation.</p></li>
</ul>
<p><span class="math notranslate nohighlight">\([x, y]\)</span> are the coordinates of a point in the original image, and <span class="math notranslate nohighlight">\([x', y']\)</span> are the coordinates of the corresponding point in the transformed image after the affine transformation has been applied using the matrix <span class="math notranslate nohighlight">\(M\)</span>.</p>
<hr class="docutils" />
<p>In this code example, we perform the following task(s):</p>
<p>This code snippet demonstrates an Affine Transformation, which is a type of geometric transformation used to map points from one coordinate space to another. In this specific case, it defines a transformation for a triangle and applies it to an image. Here’s a breakdown of each part:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src_pts</span></code>: These are the source points, representing the vertices of the original triangle in the source coordinate space. The <code class="docutils literal notranslate"><span class="pre">np.float32</span></code> function is used to define these points as a NumPy array of floating-point numbers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst_pts</span></code>: These are the destination points, indicating how the original triangle should be transformed in the destination coordinate space. The <code class="docutils literal notranslate"><span class="pre">np.float32</span></code> function similarly defines these points as a NumPy array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cv2.getAffineTransform(src_pts,</span> <span class="pre">dst_pts)</span></code>: This function, part of the OpenCV library, calculates the Affine Transformation matrix based on the source and destination points. It determines how to transform the source triangle to align with the destination triangle.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">M</span></code>: The calculated Affine Transformation matrix is stored in the variable <code class="docutils literal notranslate"><span class="pre">M</span></code>. The <code class="docutils literal notranslate"><span class="pre">.round(2)</span></code> method is used to round the matrix elements to two decimal places for clarity.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">print('Affine</span> <span class="pre">Transformation</span> <span class="pre">Matrix</span> <span class="pre">(M)</span> <span class="pre">=',</span> <span class="pre">M)</span></code>: This line prints the Affine Transformation matrix <code class="docutils literal notranslate"><span class="pre">M</span></code> to the console for inspection.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Out</span> <span class="pre">=</span> <span class="pre">cv2.warpAffine(Img,</span> <span class="pre">M,</span> <span class="pre">(cols,</span> <span class="pre">rows))</span></code>: This code applies the Affine Transformation to an input image <code class="docutils literal notranslate"><span class="pre">Img</span></code>. It uses the transformation matrix <code class="docutils literal notranslate"><span class="pre">M</span></code> to warp the image. The result is stored in the variable <code class="docutils literal notranslate"><span class="pre">Out</span></code>. The <code class="docutils literal notranslate"><span class="pre">cols</span></code> and <code class="docutils literal notranslate"><span class="pre">rows</span></code> are the dimensions of the output image, typically representing the width and height of the transformed image.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">Transformation</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">src_pts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Apply a 2D transformation matrix to a set of source points.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    M (numpy.ndarray): The 2x3 transformation matrix.</span>
<span class="sd">    src_pts (numpy.ndarray): An array of source points in the shape (N, 2).</span>

<span class="sd">    Returns:</span>
<span class="sd">    numpy.ndarray: An array of transformed points in the shape (N, 2).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Reshape src_pts for matrix multiplication</span>
    <span class="n">src_pts_reshaped</span> <span class="o">=</span> <span class="n">src_pts</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Apply the transformation matrix M to the source points</span>
    <span class="n">transformed_pts</span> <span class="o">=</span> <span class="n">M</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">src_pts_reshaped</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">src_pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>

    <span class="c1"># Transpose the result to obtain a 2x3 matrix</span>
    <span class="n">transformed_pts</span> <span class="o">=</span> <span class="n">transformed_pts</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># transformed_pts now contains the transformed points in a 2x3 matrix</span>
    <span class="k">return</span> <span class="n">transformed_pts</span>
</pre></div>
</div>
</div>
</div>
<p>Note that if you use the above transfomratio, we get</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\begin{bmatrix}x' \\y'\end{bmatrix} &amp;=
\begin{bmatrix}1.27 &amp; 0.6 &amp; -83.33 \\-0.33 &amp; 1.0 &amp; 66.67\end{bmatrix}
\begin{bmatrix}50 \\50 \\ 1\end{bmatrix}=
\begin{bmatrix}10 \\100\end{bmatrix}\\
%
\begin{bmatrix}x' \\y'\end{bmatrix} &amp;=
\begin{bmatrix}1.27 &amp; 0.6 &amp; -83.33 \\-0.33 &amp; 1.0 &amp; 66.67\end{bmatrix}
\begin{bmatrix}200 \\50 \\ 1\end{bmatrix}=
\begin{bmatrix}200 \\50\end{bmatrix}\\
%
\begin{bmatrix}x' \\y'\end{bmatrix} &amp;=
\begin{bmatrix}1.27 &amp; 0.6 &amp; -83.33 \\-0.33 &amp; 1.0 &amp; 66.67\end{bmatrix}
\begin{bmatrix}50 \\200\\ 1\end{bmatrix}=
\begin{bmatrix}100 \\250\end{bmatrix}\\
\end{align*}\]</div>
<p>Please note that all final outputs were rounded to the nearest whole integers.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;src_pts:&#39;</span><span class="p">)</span>
<span class="n">pprint</span><span class="p">(</span><span class="n">src_pts</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;dst_pts:&#39;</span><span class="p">)</span>
<span class="n">pprint</span><span class="p">(</span><span class="n">Transformation</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">src_pts</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>src_pts:
array([[ 50.,  50.],
       [200.,  50.],
       [ 50., 200.]], dtype=float32)
dst_pts:
array([[ 10.17, 100.17],
       [200.67,  50.67],
       [100.17, 250.17]])
</pre></div>
</div>
</div>
</div>
<p><font color='Blue'><b>Example</b></font>:
In this example, we demonstrate 2D Image Translation using <code class="docutils literal notranslate"><span class="pre">cv2.warpAffine</span></code> in Python, showcasing the transforming an image of an image using the following <span class="math notranslate nohighlight">\(M\)</span>:</p>
<div class="amsmath math notranslate nohighlight" id="equation-fdca5dc1-7101-4a39-8199-bfdd57834ea8">
<span class="eqno">(8.17)<a class="headerlink" href="#equation-fdca5dc1-7101-4a39-8199-bfdd57834ea8" title="Permalink to this equation">#</a></span>\[\begin{equation}
M =
\begin{bmatrix}
1 &amp; 0 &amp; 10 \\
0 &amp; 1 &amp; 20
\end{bmatrix}
\end{equation}\]</div>
<p>where specified values of <span class="math notranslate nohighlight">\(b_{00} = 10\)</span> and <span class="math notranslate nohighlight">\(b_{10} = 20\)</span> and displaying both the original and transformed images with informative labels. We utilize the <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_sample_images.html#sklearn.datasets.load_sample_images">image dataset function</a> from scikit-learn to showcase fundamental image manipulation operations using OpenCV.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_sample_image</span>

<span class="c1"># Load the sample image</span>
<span class="n">Img</span> <span class="o">=</span> <span class="n">load_sample_image</span><span class="p">(</span><span class="s1">&#39;flower.jpg&#39;</span><span class="p">)</span>
<span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">Img</span><span class="o">.</span><span class="n">shape</span>

<span class="c1"># Define a function to create a 2D translation matrix</span>
<span class="k">def</span> <span class="nf">map_matrix</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a 2D translation matrix.</span>

<span class="sd">    Args:</span>
<span class="sd">        tx (float): Translation amount in the x-direction.</span>
<span class="sd">        ty (float): Translation amount in the y-direction.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: A 2x3 transformation matrix for translation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create a 2x3 transformation matrix with translation values (tx, ty)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">M</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">M</span>

<span class="c1"># Apply the affine transformation to the image using warpAffine</span>
<span class="c1"># with translation values tx = 10 and ty = 20</span>
<span class="n">tx</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">ty</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">map_matrix</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Transformation Matrix (M) =&#39;</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span class="n">Out</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">warpAffine</span><span class="p">(</span><span class="n">Img</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">))</span>

<span class="c1"># Display the original and transformed images with titles</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">([</span><span class="n">Img</span><span class="p">,</span> <span class="n">Out</span><span class="p">],</span> 
                 <span class="p">[</span><span class="s1">&#39;Original Image&#39;</span><span class="p">,</span> <span class="s1">&#39;Translated Image ($b_</span><span class="si">{00}</span><span class="s1">$ = </span><span class="si">%i</span><span class="s1">, $b_</span><span class="si">{01}</span><span class="s1">$ = </span><span class="si">%i</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">)],</span>
                 <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Example: Translation Transformation&#39;</span><span class="p">)</span>
    
<span class="c1"># Define the source points (original triangle)</span>
<span class="n">src_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">200</span><span class="p">]])</span>

<span class="c1"># Define the destination points (how the triangle should be transformed)</span>
<span class="n">dst_pts</span> <span class="o">=</span> <span class="n">Transformation</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">src_pts</span><span class="p">)</span>
<span class="c1"># Mark the source and destination points on the images</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">src_pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">src_pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>  <span class="c1"># Mark source points on the original image</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">dst_pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dst_pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>  <span class="c1"># Mark destination points on the transformed image</span>

<span class="c1"># Add text indicating the size of the original and transformed images</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.02</span> <span class="o">*</span> <span class="n">Img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">s</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Size: </span><span class="si">{</span><span class="n">Img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> by </span><span class="si">{</span><span class="n">Img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
               <span class="n">size</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s2">&quot;square&quot;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;LightSkyBlue&#39;</span><span class="p">))</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.02</span> <span class="o">*</span> <span class="n">Out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">s</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Size: </span><span class="si">{</span><span class="n">Out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> by </span><span class="si">{</span><span class="n">Out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
               <span class="n">size</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s2">&quot;square&quot;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;LightSkyBlue&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Transformation Matrix (M) = [[ 1.  0. 10.]
 [ 0.  1. 20.]]
</pre></div>
</div>
<img alt="../_images/bcdbcbb5aff1b81e4cec9e6816d0841a287867b6f4ad71ba6d1117269fa16f6e.png" src="../_images/bcdbcbb5aff1b81e4cec9e6816d0841a287867b6f4ad71ba6d1117269fa16f6e.png" />
</div>
</div>
<div class="warning admonition">
<p class="admonition-title">Note</p>
<p>It is essential to note that in this context, <span class="math notranslate nohighlight">\(t_x\)</span> and <span class="math notranslate nohighlight">\(t_y\)</span> are equivalent to <span class="math notranslate nohighlight">\(b_{00}\)</span> and <span class="math notranslate nohighlight">\(b_{10}\)</span> respectively, as represented by:</p>
<div class="amsmath math notranslate nohighlight" id="equation-e7d19fd5-7429-4398-9f3a-fe3d0de13d39">
<span class="eqno">(8.18)<a class="headerlink" href="#equation-e7d19fd5-7429-4398-9f3a-fe3d0de13d39" title="Permalink to this equation">#</a></span>\[\begin{equation}
B = \begin{bmatrix} b_{00} \\ b_{10} \end{bmatrix}_{2 \times 1} \text{ and } 
B = \begin{bmatrix} t_{x} \\ t_{y} \end{bmatrix}_{2 \times 1}
\end{equation}\]</div>
</div>
<p>Given an input 2D vector <span class="math notranslate nohighlight">\(\mathbf{X} = \begin{bmatrix} x \\ y \end{bmatrix}\)</span>, the transformation <span class="math notranslate nohighlight">\(T\)</span> can be expressed as:</p>
<div class="amsmath math notranslate nohighlight" id="equation-92d041cb-eea1-481c-9cea-70c15cf43787">
<span class="eqno">(8.19)<a class="headerlink" href="#equation-92d041cb-eea1-481c-9cea-70c15cf43787" title="Permalink to this equation">#</a></span>\[\begin{equation}
\begin{bmatrix}
x' \\
y'
\end{bmatrix}
=
M \mathbf{X^*}
\end{equation}\]</div>
<p>Where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(M\)</span> is the 2x3 translation matrix created in the <code class="docutils literal notranslate"><span class="pre">map_matrix</span></code> function:</p></li>
</ul>
<div class="amsmath math notranslate nohighlight" id="equation-ee9ef369-d1e3-4de8-9ddd-b08c48b3d5bc">
<span class="eqno">(8.20)<a class="headerlink" href="#equation-ee9ef369-d1e3-4de8-9ddd-b08c48b3d5bc" title="Permalink to this equation">#</a></span>\[\begin{equation}
M =
\begin{bmatrix}
1 &amp; 0 &amp; t_x \\
0 &amp; 1 &amp; t_y
\end{bmatrix}
\end{equation}\]</div>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{X}\)</span> is the input vector:</p></li>
</ul>
<div class="amsmath math notranslate nohighlight" id="equation-4ec8ae75-0019-487d-b301-8a4cd5ae6fce">
<span class="eqno">(8.21)<a class="headerlink" href="#equation-4ec8ae75-0019-487d-b301-8a4cd5ae6fce" title="Permalink to this equation">#</a></span>\[\begin{equation}
\mathbf{X} =
\begin{bmatrix}
x \\ y
\end{bmatrix}
\end{equation}\]</div>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{X^*}\)</span> signifies an augmented form of the input vector:</p></li>
</ul>
<div class="amsmath math notranslate nohighlight" id="equation-286e2935-2e43-48ba-aa87-f405203e8517">
<span class="eqno">(8.22)<a class="headerlink" href="#equation-286e2935-2e43-48ba-aa87-f405203e8517" title="Permalink to this equation">#</a></span>\[\begin{equation} \mathbf{X} = \begin{bmatrix} x \\y \\ 1 \end{bmatrix}
\end{equation}\]</div>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(x'\)</span> and <span class="math notranslate nohighlight">\(y'\)</span> are the transformed coordinates, which are the result of applying the translation transformation <span class="math notranslate nohighlight">\(T\)</span> to the input vector <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>.</p></li>
</ul>
<p>In this specific code:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(t_x\)</span> and <span class="math notranslate nohighlight">\(t_y\)</span> are the translation amounts in the x and y directions, respectively. These values are set to 10 and 20 in the code.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">map_matrix</span></code> function creates the translation matrix <span class="math notranslate nohighlight">\(M\)</span> with the specified translation values <span class="math notranslate nohighlight">\((t_x, t_y)\)</span>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">cv2.warpAffine</span></code> function applies the translation transformation to the image using the matrix <span class="math notranslate nohighlight">\(M\)</span>.</p></li>
</ul>
<p>The result is a translated image where each pixel has been shifted by <span class="math notranslate nohighlight">\(tx\)</span> units in the x-direction and <span class="math notranslate nohighlight">\(ty\)</span> units in the y-direction.</p>
<hr class="docutils" />
<p>In this code example, we perform the following task(s):</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">map_matrix(tx,</span> <span class="pre">ty)</span></code>: This is a Python function that creates a 2D translation matrix. It accepts two arguments, <code class="docutils literal notranslate"><span class="pre">tx</span></code> for the translation amount in the x-direction and <code class="docutils literal notranslate"><span class="pre">ty</span></code> for the translation amount in the y-direction. The purpose of this function is to generate a transformation matrix for translation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">np.eye(3,</span> <span class="pre">dtype=float)[:2,</span> <span class="pre">:]</span></code>: This line creates a 2x3 transformation matrix. It initializes an identity matrix (<code class="docutils literal notranslate"><span class="pre">np.eye(3,</span> <span class="pre">dtype=float)</span></code>) and then selects only the first two rows and all columns, effectively creating a 2x3 matrix. The last column of this matrix is used to store the translation values.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">M[:,</span> <span class="pre">-1]</span> <span class="pre">=</span> <span class="pre">[tx,</span> <span class="pre">ty]</span></code>: This assigns the translation values <code class="docutils literal notranslate"><span class="pre">tx</span></code> and <code class="docutils literal notranslate"><span class="pre">ty</span></code> to the last column of the transformation matrix <code class="docutils literal notranslate"><span class="pre">M</span></code>. The translation matrix is now ready to be applied to an image.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx</span> <span class="pre">=</span> <span class="pre">10</span></code> and <code class="docutils literal notranslate"><span class="pre">ty</span> <span class="pre">=</span> <span class="pre">20</span></code>: These lines set the translation amounts for the transformation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">map_matrix(tx,</span> <span class="pre">ty)</span></code>: This line applies the <code class="docutils literal notranslate"><span class="pre">map_matrix</span></code> function with the translation values <code class="docutils literal notranslate"><span class="pre">tx</span></code> and <code class="docutils literal notranslate"><span class="pre">ty</span></code> and obtains the transformation matrix <code class="docutils literal notranslate"><span class="pre">M</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">print('Transformation</span> <span class="pre">Matrix</span> <span class="pre">(M)</span> <span class="pre">=',</span> <span class="pre">M)</span></code>: It prints the resulting transformation matrix <code class="docutils literal notranslate"><span class="pre">M</span></code> to the console.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Out</span> <span class="pre">=</span> <span class="pre">cv2.warpAffine(Img,</span> <span class="pre">M,</span> <span class="pre">(cols,</span> <span class="pre">rows))</span></code>: This code applies the translation transformation to the input image <code class="docutils literal notranslate"><span class="pre">Img</span></code> using the transformation matrix <code class="docutils literal notranslate"><span class="pre">M</span></code>. The result is stored in the variable <code class="docutils literal notranslate"><span class="pre">Out</span></code>. The dimensions <code class="docutils literal notranslate"><span class="pre">(cols,</span> <span class="pre">rows)</span></code> specify the size of the output image.</p></li>
</ol>
</section>
<section id="getrotationmatrix2d">
<h3><span class="section-number">8.2.2.4. </span>getRotationMatrix2D<a class="headerlink" href="#getrotationmatrix2d" title="Link to this heading">#</a></h3>
<p>In computer vision and image processing, the <code class="docutils literal notranslate"><span class="pre">cv2.getRotationMatrix2D</span></code> function, provided by the OpenCV library, is a valuable tool for computing a 2D rotation matrix. This matrix facilitates image rotations with precise control over the angle and scaling factor.</p>
<p>The function requires three primary arguments:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">center</span></code>: This parameter specifies the rotation center, typically represented as a tuple (x, y) denoting the coordinates of the central point around which the image will rotate.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angle</span></code>: The rotation angle is defined in degrees. <strong>A positive angle value indicates counterclockwise rotation, while a negative angle value signifies a clockwise rotation</strong>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scale</span></code>: The scaling factor applied to the image after rotation. It allows for resizing the image during the rotation process. A scale of 1 preserves the original size, values greater than 1 increase it, and values less than 1 decrease it.</p></li>
</ol>
<p>The function returns a 2x3 transformation matrix commonly referred to as the “rotation matrix.” This matrix encapsulates the geometric transformations necessary to achieve the specified rotation and scaling effects.</p>
<p>Mathematically, the rotation matrix is expressed as:</p>
<div class="amsmath math notranslate nohighlight" id="equation-6fa81682-7a63-45e1-9362-f4727ed07129">
<span class="eqno">(8.23)<a class="headerlink" href="#equation-6fa81682-7a63-45e1-9362-f4727ed07129" title="Permalink to this equation">#</a></span>\[\begin{equation}
\begin{bmatrix}
\alpha &amp; \beta &amp; (1 - \alpha) \cdot \texttt{center.x} - \beta \cdot \texttt{center.y} \\
- \beta &amp; \alpha &amp; \beta \cdot \texttt{center.x} + (1 - \alpha) \cdot \texttt{center.y}
\end{bmatrix}
\end{equation}\]</div>
<p>Where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\alpha = \texttt{scale} \cdot \cos(\texttt{angle})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\beta = \texttt{scale} \cdot \sin(\texttt{angle})\)</span></p></li>
</ul>
<p>This transformation preserves the rotation center at its original position. If the objective is to change the rotation center, you can adjust the shift accordingly.</p>
<p>For a more comprehensive understanding of this function, please refer to <a class="reference external" href="https://docs.opencv.org/3.4/da/d54/group__imgproc__transform.html#gafbbc470ce83812914a70abfb604f4326">this link</a>.</p>
<p><font color='Blue'><b>Example:</b></font> In this example, we load an image, rotate it by 25 degrees, and display both the original and rotated images.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_sample_image</span>

<span class="c1"># Load the sample image</span>
<span class="n">Img</span> <span class="o">=</span> <span class="n">load_sample_image</span><span class="p">(</span><span class="s1">&#39;flower.jpg&#39;</span><span class="p">)</span>

<span class="c1"># Rotate the image by 25 degrees</span>
<span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">Img</span><span class="o">.</span><span class="n">shape</span>
<span class="n">angle</span> <span class="o">=</span> <span class="mi">25</span>  <span class="c1"># Specify the rotation angle</span>
<span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># Scale factor (1.0 maintains the original size)</span>
<span class="n">rotation_center</span> <span class="o">=</span> <span class="p">(</span><span class="n">cols</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">rows</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Center of the image</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;rotation_center:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rotation_center</span><span class="p">)</span>

<span class="c1"># Get the rotation matrix using cv2.getRotationMatrix2D</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">getRotationMatrix2D</span><span class="p">(</span><span class="n">rotation_center</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Affine Transformation Matrix (M) =&#39;</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>

<span class="c1"># Apply the affine transformation to the image using warpAffine</span>
<span class="n">Out</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">warpAffine</span><span class="p">(</span><span class="n">Img</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">))</span>  <span class="c1"># Transformed image</span>

<span class="c1"># Display the original and rotated images</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">([</span><span class="n">Img</span><span class="p">,</span> <span class="n">Out</span><span class="p">],</span>
                 <span class="p">[</span><span class="s1">&#39;Original Image&#39;</span><span class="p">,</span> <span class="s1">&#39;Rotated Image&#39;</span><span class="p">],</span>
                 <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Image Rotation by </span><span class="si">{</span><span class="n">angle</span><span class="si">}</span><span class="s1"> Degrees&#39;</span><span class="p">)</span>

<span class="c1"># Define the source points (original triangle)</span>
<span class="n">src_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">200</span><span class="p">]])</span>

<span class="c1"># Define the destination points (how the triangle should be transformed)</span>
<span class="n">dst_pts</span> <span class="o">=</span> <span class="n">Transformation</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">src_pts</span><span class="p">)</span>

<span class="c1"># Mark the source and destination points on the images</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">src_pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">src_pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>  <span class="c1"># Mark source points on the original image</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">dst_pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dst_pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>  <span class="c1"># Mark destination points on the transformed image</span>

<span class="c1"># Add text indicating the size of the original and transformed images</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.02</span> <span class="o">*</span> <span class="n">Img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">s</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Size: </span><span class="si">{</span><span class="n">Img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> by </span><span class="si">{</span><span class="n">Img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
               <span class="n">size</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s2">&quot;square&quot;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;LightSkyBlue&#39;</span><span class="p">))</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.02</span> <span class="o">*</span> <span class="n">Out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">s</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Size: </span><span class="si">{</span><span class="n">Out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> by </span><span class="si">{</span><span class="n">Out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
               <span class="n">size</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s2">&quot;square&quot;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;LightSkyBlue&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>rotation_center:
(320, 213)
Affine Transformation Matrix (M) = [[  0.90630779   0.42261826 -60.0361816 ]
 [ -0.42261826   0.90630779 155.19428512]]
</pre></div>
</div>
<img alt="../_images/3926857daf738bd0f54780e2ada1f48fcf9a8963995cf226eaaa2651f743e045.png" src="../_images/3926857daf738bd0f54780e2ada1f48fcf9a8963995cf226eaaa2651f743e045.png" />
</div>
</div>
<p>Based on the provided values of <span class="math notranslate nohighlight">\(\theta = 25\)</span> (in degrees) and <span class="math notranslate nohighlight">\(\text{scale} = 1\)</span>, the resulting 2D rotation matrix <span class="math notranslate nohighlight">\(M\)</span> can be calculated as follows:</p>
<div class="amsmath math notranslate nohighlight" id="equation-cb02515c-e15a-46bf-ae91-05987ecf7060">
<span class="eqno">(8.24)<a class="headerlink" href="#equation-cb02515c-e15a-46bf-ae91-05987ecf7060" title="Permalink to this equation">#</a></span>\[\begin{equation}
\begin{bmatrix}
\alpha &amp; \beta &amp; (1 - \alpha) \cdot \text{center.x} - \beta \cdot \text{center.y} \\
- \beta &amp; \alpha &amp; \beta \cdot \text{center.x} + (1 - \alpha) \cdot \text{center.y}
\end{bmatrix}
\end{equation}\]</div>
<p>Where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\alpha = \text{scale} \cdot \cos(\theta)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\beta = \text{scale} \cdot \sin(\theta)\)</span></p></li>
</ul>
<p>Given that <span class="math notranslate nohighlight">\(\theta = 25\)</span> degrees and <span class="math notranslate nohighlight">\(\text{scale} = 1\)</span>, you can calculate <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> as follows:</p>
<div class="amsmath math notranslate nohighlight" id="equation-1a3a8515-1516-433a-a133-8b2cb57955b8">
<span class="eqno">(8.25)<a class="headerlink" href="#equation-1a3a8515-1516-433a-a133-8b2cb57955b8" title="Permalink to this equation">#</a></span>\[\begin{equation}
\alpha = 1 \cdot \cos(25^\circ) \approx 0.90630779
\end{equation}\]</div>
<div class="amsmath math notranslate nohighlight" id="equation-5760c93d-a599-4873-aaad-00a2c0d539db">
<span class="eqno">(8.26)<a class="headerlink" href="#equation-5760c93d-a599-4873-aaad-00a2c0d539db" title="Permalink to this equation">#</a></span>\[\begin{equation}
\beta = 1 \cdot \sin(25^\circ) \approx 0.42261826
\end{equation}\]</div>
<p>Now, you can calculate the elements of the rotation matrix <span class="math notranslate nohighlight">\(M\)</span> using these values and the center point <span class="math notranslate nohighlight">\((320, 213)\)</span>:</p>
<div class="amsmath math notranslate nohighlight" id="equation-d9e114b6-2031-4fbb-b034-5feedabb535a">
<span class="eqno">(8.27)<a class="headerlink" href="#equation-d9e114b6-2031-4fbb-b034-5feedabb535a" title="Permalink to this equation">#</a></span>\[\begin{equation}
M = \begin{bmatrix}
0.90630779 &amp; 0.42261826 &amp; (1 - 0.90630779) \cdot 320 - 0.42261826 \cdot 213 \\
-0.42261826 &amp; 0.90630779 &amp; 0.42261826 \cdot 320 + (1 - 0.90630779) \cdot 213
\end{bmatrix}
\end{equation}\]</div>
<p>The resulting matrix <span class="math notranslate nohighlight">\(M\)</span> will be:</p>
<div class="amsmath math notranslate nohighlight" id="equation-46dc6a10-2a65-4ee6-9260-b42fb290c84b">
<span class="eqno">(8.28)<a class="headerlink" href="#equation-46dc6a10-2a65-4ee6-9260-b42fb290c84b" title="Permalink to this equation">#</a></span>\[\begin{equation}
M = \begin{bmatrix}
0.90630779 &amp; 0.42261826 &amp; -60.0361816 \\
-0.42261826 &amp; 0.90630779 &amp; 155.19428512
\end{bmatrix}
\end{equation}\]</div>
<p>This is the 2D rotation matrix <span class="math notranslate nohighlight">\(M\)</span> corresponding to a rotation angle of 25 degrees and a scale factor of 1.</p>
<hr class="docutils" />
<p>In this code example, we perform the following task(s):</p>
<p>This code snippet demonstrates image rotation using OpenCV. Here’s a breakdown of each part:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">cv2.getRotationMatrix2D(rotation_center,</span> <span class="pre">angle,</span> <span class="pre">scale)</span></code>: This line calculates the rotation matrix for an affine transformation. It uses the <code class="docutils literal notranslate"><span class="pre">cv2.getRotationMatrix2D</span></code> function, which takes three arguments:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rotation_center</span></code>: This specifies the center of rotation, typically a tuple of (x, y) coordinates. The rotation will occur around this point.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angle</span></code>: This is the rotation angle in degrees. Positive angles indicate clockwise rotation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scale</span></code>: This argument allows for scaling the image during rotation. In most cases, it’s set to 1 for no scaling.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">print('Affine</span> <span class="pre">Transformation</span> <span class="pre">Matrix</span> <span class="pre">(M)</span> <span class="pre">=',</span> <span class="pre">M)</span></code>: This line prints the calculated affine transformation matrix <code class="docutils literal notranslate"><span class="pre">M</span></code> to the console. The matrix represents the rotation transformation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Out</span> <span class="pre">=</span> <span class="pre">cv2.warpAffine(Img,</span> <span class="pre">M,</span> <span class="pre">(cols,</span> <span class="pre">rows))</span></code>: This code applies the calculated affine transformation matrix <code class="docutils literal notranslate"><span class="pre">M</span></code> to the input image <code class="docutils literal notranslate"><span class="pre">Img</span></code>. It uses the <code class="docutils literal notranslate"><span class="pre">cv2.warpAffine</span></code> function to perform the rotation. The result is stored in the variable <code class="docutils literal notranslate"><span class="pre">Out</span></code>, which represents the rotated image.</p></li>
</ol>
</section>
</section>
<section id="resizing-images-with-opencv">
<h2><span class="section-number">8.2.3. </span>Resizing Images with OpenCV<a class="headerlink" href="#resizing-images-with-opencv" title="Link to this heading">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">resize</span></code> function in OpenCV is a versatile tool for adjusting the size of images, whether making them smaller or larger. It offers several options for defining the output size or using scaling factors to control the resizing process, providing the flexibility needed for various image manipulation tasks <span id="id7">[<a class="reference internal" href="../References.html#id19" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="../References.html#id50" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p><strong>Key Concepts:</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">resize</span></code> function is essential for handling image dimensions. Here’s a breakdown of its capabilities:</p>
<ol class="arabic">
<li><p><strong>Resizing an Image:</strong>
The primary purpose of <code class="docutils literal notranslate"><span class="pre">resize</span></code> is to change the size of an image. This can involve reducing or increasing the image’s dimensions. The function allows explicit size specification or resizing based on scaling factors (<code class="docutils literal notranslate"><span class="pre">fx</span></code> and <code class="docutils literal notranslate"><span class="pre">fy</span></code>). Importantly, the initial type or size of the output image (<code class="docutils literal notranslate"><span class="pre">dst</span></code>) is not used. Instead, it’s determined based on the source image (<code class="docutils literal notranslate"><span class="pre">src</span></code>), the desired output size (<code class="docutils literal notranslate"><span class="pre">dsize</span></code>), and the specified scaling factors.</p></li>
<li><p><strong>Explicit Output Size:</strong>
If you want to resize <code class="docutils literal notranslate"><span class="pre">src</span></code> to fit a pre-created destination image <code class="docutils literal notranslate"><span class="pre">dst</span></code>, you can achieve this by calling the function as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">resize</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">dst</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">dsize</span></code> is set to match the size of <code class="docutils literal notranslate"><span class="pre">dst</span></code>, and the scaling factors <code class="docutils literal notranslate"><span class="pre">fx</span></code> and <code class="docutils literal notranslate"><span class="pre">fy</span></code> are automatically computed based on that.</p>
</li>
<li><p><strong>Using Scaling Factors:</strong>
You can also use scaling factors to control the resizing process. For instance, to decrease the size of the image by a factor of 2 in both the horizontal and vertical directions (decimation), you can use the following approach:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">resize</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">Size</span><span class="p">(),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">fx</span></code> and <code class="docutils literal notranslate"><span class="pre">fy</span></code> are explicitly specified, and the function calculates the destination image size based on these factors.</p>
</li>
<li><p><strong>Selecting Interpolation:</strong>
When shrinking an image, the <code class="docutils literal notranslate"><span class="pre">INTER_AREA</span></code> interpolation method is recommended for the best results in terms of image quality. On the other hand, when enlarging an image, using <code class="docutils literal notranslate"><span class="pre">INTER_CUBIC</span></code> (higher quality, but slower) or <code class="docutils literal notranslate"><span class="pre">INTER_LINEAR</span></code> (faster but still acceptable quality) interpolation methods is generally recommended.</p></li>
</ol>
<p><strong>Function Parameters:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">src</span></code>: The input image to be resized.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The output image. Its size can be explicitly set using <code class="docutils literal notranslate"><span class="pre">dsize</span></code>, or it can be determined automatically based on <code class="docutils literal notranslate"><span class="pre">src.size()</span></code>, <code class="docutils literal notranslate"><span class="pre">fx</span></code>, and <code class="docutils literal notranslate"><span class="pre">fy</span></code>. The type of <code class="docutils literal notranslate"><span class="pre">dst</span></code> matches the type of <code class="docutils literal notranslate"><span class="pre">src</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dsize</span></code>: The desired output image size. If set to zero (None in Python), the function calculates it as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dsize</span> <span class="o">=</span> <span class="n">Size</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">fx</span> <span class="o">*</span> <span class="n">src</span><span class="o">.</span><span class="n">cols</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">fy</span> <span class="o">*</span> <span class="n">src</span><span class="o">.</span><span class="n">rows</span><span class="p">))</span>
</pre></div>
</div>
<p>Either <code class="docutils literal notranslate"><span class="pre">dsize</span></code> or both <code class="docutils literal notranslate"><span class="pre">fx</span></code> and <code class="docutils literal notranslate"><span class="pre">fy</span></code> must be non-zero.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">fx</span></code>: The scaling factor along the horizontal axis (width). If <code class="docutils literal notranslate"><span class="pre">fx</span></code> is 0, it’s computed as <code class="docutils literal notranslate"><span class="pre">(double)dsize.width</span> <span class="pre">/</span> <span class="pre">src.cols</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fy</span></code>: The scaling factor along the vertical axis (height). If <code class="docutils literal notranslate"><span class="pre">fy</span></code> is 0, it’s computed as <code class="docutils literal notranslate"><span class="pre">(double)dsize.height</span> <span class="pre">/</span> <span class="pre">src.rows</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">interpolation</span></code>: The interpolation method used during the resizing operation (e.g., <code class="docutils literal notranslate"><span class="pre">INTER_NEAREST</span></code>, <code class="docutils literal notranslate"><span class="pre">INTER_LINEAR</span></code>, <code class="docutils literal notranslate"><span class="pre">INTER_CUBIC</span></code>, <code class="docutils literal notranslate"><span class="pre">INTER_LANCZOS4</span></code>).</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">resize</span></code> function allows you to resize images while maintaining control over the output size and selecting appropriate interpolation methods to achieve the desired quality.</p>
<p><strong>Syntax:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dsize</span><span class="p">[,</span> <span class="n">dst</span><span class="p">[,</span> <span class="n">fx</span><span class="p">[,</span> <span class="n">fy</span><span class="p">[,</span> <span class="n">interpolation</span><span class="p">]]]])</span> <span class="o">-&gt;</span> <span class="n">dst</span>
</pre></div>
</div>
<p>Here’s what each parameter does:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src</span></code>: The input image that you want to resize. It should be a NumPy array (image) in most cases.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dsize</span></code>: The desired size (width and height) of the output image. It’s specified as a tuple (width, height). If you provide this parameter, the <code class="docutils literal notranslate"><span class="pre">fx</span></code> and <code class="docutils literal notranslate"><span class="pre">fy</span></code> parameters (scaling factors) are ignored.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code> (optional): The output image where the resized image will be stored. If not provided, a new image will be created to store the result.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fx</span></code> (optional): The scale factor along the horizontal axis (width) by which you want to resize the image. If you provide <code class="docutils literal notranslate"><span class="pre">fx</span></code>, the <code class="docutils literal notranslate"><span class="pre">dsize</span></code> parameter is ignored on that axis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fy</span></code> (optional): The scale factor along the vertical axis (height) by which you want to resize the image. If you provide <code class="docutils literal notranslate"><span class="pre">fy</span></code>, the <code class="docutils literal notranslate"><span class="pre">dsize</span></code> parameter is ignored on that axis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">interpolation</span></code> (optional): The interpolation method to be used during the resizing operation. Interpolation determines how pixel values are computed for the output image based on the input image. Common <a class="reference external" href="https://en.wikipedia.org/wiki/Bicubic_interpolation">interpolation</a> methods include:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cv2.INTER_NEAREST</span></code>: Nearest-neighbor interpolation (fast but may produce blocky results).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cv2.INTER_LINEAR</span></code>: Bilinear interpolation (good for most general-purpose resizing).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cv2.INTER_CUBIC</span></code>: Bicubic interpolation (better quality, but slower).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cv2.INTER_LANCZOS4</span></code>: Lanczos interpolation (high-quality but slower).</p></li>
</ul>
</li>
</ol>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.resize()</span></code> function resizes the input image based on the specified size or scaling factors and the chosen interpolation method. The function returns the resized image, and if you provided the <code class="docutils literal notranslate"><span class="pre">dst</span></code> parameter, the resized image is stored in the <code class="docutils literal notranslate"><span class="pre">dst</span></code> array; otherwise, a new image is created and returned. The <code class="docutils literal notranslate"><span class="pre">dst</span></code> parameter allows you to reuse an existing image array for efficiency.</p>
<p><font color='Blue'><b>Example:</b></font> In this example, we’ll explore an image processing task that involves resizing an image using cubic interpolation. Cubic interpolation is a method for resizing images while maintaining smooth transitions between pixels. We’ll load a sample image, apply the resizing operation, and visualize both the original and resized images. Additionally, we’ll add text annotations to display the sizes of the original and resized images for reference.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load the sample image &#39;china.jpg&#39;</span>
<span class="n">Img</span> <span class="o">=</span> <span class="n">load_sample_image</span><span class="p">(</span><span class="s1">&#39;china.jpg&#39;</span><span class="p">)</span>
                        
<span class="c1"># Resize the original image using cubic interpolation</span>
<span class="n">Out</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">Img</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">INTER_CUBIC</span><span class="p">)</span>

<span class="c1"># Display the original and resized images with titles</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">([</span><span class="n">Img</span><span class="p">,</span> <span class="n">Out</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Original Image&#39;</span><span class="p">,</span> <span class="s1">&#39;Resized Image&#39;</span><span class="p">],</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Image Resize&#39;</span><span class="p">)</span>

<span class="c1"># Add text indicating the size of the original and resized images</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.02</span> <span class="o">*</span> <span class="n">Img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">s</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Size: </span><span class="si">{</span><span class="n">Img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> by </span><span class="si">{</span><span class="n">Img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
               <span class="n">size</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s2">&quot;square&quot;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;LightSkyBlue&#39;</span><span class="p">))</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.02</span> <span class="o">*</span> <span class="n">Out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">s</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Size: </span><span class="si">{</span><span class="n">Out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> by </span><span class="si">{</span><span class="n">Out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
               <span class="n">size</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s2">&quot;square&quot;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;LightSkyBlue&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/a1872475e370b50f1d09491d8e4090eb048c59918810a97537bc4f28bae9bbf6.png" src="../_images/a1872475e370b50f1d09491d8e4090eb048c59918810a97537bc4f28bae9bbf6.png" />
</div>
</div>
<p>In this code example, we perform the following task(s):</p>
<p><code class="docutils literal notranslate"><span class="pre">Out</span> <span class="pre">=</span> <span class="pre">cv2.resize(Img,</span> <span class="pre">None,</span> <span class="pre">fx=2,</span> <span class="pre">fy=2,</span> <span class="pre">interpolation=cv2.INTER_CUBIC)</span></code>: This line resizes an input image <code class="docutils literal notranslate"><span class="pre">Img</span></code> and stores the result in the variable <code class="docutils literal notranslate"><span class="pre">Out</span></code>. The <code class="docutils literal notranslate"><span class="pre">cv2.resize</span></code> function is used for this purpose, and it takes several arguments:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Img</span></code>: This is the input image that you want to resize.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: The second argument represents the output image size. In this case, it is set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, which means the size of the output image will be determined automatically based on the scaling factors provided in the next two arguments.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fx=2</span></code> and <code class="docutils literal notranslate"><span class="pre">fy=2</span></code>: These arguments specify the scaling factors for resizing. <code class="docutils literal notranslate"><span class="pre">fx</span></code> is the scaling factor for the width, and <code class="docutils literal notranslate"><span class="pre">fy</span></code> is the scaling factor for the height. In this case, both factors are set to 2, which means the image will be scaled up by a factor of 2 in both dimensions, effectively doubling its size.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">interpolation=cv2.INTER_CUBIC</span></code>: This argument defines the interpolation method used during the resizing process. <code class="docutils literal notranslate"><span class="pre">cv2.INTER_CUBIC</span></code> is used here, which corresponds to the bicubic interpolation method. Bicubic interpolation produces high-quality results when upscaling an image, resulting in a smoother and more detailed output.</p></li>
</ul>
</section>
<section id="warp-perspective-optional-content">
<h2><span class="section-number">8.2.4. </span>Warp Perspective (Optional Content)<a class="headerlink" href="#warp-perspective-optional-content" title="Link to this heading">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.warpPerspective()</span></code> function in the Python OpenCV library is a powerful tool used for performing perspective transformations on an input image. These transformations allow you to change the perspective view of an object within an image, simulating effects like changing the viewpoint or correcting for distortions caused by the camera’s perspective. The primary purpose of this function is to apply a given 3x3 transformation matrix to the input image, resulting in a transformed output image <span id="id8">[<a class="reference internal" href="../References.html#id19" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="../References.html#id50" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p><strong>Perspective Transformation</strong></p>
<p>Perspective transformations are essential for various computer vision tasks, including image rectification, object recognition, and more. They involve manipulating the positions of points in an image, effectively warping the image based on a specified transformation matrix. This matrix, denoted as <code class="docutils literal notranslate"><span class="pre">M</span></code>,</p>
<div class="amsmath math notranslate nohighlight" id="equation-c7ad9ec4-9440-4258-976d-58a954719aae">
<span class="eqno">(8.29)<a class="headerlink" href="#equation-c7ad9ec4-9440-4258-976d-58a954719aae" title="Permalink to this equation">#</a></span>\[\begin{equation}
M = \begin{bmatrix} M_{11} &amp; M_{12} &amp; M_{13} \\M_{21} &amp; M_{22} &amp; M_{23}  \\M_{31} &amp; M_{32} &amp; M_{33} \end{bmatrix}
\end{equation}\]</div>
<p>describes how the points in the source image (<code class="docutils literal notranslate"><span class="pre">src</span></code>) should be transformed to obtain their corresponding positions in the destination image (<code class="docutils literal notranslate"><span class="pre">dst</span></code>).</p>
<p>The transformation is defined by the following equation:</p>
<div class="amsmath math notranslate nohighlight" id="equation-45ad9372-1a1b-4cf0-9959-7baebe386b64">
<span class="eqno">(8.30)<a class="headerlink" href="#equation-45ad9372-1a1b-4cf0-9959-7baebe386b64" title="Permalink to this equation">#</a></span>\[\begin{equation}
\texttt{dst} (x,y) = \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} , \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right )
\end{equation}\]</div>
<p>When the flag <code class="docutils literal notranslate"><span class="pre">WARP_INVERSE_MAP</span></code> is set, the function uses the inverse of the transformation matrix for the calculation. Otherwise, the transformation is inverted using the <code class="docutils literal notranslate"><span class="pre">invert</span></code> function before being applied. The function does not operate in-place; it generates a new transformed image as the output.</p>
<p><strong>Parameters</strong></p>
<p>Here’s a detailed explanation of the parameters used in the <code class="docutils literal notranslate"><span class="pre">cv2.warpPerspective()</span></code> function:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src</span></code>: This parameter represents the input image you want to transform using the perspective transformation. It should be a numpy array, representing the image you wish to warp.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">M</span></code>: The <code class="docutils literal notranslate"><span class="pre">M</span></code> parameter is a 3x3 transformation matrix that defines the perspective transformation. This matrix describes how the points in the source image (<code class="docutils literal notranslate"><span class="pre">src</span></code>) should be transformed to obtain the corresponding points in the destination image (<code class="docutils literal notranslate"><span class="pre">dst</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dsize</span></code>: The <code class="docutils literal notranslate"><span class="pre">dsize</span></code> parameter specifies the size of the output image (<code class="docutils literal notranslate"><span class="pre">dst</span></code>). It is a tuple containing the width and height of the destination image. The transformed input image (<code class="docutils literal notranslate"><span class="pre">src</span></code>) will be resized to this size.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code> (optional): The <code class="docutils literal notranslate"><span class="pre">dst</span></code> parameter serves as the output image where the result of the perspective transformation will be stored. If this parameter is not provided, a new image will be created to hold the transformed result.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">flags</span></code> (optional): The <code class="docutils literal notranslate"><span class="pre">flags</span></code> parameter provides additional transformation options. It can be a combination of transformation flags, but it is often set to <code class="docutils literal notranslate"><span class="pre">cv2.INTER_LINEAR</span></code> for bilinear interpolation, which provides a good trade-off between speed and quality.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">borderMode</span></code> (optional): The <code class="docutils literal notranslate"><span class="pre">borderMode</span></code> parameter specifies how the border of the output image (<code class="docutils literal notranslate"><span class="pre">dst</span></code>) should be filled. It can be set to different border modes, such as <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_CONSTANT</span></code> or <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REPLICATE</span></code>, depending on the desired behavior.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">borderValue</span></code> (optional): The <code class="docutils literal notranslate"><span class="pre">borderValue</span></code> parameter is used to specify the value used for padding if the <code class="docutils literal notranslate"><span class="pre">borderMode</span></code> is set to <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_CONSTANT</span></code>.</p></li>
</ul>
<p><strong>Function Signature</strong></p>
<p>Here’s the structure of the function signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">warpPerspective</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">dsize</span><span class="p">[,</span> <span class="n">dst</span><span class="p">[,</span> <span class="n">flags</span><span class="p">[,</span> <span class="n">borderMode</span><span class="p">[,</span> <span class="n">borderValue</span><span class="p">]]]])</span> <span class="o">-&gt;</span> <span class="n">dst</span>
</pre></div>
</div>
<p><strong>Usage and Importance</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.warpPerspective()</span></code> function is a fundamental component in many image processing pipelines. It enables handling perspective effects, correcting image distortions, and preparing images for further analysis or visualization. By understanding and utilizing perspective transformations, you can significantly enhance the capabilities of your computer vision applications.</p>
<p>For more detailed information and examples of using <code class="docutils literal notranslate"><span class="pre">warpPerspective</span></code>, you can refer to the <a class="reference external" href="https://docs.opencv.org/2.4/modules/imgproc/doc/geometric_transformations.html#cv2.warpPerspective">OpenCV documentation</a> and the <a class="reference external" href="https://docs.opencv.org/3.4/da/d54/group__imgproc__transform.html#gaf73673a7e8e18ec6963e3774e6a94b87">function description</a>. This function is essential for tasks that require precise geometric adjustments in images, making it a valuable tool in various computer vision scenarios.</p>
<p><font color='Blue'><b>Example</b></font>: In this example, we explore perspective transformation, a crucial concept in image processing. We define source and destination points to describe how we want to alter the image’s perspective. Using these points, we calculate a transformation matrix (M). Then, we apply this matrix to the input image, transforming its perspective. We visualize both the original and transformed images, including annotations for size reference and marked points to show the transformation’s effect.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Define the source and destination points for perspective transformation</span>
<span class="n">src_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">],</span> <span class="p">[</span><span class="mi">350</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">380</span><span class="p">],</span> <span class="p">[</span><span class="mi">380</span><span class="p">,</span> <span class="mi">400</span><span class="p">]])</span>  <span class="c1"># Source points</span>
<span class="n">dst_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">400</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">400</span><span class="p">],</span> <span class="p">[</span><span class="mi">400</span><span class="p">,</span> <span class="mi">400</span><span class="p">]])</span>  <span class="c1"># Destination points</span>

<span class="c1"># Calculate the perspective transformation matrix</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">getPerspectiveTransform</span><span class="p">(</span><span class="n">src_pts</span><span class="p">,</span> <span class="n">dst_pts</span><span class="p">)</span>

<span class="c1"># Apply the perspective transformation to the input image</span>
<span class="n">Out</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">warpPerspective</span><span class="p">(</span><span class="n">Img</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">dsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">400</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;M =&#39;</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>

<span class="c1"># Display the original and transformed images with titles</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">([</span><span class="n">Img</span><span class="p">,</span> <span class="n">Out</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Original Image&#39;</span><span class="p">,</span> <span class="s1">&#39;Warped Image&#39;</span><span class="p">],</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Warp Perspective&#39;</span><span class="p">)</span>

<span class="c1"># Add text to indicate the size of the original and transformed images</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.02</span> <span class="o">*</span> <span class="n">Img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">s</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Size: </span><span class="si">{</span><span class="n">Img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> by </span><span class="si">{</span><span class="n">Img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
               <span class="n">size</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s2">&quot;square&quot;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;LightSkyBlue&#39;</span><span class="p">))</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.6</span> <span class="o">*</span> <span class="n">Img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">y</span><span class="o">=</span><span class="n">Out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Size: </span><span class="si">{</span><span class="n">Out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> by </span><span class="si">{</span><span class="n">Out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
               <span class="n">size</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s2">&quot;square&quot;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;LightSkyBlue&#39;</span><span class="p">))</span>

<span class="c1"># Mark the source and destination points on the images</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">src_pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">src_pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>  <span class="c1"># Mark source points on the original image</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">dst_pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dst_pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>  <span class="c1"># Mark destination points on the transformed image</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>M = [[ 1.52835807e+00  1.43283569e-01 -8.50149178e+01]
 [ 5.25237016e-02  1.57571105e+00 -9.71688479e+01]
 [ 3.13555899e-04  6.58838004e-04  1.00000000e+00]]
</pre></div>
</div>
<img alt="../_images/4352a5ca19d7a79f3effb266f77fb8f6c927e018754f4965372d5e5c8dc322d6.png" src="../_images/4352a5ca19d7a79f3effb266f77fb8f6c927e018754f4965372d5e5c8dc322d6.png" />
</div>
</div>
<p>In this code example, we perform the following task(s):</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src_pts</span></code> and <code class="docutils literal notranslate"><span class="pre">dst_pts</span></code>: These are two sets of points used to define the source and destination points for the perspective transformation. In this context:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src_pts</span></code> represents the coordinates of four points in the source image that define the region you want to transform. These points are specified as a NumPy array of shape (4, 2), where each row represents the (x, y) coordinates of a point.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst_pts</span></code> represents the corresponding destination points in the transformed image. Like <code class="docutils literal notranslate"><span class="pre">src_pts</span></code>, it’s also a NumPy array of shape (4, 2), where each row specifies the (x, y) coordinates of a point in the destination image. These points define where the source region will be mapped to in the transformed image.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">cv2.getPerspectiveTransform(src_pts,</span> <span class="pre">dst_pts)</span></code>: This line calculates the perspective transformation matrix <code class="docutils literal notranslate"><span class="pre">M</span></code> using the source and destination points. The <code class="docutils literal notranslate"><span class="pre">cv2.getPerspectiveTransform</span></code> function takes the source and destination points as arguments and returns the transformation matrix. This matrix describes how points in the source image are mapped to points in the destination image, considering perspective distortion.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Out</span> <span class="pre">=</span> <span class="pre">cv2.warpPerspective(Img,</span> <span class="pre">M,</span> <span class="pre">dsize=(400,</span> <span class="pre">400))</span></code>: This code applies the calculated perspective transformation to the input image <code class="docutils literal notranslate"><span class="pre">Img</span></code>. The <code class="docutils literal notranslate"><span class="pre">cv2.warpPerspective</span></code> function takes three arguments:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Img</span></code>: This is the input image that you want to transform.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">M</span></code>: This is the perspective transformation matrix obtained earlier using source and destination points.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dsize</span></code>: This argument specifies the size of the output image after the transformation. In this case, it’s set to (400, 400), meaning that the resulting image will have dimensions of 400x400 pixels.</p></li>
</ul>
</li>
</ol>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./chapter_08"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="ENGG680_C08S01.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">8.1. </span>Getting Started with OpenCV</p>
      </div>
    </a>
    <a class="right-next"
       href="ENGG680_C08S03.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">8.3. </span>Image Thresholding</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#sample-images">8.2.1. Sample Images</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#affine-transformations">8.2.2. Affine Transformations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#how-to-derive-an-affine-transformation">8.2.2.1. How to Derive an Affine Transformation?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#getaffinetransform">8.2.2.2. getAffineTransform</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#image-wrap">8.2.2.3. Image Wrap</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#getrotationmatrix2d">8.2.2.4. getRotationMatrix2D</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#resizing-images-with-opencv">8.2.3. Resizing Images with OpenCV</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#warp-perspective-optional-content">8.2.4. Warp Perspective (Optional Content)</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Hatef Dastour
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>