

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>8.1. Getting Started with OpenCV &#8212; Introduction to Digital Engineering</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=365ca57ee442770a23c6" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=365ca57ee442770a23c6" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=365ca57ee442770a23c6" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=365ca57ee442770a23c6" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/myfile.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=365ca57ee442770a23c6" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=365ca57ee442770a23c6" />
  <script src="../_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=365ca57ee442770a23c6"></script>

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'chapter_08/ENGG_680_C08S1';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="8.2. Geometric Transformations" href="ENGG_680_C08S2.html" />
    <link rel="prev" title="8. An Introduction to Computer Vision" href="ReadMe.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../Introduction.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Introduction to Digital Engineering - Home"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Introduction to Digital Engineering - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_01/ReadMe.html">1. Introduction to Python Programming</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_01/ENGG_680_C01S1.html">1.1. Variable names, Expressions and statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_01/ENGG_680_C01S2.html">1.2. Fundamental Concepts and Operations in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_01/ENGG_680_C01S3.html">1.3. Functions</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_02/ReadMe.html">2. Control Flow: Conditionals, Recursion, and Iteration</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_02/ENGG_680_C02S1.html">2.1. Conditionals and recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_02/ENGG_680_C02S2.html">2.2. Iteration</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_03/ReadMe.html">3. Data Structures and File Handling in Python</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_03/ENGG_680_C03S1.html">3.1. Strings in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_03/ENGG_680_C03S2.html">3.2. Python Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_03/ENGG_680_C03S3.html">3.3. Python Dictionaries: Key-Value Pairs in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_03/ENGG_680_C03S4.html">3.4. Python Tuples: Immutable Sequences in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_03/ENGG_680_C03S5.html">3.5. Python Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_03/ENGG_680_C03S6.html">3.6. Files in Python (Optional Section)</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_04/ReadMe.html">4. Classes and Objects</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_04/ENGG_680_C04S1.html">4.1. Introduction to Classes and Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_04/ENGG_680_C04S2.html">4.2. Inheritance and Polymorphism</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_04/ENGG_680_C04S3.html">4.3. Encapsulation and Abstraction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_04/ENGG_680_C04S4.html">4.4. Copying Objects (Optional Section)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_04/ENGG_680_C04S5.html">4.5. Magic Methods (Dunder Methods) in Python (Optional Section)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_04/ENGG_680_C04S6.html">4.6. Examples of Classes (Optional Section)</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_05/ReadMe.html">5. Introduction to NumPy</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_05/ENGG_680_C05S1.html">5.1. Basics of Numpy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_05/ENGG_680_C05S2.html">5.2. NumPy Function Reference and Usage Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_05/ENGG_680_C05S3.html">5.3. Advanced Numpy Concepts (Optional Section)</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_06/ReadMe.html">6. Working with Data using Pandas</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_06/ENGG_680_C06S1.html">6.1. An Introduction to Pandas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_06/ENGG_680_C06S2.html">6.2. DataFrame and Series Indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_06/ENGG_680_C06S3.html">6.3. Pandas Data Selection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_06/ENGG_680_C06S4.html">6.4. Handling Missing Data in Pandas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_06/ENGG_680_C06S5.html">6.5. Combining Datasets using Pandas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_06/ENGG_680_C06S6.html">6.6. Aggregation and Grouping in Pandas</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_07/ReadMe.html">7. Data Visualization using Python</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_07/ENGG_680_C07S1.html">7.1. Getting started with Matplotlib</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_07/ENGG_680_C07S2.html">7.2. Matplotlib Styles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_07/ENGG_680_C07S3.html">7.3. Matplotlib interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_07/ENGG_680_C07S4.html">7.4. Adjusting the Plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_07/ENGG_680_C07S5.html">7.5. Seaborn plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_07/ENGG_680_C07S6.html">7.6. Python Plotting Guide</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="ReadMe.html">8. An Introduction to Computer Vision</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2 current active"><a class="current reference internal" href="#">8.1. Getting Started with OpenCV</a></li>
<li class="toctree-l2"><a class="reference internal" href="ENGG_680_C08S2.html">8.2. Geometric Transformations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ENGG_680_C08S3.html">8.3. Image Thresholding</a></li>
<li class="toctree-l2"><a class="reference internal" href="ENGG_680_C08S4.html">8.4. Image Filtering</a></li>
<li class="toctree-l2"><a class="reference internal" href="ENGG_680_C08S5.html">8.5. Drawing Functions (Optional Section)</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_09/ReadMe.html">9. An Introduction to Machine Learning</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_09/ENGG_680_C09S1.html">9.1. Prologue: Statistical Metrics and Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_09/ENGG_680_C09S2.html">9.2. An Introduction to Linear Regression</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter_09/ENGG_680_C09S3.html">9.3. Multiple Linear Regression</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter_10/ReadMe.html">10. Tree-Based Methods</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-10"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter_10/ENGG_680_C10S1.html">10.1. Fundamental Structure of Decision Trees</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../appendixes/ReadMe.html">11. Appendices</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-11"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendixes/SampleQuestions_1.html">11.1. Sample Questions 1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendixes/SampleQuestions_2.html">11.2. Sample Questions 2</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../References.html">12. References</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Getting Started with OpenCV</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#sample-images">8.1.1. Sample Images</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#accessing-and-manipulating-pixel-values-in-images">8.1.2. Accessing and Manipulating Pixel Values in Images</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#adding-padding-exploring-border-types-in-opencv-optional-content">8.1.3. Adding Padding: Exploring Border Types in OpenCV (Optional Content)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#image-blending-using-the-cv2-addweighted-function">8.1.4. Image Blending: Using the <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> Function</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bitwise-operations-in-opencv-optional-content">8.1.5. Bitwise Operations in OpenCV (Optional Content)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bitwise-and-operation-with-cv2-bitwise-and">8.1.5.1. Bitwise AND Operation with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#element-wise-bitwise-or-with-cv2-bitwise-or">8.1.5.2. Element-Wise Bitwise OR with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#colorspace-conversion-with-cv2-cvtcolor">8.1.6. Colorspace Conversion with <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rgb-to-grayscale">8.1.6.1. RGB to Grayscale</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rgb-to-hsv">8.1.6.2. RGB to HSV</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="getting-started-with-opencv">
<h1><span class="section-number">8.1. </span>Getting Started with OpenCV<a class="headerlink" href="#getting-started-with-opencv" title="Permalink to this heading">#</a></h1>
<p>OpenCV (Open Source Computer Vision) is a widely acclaimed open-source library that forms the backbone of many computer vision applications. With a rich history dating back to its inception in 1999, OpenCV has evolved into a versatile toolkit that empowers developers to create innovative solutions in the field of image and video analysis. Released under a permissive BSD license, OpenCV has garnered a strong community of researchers, engineers, and enthusiasts who contribute to its growth and enhancement <span id="id1">[<a class="reference internal" href="../References.html#id37" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="../References.html#id38" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p>CV2, often referred to as “opencv-python,” is the Python wrapper for the OpenCV library. This wrapper brings the power of OpenCV’s vast functionality to the Python programming ecosystem, making it accessible and convenient for Python developers. With CV2, you can perform a wide range of tasks, including image processing, feature extraction, object detection, video analysis, and more, using the intuitive and expressive syntax of Python.</p>
<p>CV2’s integration with Python has contributed to its popularity and ubiquity in the field of computer vision. It offers a comprehensive suite of functions and tools that enable users to manipulate, analyze, and interpret visual data effortlessly. From simple tasks like image resizing and filtering to complex tasks such as building deep learning models for image recognition, CV2 provides the necessary building blocks.</p>
<section id="sample-images">
<h2><span class="section-number">8.1.1. </span>Sample Images<a class="headerlink" href="#sample-images" title="Permalink to this heading">#</a></h2>
<p>In this section, we employ <code class="docutils literal notranslate"><span class="pre">Lunenburg.jpg</span></code> and <code class="docutils literal notranslate"><span class="pre">Varenna.jpg</span></code> from my personal image library. Both images were adjusted to a size of 2000 by 1500 to facilitate more straightforward calculations.</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Lunenburg,_Nova_Scotia">Lunenburg</a> (a town in Nova Scotia, Canada) is known for its well-preserved colonial architecture and UNESCO World Heritage status.</p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Varenna">Varenna</a> features the picturesque village of Varenna on the shores of Lake Como, Italy, celebrated for its charming waterfront and stunning natural beauty.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">io</span>

<span class="c1"># Initialize empty list for storing images</span>
<span class="n">Images</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Define image names and their corresponding URLs</span>
<span class="n">Names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Lunenburg&#39;</span><span class="p">,</span> <span class="s1">&#39;Varenna&#39;</span><span class="p">]</span>
<span class="n">Urls</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;https://raw.githubusercontent.com/HatefDastour/ENGG_680/main/Files/</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">.jpg&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">Names</span><span class="p">]</span>

<span class="c1"># Load images from the specified URLs and create a dictionary with image names as keys</span>
<span class="n">Images</span> <span class="o">=</span> <span class="p">[</span><span class="n">io</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">Urls</span><span class="p">]</span>
<span class="n">Images_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">Names</span><span class="p">,</span> <span class="n">Images</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import necessary libraries</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  <span class="c1"># Import the plotting library</span>

<span class="c1"># Set font properties for plots</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.family&#39;</span><span class="p">:</span> <span class="s1">&#39;Calibri&#39;</span><span class="p">,</span> <span class="s1">&#39;axes.titlesize&#39;</span><span class="p">:</span> <span class="mi">16</span><span class="p">})</span>

<span class="c1"># Define a function to display images with titles and optional settings</span>
<span class="k">def</span> <span class="nf">ImShow</span><span class="p">(</span><span class="n">Images</span><span class="p">,</span> <span class="n">Names</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Images&#39;</span><span class="p">,</span> <span class="n">grayscale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">9.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Display a pair of images side by side.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    Images (list): List of two images to be displayed.</span>
<span class="sd">    Names (list): List of two names or labels for the images.</span>
<span class="sd">    title (str, optional): Title for the figure. Defaults to &#39;Images&#39;.</span>
<span class="sd">    grayscale (bool, optional): If True, display images in grayscale. Defaults to False.</span>
<span class="sd">    figsize (tuple, optional): Figure size (width, height) in inches. Defaults to (9.5, 4).</span>

<span class="sd">    Returns:</span>
<span class="sd">    matplotlib.figure.Figure: The figure containing the displayed images.</span>
<span class="sd">    numpy.ndarray: The array of subplots for further manipulation.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Create a figure with two subplots</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>  <span class="c1"># Create a figure with 1 row and 2 columns of subplots</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># Flatten the subplots for easier manipulation</span>

    <span class="c1"># Iterate over the first two images</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="c1"># Display the image in grayscale if grayscale is True, otherwise in color</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Images</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span> <span class="k">if</span> <span class="n">grayscale</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Set aspect ratio to 1 (square aspect)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>  <span class="c1"># Turn off axis</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">Names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>  <span class="c1"># Set image title with bold font</span>

    <span class="k">if</span> <span class="n">title</span><span class="p">:</span>
        <span class="c1"># Set main title if provided</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>  <span class="c1"># Adjust layout for better spacing</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>

<span class="c1"># Display the original images</span>
<span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">(</span><span class="n">Images</span><span class="p">,</span> <span class="n">Names</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Sample Images&#39;</span><span class="p">)</span>  <span class="c1"># Call the ImShow function to display images</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/5e87ce06a405f59153776deacb1d5583dbaeb82d63c4c3cf5852abc5b5c99809.png" src="../_images/5e87ce06a405f59153776deacb1d5583dbaeb82d63c4c3cf5852abc5b5c99809.png" />
</div>
</div>
</section>
<section id="accessing-and-manipulating-pixel-values-in-images">
<h2><span class="section-number">8.1.2. </span>Accessing and Manipulating Pixel Values in Images<a class="headerlink" href="#accessing-and-manipulating-pixel-values-in-images" title="Permalink to this heading">#</a></h2>
<p>To gain precise control over pixel values within an image, we leverage the versatile <code class="docutils literal notranslate"><span class="pre">split</span></code> function <span id="id2">[<a class="reference internal" href="../References.html#id37" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="../References.html#id38" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>. This function proves invaluable in dissecting the intricate tapestry of color channels present within an image.</p>
<p>In the digital imaging realm, each channel corresponds to a distinct color component. In the ubiquitous RGB color model, we encounter the vibrant Red, Green, and Blue channels. Alternatively, the CMYK model introduces Cyan, Magenta, Yellow, and Black channels. These models, alongside others, collectively govern an image’s appearance through their distinctive channels.</p>
<figure class="align-center" id="id12">
<a class="reference internal image-reference" href="../_images/CMYK_RGB.jpg"><img alt="../_images/CMYK_RGB.jpg" src="../_images/CMYK_RGB.jpg" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.1 </span><span class="caption-text">CMYK (left) and RGB (right) color models.</span><a class="headerlink" href="#id12" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cv2</span>

<span class="c1"># Load an example image from the &#39;Images&#39; dataset</span>
<span class="n">Img</span> <span class="o">=</span> <span class="n">Images_dict</span><span class="p">[</span><span class="s1">&#39;Lunenburg&#39;</span><span class="p">]</span>

<span class="c1"># Split the channels of the image into B (Blue), G (Green), and R (Red) channels</span>
<span class="n">B</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">Img</span><span class="p">)</span>

<span class="c1"># Calculate the size (shape) of each channel</span>
<span class="n">size_B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span>
<span class="n">size_G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">shape</span>
<span class="n">size_R</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span>

<span class="c1"># Print the sizes of B, G, and R channels</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Size of B channel (Blue):&quot;</span><span class="p">,</span> <span class="n">size_B</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Size of G channel (Green):&quot;</span><span class="p">,</span> <span class="n">size_G</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Size of R channel (Red):&quot;</span><span class="p">,</span> <span class="n">size_R</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Size of B channel (Blue): (1500, 2000)
Size of G channel (Green): (1500, 2000)
Size of R channel (Red): (1500, 2000)
</pre></div>
</div>
</div>
</div>
<p>The following line of code utilizes the <code class="docutils literal notranslate"><span class="pre">cv2.split()</span></code> function to split the channels of the first image in the ‘Images’ dataset. This function separates the image into its individual color channels, where <code class="docutils literal notranslate"><span class="pre">B</span></code> corresponds to the Blue channel, <code class="docutils literal notranslate"><span class="pre">G</span></code> to the Green channel, and <code class="docutils literal notranslate"><span class="pre">R</span></code> to the Red channel. These channels represent the components that collectively create the image’s color when combined.</p>
<figure class="align-center" id="id13">
<a class="reference internal image-reference" href="../_images/CV2_BGR.png"><img alt="../_images/CV2_BGR.png" src="../_images/CV2_BGR.png" style="width: 450px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.2 </span><span class="caption-text">Visual representation of <code class="docutils literal notranslate"><span class="pre">B,</span> <span class="pre">G,</span> <span class="pre">R</span> <span class="pre">=</span> <span class="pre">cv2.split(Img)</span></code>.</span><a class="headerlink" href="#id13" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Alternatively, we can access the red, green, and blue channels of <code class="docutils literal notranslate"><span class="pre">Img</span></code> using the indexing syntax <code class="docutils literal notranslate"><span class="pre">Img[:,:,0]</span></code>, <code class="docutils literal notranslate"><span class="pre">Img[:,:,1]</span></code>, and <code class="docutils literal notranslate"><span class="pre">Img[:,:,2]</span></code>. This concise notation allows direct access to each color channel within the image, where the indices 0, 1, and 2 correspond to the red, green, and blue channels respectively. This indexing approach provides a convenient and efficient way to work with individual color channels, enabling focused manipulation and analysis of the image’s color components.</p>
<figure class="align-center" id="id14">
<a class="reference internal image-reference" href="../_images/RGB_bands.png"><img alt="../_images/RGB_bands.png" src="../_images/RGB_bands.png" style="width: 300px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.3 </span><span class="caption-text">Visual representation of the three bands of <code class="docutils literal notranslate"><span class="pre">Img</span></code>.</span><a class="headerlink" href="#id14" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<div class="important admonition">
<p class="admonition-title">Remark</p>
<p>The order of the three color channels in an image and the output of <code class="docutils literal notranslate"><span class="pre">cv2.split(img)</span></code> in OpenCV might appear different due to how they represent the color information. This difference stems from historical conventions and the way images are stored in memory.</p>
<p><strong>RGB Order in Images:</strong></p>
<p>In standard RGB (Red, Green, Blue) images, the channels are typically arranged in the following order:</p>
<ol class="arabic simple">
<li><p><font color='Red'><b>Red (R)</b></font></p></li>
<li><p><font color='Green'><b>Green (G)</b></font></p></li>
<li><p><font color='Blue'><b>Blue (B)</b></font></p></li>
</ol>
<p>This order is based on human perception and the way colors are traditionally represented in digital imaging. The red channel contains information about the intensity of red in each pixel, followed by green and then blue.</p>
<p><strong>OpenCV’s <code class="docutils literal notranslate"><span class="pre">cv2.split(img)</span></code> Order:</strong></p>
<p>OpenCV, which is primarily used for computer vision and image processing tasks, often follows a different convention when splitting color channels using <code class="docutils literal notranslate"><span class="pre">cv2.split(img)</span></code>. The order is as follows:</p>
<ol class="arabic simple">
<li><p><font color='Blue'><b>Blue (B)</b></font></p></li>
<li><p><font color='Green'><b>Green (G)</b></font></p></li>
<li><p><font color='Red'><b>Red (R)</b></font></p></li>
</ol>
<p>This order might seem counterintuitive when compared to the RGB order, but it is used for compatibility with certain image processing algorithms and the way images are stored in memory in the BGR (Blue, Green, Red) format.</p>
<p>It’s important to be aware of this difference when working with OpenCV, especially if you are integrating it with other libraries or software that expect RGB order. You may need to reorder the channels if necessary.</p>
</div>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">Images_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="c1"># Create a figure with three subplots to display the color channels</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">9.5</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">))</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># Flatten the subplots for easier manipulation</span>

    <span class="c1"># Set the main title to the name of the image</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

    <span class="c1"># Iterate over the three color channels</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">channel_name</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Red&#39;</span><span class="p">,</span> <span class="s1">&#39;Green&#39;</span><span class="p">,</span> <span class="s1">&#39;Blue&#39;</span><span class="p">])):</span>
        <span class="c1"># Create an image with all zeros (black image) of the same size as the original image</span>
        <span class="n">channel_image</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">image</span>
        <span class="c1"># Assign the values of the current color channel to the corresponding channel in the black image</span>
        <span class="n">channel_image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="c1"># Display the image for the current color channel in the subplot</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">channel_image</span><span class="p">)</span>
        <span class="c1"># Set aspect ratio to 1 to avoid stretching</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Turn off axis for cleaner visualization</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
        <span class="c1"># Add text label indicating the color channel</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">channel_name</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="s1">&#39;White&#39;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s2">&quot;square&quot;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span> <span class="n">channel_name</span><span class="p">))</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/88172fc347788b0713db18489e91adbb4964b0077e96369c36f9bb5a278d83da.png" src="../_images/88172fc347788b0713db18489e91adbb4964b0077e96369c36f9bb5a278d83da.png" />
<img alt="../_images/2e110d06a93720065031556563753f8aefad69dd0af0dfd51bbff105724be90b.png" src="../_images/2e110d06a93720065031556563753f8aefad69dd0af0dfd51bbff105724be90b.png" />
</div>
</div>
<p>Here’s an explanation of the code:</p>
<p>The code then iterates over the three color channels: Red, Green, and Blue. For each channel:</p>
<ul class="simple">
<li><p>It creates a black image of the same size as the original image using <code class="docutils literal notranslate"><span class="pre">channel_image</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">*</span> <span class="pre">image</span></code>. This black image has the same dimensions as the original but contains all zeros, essentially creating a black canvas for the channel.</p></li>
<li><p>It assigns the values of the current color channel from the original image to the corresponding channel in the black image. This isolates the specific color channel.</p></li>
<li><p>It displays the isolated color channel image in the current subplot using <code class="docutils literal notranslate"><span class="pre">ax.imshow(channel_image)</span></code>.</p></li>
<li><p>Sets the aspect ratio to 1 to avoid stretching the displayed image.</p></li>
<li><p>Turns off the axis to provide a cleaner visualization.</p></li>
<li><p>Adds a text label indicating the color channel name (e.g., “Red,” “Green,” or “Blue”) on top of the subplot.</p></li>
</ul>
</section>
<section id="adding-padding-exploring-border-types-in-opencv-optional-content">
<h2><span class="section-number">8.1.3. </span>Adding Padding: Exploring Border Types in OpenCV (Optional Content)<a class="headerlink" href="#adding-padding-exploring-border-types-in-opencv-optional-content" title="Permalink to this heading">#</a></h2>
<p>In image processing, padding or adding borders to an image is a common operation, often used in tasks like convolution or resizing. OpenCV provides several border types, each with its own unique behavior <span id="id3">[<a class="reference internal" href="../References.html#id37" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="../References.html#id38" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>. The <code class="docutils literal notranslate"><span class="pre">cv2.copyMakeBorder</span></code> function in OpenCV is used to create a new image (destination, <code class="docutils literal notranslate"><span class="pre">dst</span></code>) by adding a border around the original image (source, <code class="docutils literal notranslate"><span class="pre">src</span></code>). The border is created based on the specified parameters, such as the offset, border type, and value of the border pixels. Here’s an explanation of the function signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">copyMakeBorder</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">bordertype</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src</span></code>: The source image, which is the input image to which the border will be added.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The destination image, where the result (image with border) will be stored. It should have the size of the output image, which can be calculated based on the input image and the specified offset.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">offset</span></code>: A tuple <code class="docutils literal notranslate"><span class="pre">(top,</span> <span class="pre">bottom,</span> <span class="pre">left,</span> <span class="pre">right)</span></code> that specifies the number of pixels for each side (top, bottom, left, right) by which the image will be extended with the border.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bordertype</span></code>: The type of border to be added, specified as an integer constant. Common border types include <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_CONSTANT</span></code>, <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REPLICATE</span></code>, <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REFLECT</span></code>, and others.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value of the border pixels. This parameter is optional and is only used when the <code class="docutils literal notranslate"><span class="pre">bordertype</span></code> is set to <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_CONSTANT</span></code>. The default value is <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0)</span></code>, which corresponds to black in grayscale images.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.copyMakeBorder</span></code> function modifies the <code class="docutils literal notranslate"><span class="pre">dst</span></code> image by adding a border around the <code class="docutils literal notranslate"><span class="pre">src</span></code> image based on the specified offset and border type. The resulting image in <code class="docutils literal notranslate"><span class="pre">dst</span></code> will have a larger size than the original image, with the specified border.</p>
<p>It’s important to note that the <code class="docutils literal notranslate"><span class="pre">dst</span></code> image should be pre-allocated to accommodate the new size, and the dimensions of the <code class="docutils literal notranslate"><span class="pre">dst</span></code> image can be calculated based on the dimensions of the <code class="docutils literal notranslate"><span class="pre">src</span></code> image and the specified offset.</p>
<p>Let’s delve into these border types:</p>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_CONSTANT</span></code></strong>: This option introduces a border with a consistent color, effectively extending the image’s dimensions. The border’s color remains the same throughout, making it suitable for scenarios where a constant background is desired.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REFLECT</span></code></strong>: When using this option, the border is generated by reflecting the elements along the boundary. This results in a pattern that resembles a mirror reflection, such as “fedcba|abcdefgh|hgfedcb”. It provides a smooth and continuous appearance at the border.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REFLECT_101</span></code> (or <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_DEFAULT</span></code>)</strong>: Similar to <code class="docutils literal notranslate"><span class="pre">BORDER_REFLECT</span></code>, this option creates a border with mirrored reflection. However, the pattern differs slightly, appearing as “gfedcb|abcdefgh|gfedcba”. This border type is popular for tasks that require symmetry preservation.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REPLICATE</span></code></strong>: This option duplicates the last element of each row or column to form the border. The resulting pattern looks like “aaaaaa|abcdefgh|hhhhhhh”, effectively maintaining the edge consistency.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_WRAP</span></code></strong>: Utilizing this option, the image wraps around to form a circular-like pattern in the border. The pattern could be described as “cdefgh|abcdefgh|abcdefg”. This border type is particularly useful for applications dealing with cyclic or periodic data.</p></li>
</ul>
<p>For an in-depth understanding of these border types, along with practical code examples and usage scenarios, it’s highly recommended to refer to the official OpenCV documentation available <a class="reference external" href="https://docs.opencv.org/3.4/dc/da3/tutorial_copyMakeBorder.html">here</a>. This documentation provides detailed insights and examples, enabling you to leverage these border types effectively in various image processing tasks <span id="id4">[<a class="reference internal" href="../References.html#id37" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="../References.html#id38" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Mapping of OpenCV border types to their descriptive names</span>
<span class="n">cv2_border_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_CONSTANT</span><span class="p">:</span> <span class="s1">&#39;BORDER_CONSTANT&#39;</span><span class="p">,</span>
                   <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REPLICATE</span><span class="p">:</span> <span class="s1">&#39;BORDER_REPLICATE&#39;</span><span class="p">,</span>
                   <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REFLECT</span><span class="p">:</span> <span class="s1">&#39;BORDER_REFLECT&#39;</span><span class="p">,</span>
                   <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_WRAP</span><span class="p">:</span> <span class="s1">&#39;BORDER_WRAP&#39;</span><span class="p">,</span>
                   <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REFLECT_101</span><span class="p">:</span> <span class="s1">&#39;BORDER_REFLECT_101&#39;</span><span class="p">}</span>


<span class="n">Red_RGB</span> <span class="o">=</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Red RGB Color:&#39;</span><span class="p">,</span> <span class="n">Red_RGB</span><span class="p">)</span>

<span class="c1"># Create a 2x3 grid of subplots to display images</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">9.5</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="n">fig</span><span class="o">.</span><span class="n">delaxes</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Remove the last subplot (blank)</span>

<span class="c1"># Set the title for the overall figure</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Border Types Applied&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

<span class="c1"># Iterate over the different border types and apply them to the image</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">border_type</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cv2_border_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
    <span class="c1"># Apply the specified border to the image (Images[1]) with padding values</span>
    <span class="n">img_with_border</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">copyMakeBorder</span><span class="p">(</span><span class="n">Images</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">border_type</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">Red_RGB</span><span class="p">)</span>
    <span class="c1"># value = Red_RGB will be used only if border_type = cv2.BORDER_CONSTANT</span>
    <span class="c1"># Display the image with the applied border on the current subplot</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img_with_border</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Red RGB Color: (255, 0, 0)
</pre></div>
</div>
<img alt="../_images/181f345a777a56aabc1f93c389805b8fb32329db0aa0142e195d84870e0b9d80.png" src="../_images/181f345a777a56aabc1f93c389805b8fb32329db0aa0142e195d84870e0b9d80.png" />
</div>
</div>
<p>Here’s an explanation of the code:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cv2_border_dict</span></code>: This is a dictionary that maps OpenCV border types to their descriptive names. It provides a convenient way to iterate over and display different border types with their names.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Red_RGB</span></code>: This variable defines an RGB color value for the color red, represented as (255, 0, 0).</p></li>
<li><p>Creating Subplots: The code sets up a 2x3 grid of subplots using Matplotlib. The subplots are arranged in a 2x3 grid, and the last subplot is removed using <code class="docutils literal notranslate"><span class="pre">fig.delaxes(ax[-1])</span></code> to create space for other elements.</p></li>
<li><p>Iterating Over Border Types: The code iterates over different border types using a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop. For each border type, it performs the following steps:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">img_with_border</span> <span class="pre">=</span> <span class="pre">cv2.copyMakeBorder(Images[1],</span> <span class="pre">100,</span> <span class="pre">100,</span> <span class="pre">100,</span> <span class="pre">100,</span> <span class="pre">border_type,</span> <span class="pre">value=Red_RGB)</span></code>: It applies the specified border to an image (<code class="docutils literal notranslate"><span class="pre">Images[1]</span></code>) using the <code class="docutils literal notranslate"><span class="pre">cv2.copyMakeBorder</span></code> function. The function takes several arguments:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Images[1]</span></code>: The image to which the border is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">100,</span> <span class="pre">100,</span> <span class="pre">100,</span> <span class="pre">100</span></code>: These values specify the padding on each side (top, bottom, left, right) of the image.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">border_type</span></code>: The type of border to apply, as defined in <code class="docutils literal notranslate"><span class="pre">cv2_border_dict</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value=Red_RGB</span></code>: This argument specifies the color to use for the border, and it is set to red (only used if <code class="docutils literal notranslate"><span class="pre">border_type</span></code> is <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_CONSTANT</span></code>).</p></li>
</ul>
</li>
<li><p>Displaying the Image: The code displays the image with the applied border on the current subplot using <code class="docutils literal notranslate"><span class="pre">ax[i].imshow(img_with_border)</span></code>. It sets the aspect ratio to 1 to prevent stretching, turns off the axis for a cleaner visualization using <code class="docutils literal notranslate"><span class="pre">ax[i].axis('off')</span></code>, and sets the title of the subplot to the name of the border type.</p></li>
</ul>
</li>
</ol>
</section>
<section id="image-blending-using-the-cv2-addweighted-function">
<h2><span class="section-number">8.1.4. </span>Image Blending: Using the <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> Function<a class="headerlink" href="#image-blending-using-the-cv2-addweighted-function" title="Permalink to this heading">#</a></h2>
<p>Image blending is a fundamental technique in image processing that combines two images to create a new composite image. OpenCV provides the <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> function, which performs image blending based on a weighted sum of the input images and an additional constant value. Here’s an explanation of the blending formula and how it works
<span id="id5">[<a class="reference internal" href="../References.html#id37" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="../References.html#id38" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>:</p>
<p>The formula for image blending using <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> is as follows:</p>
<div class="amsmath math notranslate nohighlight" id="equation-1e501d57-1cd8-4612-989f-aea4971bb1b2">
<span class="eqno">(8.1)<a class="headerlink" href="#equation-1e501d57-1cd8-4612-989f-aea4971bb1b2" title="Permalink to this equation">#</a></span>\[\begin{equation}
dst = \alpha \cdot \text{src1} + \beta \cdot \text{src2} + \gamma
\end{equation}\]</div>
<p>In this formula:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code> are the two input images to be blended.</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha\)</span> is a weighting factor that determines the influence of <code class="docutils literal notranslate"><span class="pre">src1</span></code> in the final output. It satisfies the condition <span class="math notranslate nohighlight">\(0 \leq \alpha \leq 1\)</span>, meaning it controls the relative contribution of <code class="docutils literal notranslate"><span class="pre">src1</span></code> to the blended image.</p></li>
<li><p><span class="math notranslate nohighlight">\(\beta = 1 - \alpha\)</span> represents the weighting factor for <code class="docutils literal notranslate"><span class="pre">src2</span></code>, ensuring that the sum of the weights for both images is 1.</p></li>
<li><p><span class="math notranslate nohighlight">\(\gamma\)</span> is an additional constant value that can be added to the blended result. It is an integer value that can be used for brightness adjustment.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> function in OpenCV is used for image blending, which combines two input images (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>) together using a specified weight for each image. The resulting blended image is stored in the destination image (<code class="docutils literal notranslate"><span class="pre">dst</span></code>). Here’s an explanation of the function signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">addWeighted</span><span class="p">(</span><span class="n">src1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">src2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src1</span></code>: The first source image, which is the primary input image for blending.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alpha</span></code>: The weight applied to the first source image (<code class="docutils literal notranslate"><span class="pre">src1</span></code>). This value determines the contribution of <code class="docutils literal notranslate"><span class="pre">src1</span></code> to the final result. A larger <code class="docutils literal notranslate"><span class="pre">alpha</span></code> value increases the influence of <code class="docutils literal notranslate"><span class="pre">src1</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">src2</span></code>: The second source image, which is the secondary input image for blending.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">beta</span></code>: The weight applied to the second source image (<code class="docutils literal notranslate"><span class="pre">src2</span></code>). This value determines the contribution of <code class="docutils literal notranslate"><span class="pre">src2</span></code> to the final result. A larger <code class="docutils literal notranslate"><span class="pre">beta</span></code> value increases the influence of <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gamma</span></code>: A scalar added to the weighted sum of the two source images. This value can be used to control the brightness or contrast of the resulting image.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The destination image, where the blended image is stored. The dimensions of this image should match the dimensions of the input images.</p></li>
</ul>
<p>You can see the full description of this function <a class="reference external" href="https://docs.opencv.org/3.4/d5/dc4/tutorial_adding_images.html">here</a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> function performs a linear combination of the two source images (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>) based on the specified weights <code class="docutils literal notranslate"><span class="pre">alpha</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code>, and then adds the scalar <code class="docutils literal notranslate"><span class="pre">gamma</span></code> to the resulting sum. The resulting blended image is written to the <code class="docutils literal notranslate"><span class="pre">dst</span></code> image <span id="id6">[<a class="reference internal" href="../References.html#id37" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="../References.html#id38" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p>This function is commonly used for image fusion, creating special effects, adjusting image brightness and contrast, and other image processing tasks where combining two images with different weights is required. The <code class="docutils literal notranslate"><span class="pre">alpha</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code> values control the influence of each source image, and the <code class="docutils literal notranslate"><span class="pre">gamma</span></code> value can be used to control the overall brightness or contrast of the final image.</p>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Define the size of the images</span>
<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>

<span class="c1"># Create two sample images with different color channels</span>
<span class="n">Image_Red</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image_Red</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="n">Image_Green</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image_Green</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="n">Image_Blue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image_Blue</span><span class="p">[:,:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c1"># Create a subplot with three rows and two columns for visualization</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">9.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

<span class="c1"># Display the first image on the first subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image_Red</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Red&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>

<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image_Green</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Green&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>

<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image_Blue</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Blue&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>

<span class="c1"># Blend the images and display the results</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">addWeighted</span><span class="p">(</span><span class="n">Image_Red</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">Image_Green</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;0.5 * Red + 0.5 * Green&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>

<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">addWeighted</span><span class="p">(</span><span class="n">Image_Red</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">Image_Blue</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;0.5 * Red + 0.5 * Blue&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>

<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">addWeighted</span><span class="p">(</span><span class="n">Image_Green</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">Image_Blue</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;0.5 * Green + 0.5 * Blue&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>

<span class="c1"># Set aspect ratio and turn off axes for all subplots</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

<span class="c1"># Ensure tight layout</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/92b7fa749bd975cc054d105b2a2be642f31c96444e4a6d4c2945e76612d8bb27.png" src="../_images/92b7fa749bd975cc054d105b2a2be642f31c96444e4a6d4c2945e76612d8bb27.png" />
</div>
</div>
<p>Here’s an explanation of the code:</p>
<ol class="arabic simple">
<li><p>Image Creation: Three sample images are created, each with a single color channel (red, green, or blue). The images are created as NumPy arrays with dimensions (100, 150, 3) to represent an image of size 100x150 pixels with three color channels (red, green, and blue). Each color channel is set to have a maximum intensity (255) for its respective color.</p></li>
<li><p>Image Blending: The code blends the images in the remaining three subplots. Each blend is created using the <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted()</span></code> function, which takes two images, their weights, and an optional scalar value. The weights control the contribution of each image to the blend. The resulting images are displayed in the subplots with titles indicating the color combination.</p></li>
</ol>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import necessary libraries</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>  <span class="c1"># Import numpy for array operations</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  <span class="c1"># Import matplotlib for visualization</span>
<span class="kn">import</span> <span class="nn">cv2</span>  <span class="c1"># Import OpenCV for image processing</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.7</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span>
<span class="c1"># Method 1: Using cv2.addWeighted for Image Blending</span>
<span class="c1"># Blend two different images using weighted sums</span>
<span class="c1"># 0.7 and 0.3 are the weights applied to the first and second image, respectively</span>
<span class="c1"># 0 is the scalar value added to the resulting image</span>
<span class="n">augmented_img_01</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">addWeighted</span><span class="p">(</span><span class="n">Images</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Images</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">beta</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># Method 2: Custom Image Blending</span>
<span class="c1"># Blend two different images using custom weighted sums</span>
<span class="c1"># We use numpy for element-wise multiplication and addition, rounding the result, and converting to &#39;uint8&#39; data type</span>
<span class="c1"># This technique allows manual control of blending weights</span>
<span class="n">augmented_img_02</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">Images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">Images</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>

<span class="c1"># Display the original and transformed images with titles</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">(</span><span class="n">Images</span><span class="o">=</span><span class="p">[</span><span class="n">augmented_img_01</span><span class="p">,</span> <span class="n">augmented_img_02</span><span class="p">],</span>
                 <span class="n">Names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cv2.addWeighted&#39;</span><span class="p">,</span> <span class="s1">&#39;Custom Blend&#39;</span><span class="p">],</span>
                 <span class="n">title</span><span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Image Blending: </span><span class="si">{</span><span class="n">alpha</span><span class="si">:</span><span class="s1">.1</span><span class="si">}</span><span class="s1">*Img1 + </span><span class="si">{</span><span class="n">beta</span><span class="si">:</span><span class="s1">.1</span><span class="si">}</span><span class="s1">*Img2&#39;</span><span class="p">,</span>
                 <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">9.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/08cecff13d38dbb1c6eac530f6cd45b3b6f01ec1705459dd0febb26402dd7257.png" src="../_images/08cecff13d38dbb1c6eac530f6cd45b3b6f01ec1705459dd0febb26402dd7257.png" />
</div>
</div>
<p>Here’s an explanation of the code:</p>
<ol class="arabic simple">
<li><p>Alpha and Beta Values: Two blending factors, <code class="docutils literal notranslate"><span class="pre">alpha</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code>, are defined to control the weights of the original images. <code class="docutils literal notranslate"><span class="pre">alpha</span></code> is set to 0.7, and <code class="docutils literal notranslate"><span class="pre">beta</span></code> is set to 0.3. These values determine how much of each image contributes to the blend.</p></li>
<li><p>Method 1: Using <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code>:</p>
<ul class="simple">
<li><p>In this method, <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> is used to blend the two images. This function takes two input images, their corresponding weights (in this case, <code class="docutils literal notranslate"><span class="pre">alpha</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code>), and an optional scalar value (which is set to 0).</p></li>
<li><p>The result is stored in the variable <code class="docutils literal notranslate"><span class="pre">augmented_img_01</span></code>.</p></li>
</ul>
</li>
<li><p>Method 2: Custom Image Blending:</p>
<ul class="simple">
<li><p>In this method, custom image blending is performed using NumPy operations.</p></li>
<li><p>The code calculates the weighted sums of the two images using <code class="docutils literal notranslate"><span class="pre">alpha</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code> and rounds the result to ensure integer values.</p></li>
<li><p>The result is converted to the ‘uint8’ data type, suitable for image representation.</p></li>
<li><p>The blended image is stored in the variable <code class="docutils literal notranslate"><span class="pre">augmented_img_02</span></code>.</p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span>
<span class="n">augmented_img_01</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">addWeighted</span><span class="p">(</span><span class="n">Images</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Images</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">beta</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">augmented_img_02</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">Images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">Images</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">(</span><span class="n">Images</span><span class="o">=</span><span class="p">[</span><span class="n">augmented_img_01</span><span class="p">,</span> <span class="n">augmented_img_02</span><span class="p">],</span>
                 <span class="n">Names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cv2.addWeighted&#39;</span><span class="p">,</span> <span class="s1">&#39;Custom Blend&#39;</span><span class="p">],</span>
                 <span class="n">title</span><span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Image Blending: </span><span class="si">{</span><span class="n">alpha</span><span class="si">:</span><span class="s1">.1</span><span class="si">}</span><span class="s1">*Img1 + </span><span class="si">{</span><span class="n">beta</span><span class="si">:</span><span class="s1">.1</span><span class="si">}</span><span class="s1">*Img2&#39;</span><span class="p">,</span>
                 <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">9.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/13688c140d9763f54f22b35a5646b2d5c3a5a0ed34efccd5389de89c5625eb30.png" src="../_images/13688c140d9763f54f22b35a5646b2d5c3a5a0ed34efccd5389de89c5625eb30.png" />
</div>
</div>
</section>
<section id="bitwise-operations-in-opencv-optional-content">
<h2><span class="section-number">8.1.5. </span>Bitwise Operations in OpenCV (Optional Content)<a class="headerlink" href="#bitwise-operations-in-opencv-optional-content" title="Permalink to this heading">#</a></h2>
<p>Bitwise operations are fundamental operations in computer programming and image processing that manipulate individual bits within binary representations of data. These operations involve performing logical and mathematical operations at the bit level, which can be particularly useful in tasks such as image manipulation, data compression, encryption, and hardware-level operations. You can perform bitwise operations on integers and use these operations for image processing with libraries like OpenCV. Here’s a brief overview of how bitwise operations work in Python:</p>
<figure class="align-center" id="id15">
<a class="reference internal image-reference" href="../_images/bitwise_op.png"><img alt="../_images/bitwise_op.png" src="../_images/bitwise_op.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.4 </span><span class="caption-text">Examples of Bitwise Operations.</span><a class="headerlink" href="#id15" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<ol class="arabic simple">
<li><p><strong>Bitwise AND (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) and OR (<code class="docutils literal notranslate"><span class="pre">|</span></code>)</strong>:
You can use the <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> operator for bitwise AND and the <code class="docutils literal notranslate"><span class="pre">|</span></code> operator for bitwise OR. These operators compare corresponding bits of two integers and produce a new integer where each bit is the result of the corresponding bitwise operation.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Given integers</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">28</span>

<span class="c1"># Print the binary representation of a and b</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Binary for </span><span class="si">%i</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Binary for </span><span class="si">%i</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>

<span class="c1"># Bitwise AND operation</span>
<span class="n">result_and</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span>  <span class="c1"># Bitwise AND: 0001 (1 in decimal)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a &amp; b = </span><span class="si">%i</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result_and</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">result_and</span><span class="p">)))</span>

<span class="c1"># Bitwise OR operation</span>
<span class="n">result_or</span> <span class="o">=</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span>   <span class="c1"># Bitwise OR: 0111 (7 in decimal)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a | b = </span><span class="si">%i</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result_or</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">result_or</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Binary for 21 = 0b10101
Binary for 28 = 0b11100
a &amp; b = 20 (0b10100)
a | b = 29 (0b11101)
</pre></div>
</div>
</div>
</div>
<div class="important admonition">
<p class="admonition-title">Remark</p>
<p>To convert a number to its binary representation in Python, you can use the <code class="docutils literal notranslate"><span class="pre">bin()</span></code> function. This function takes an integer as input and returns a string that represents the binary value of that integer, with the “0b” prefix <span id="id7">[<a class="reference internal" href="../References.html#id17" title="Python Software Foundation. Python 3.11.4 documentation. https://docs.python.org/, 2023. [Online; accessed 01-August-2023].">Python Software Foundation, 2023</a>]</span>.</p>
<p>Here’s an example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">number</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">binary_value</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">binary_value</span><span class="p">)</span>  <span class="c1"># Output: &#39;0b101010&#39;</span>
</pre></div>
</div>
<p>If you want to remove the “0b” prefix and get the binary representation as a plain string, you can use string slicing:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">number</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">binary_string</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">number</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">binary_string</span><span class="p">)</span>  <span class="c1"># Output: &#39;101010&#39;</span>
</pre></div>
</div>
<p>If you need to pad the binary representation with leading zeros to a certain length (e.g., 8 bits), you can use the <code class="docutils literal notranslate"><span class="pre">format()</span></code> function with the <code class="docutils literal notranslate"><span class="pre">'b'</span></code> format specifier:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">number</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">binary_padded</span> <span class="o">=</span> <span class="nb">format</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="s1">&#39;08b&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">binary_padded</span><span class="p">)</span>  <span class="c1"># Output: &#39;00101010&#39;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">'08b'</span></code> format specifier means:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'0'</span></code>: The character used for padding (leading zeros).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'8'</span></code>: The width of the output string (total length).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'b'</span></code>: Indicates binary representation.</p></li>
</ul>
<p>Futhermore, you can convert a binary string to an integer using the <code class="docutils literal notranslate"><span class="pre">int()</span></code> function with the base set to 2. Here’s an example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">binary_string</span> <span class="o">=</span> <span class="s2">&quot;1101&quot;</span>
<span class="n">integer_value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">binary_string</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Binary:&quot;</span><span class="p">,</span> <span class="n">binary_string</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Integer:&quot;</span><span class="p">,</span> <span class="n">integer_value</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Binary</span><span class="p">:</span> <span class="mi">1101</span>
<span class="n">Integer</span><span class="p">:</span> <span class="mi">13</span>
</pre></div>
</div>
<p>This code converts the binary string “1101” to the corresponding integer value, which is 13 in decimal representation. The <code class="docutils literal notranslate"><span class="pre">int()</span></code> function takes two arguments: the first argument is the string containing the binary representation, and the second argument specifies the base, which is 2 for binary. The resulting integer value is then printed.</p>
</div>
<ol class="arabic simple" start="2">
<li><p><strong>Bitwise XOR (<code class="docutils literal notranslate"><span class="pre">^</span></code>) and NOT (<code class="docutils literal notranslate"><span class="pre">~</span></code>)</strong>:
The <code class="docutils literal notranslate"><span class="pre">^</span></code> operator is used for bitwise XOR, which compares corresponding bits and produces a new integer with the XOR result. The <code class="docutils literal notranslate"><span class="pre">~</span></code> operator is used for bitwise NOT, which inverts all bits of an integer.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Given integers</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">28</span>

<span class="c1"># Print the binary representation of a and b</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Binary for </span><span class="si">%i</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Binary for </span><span class="si">%i</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>

<span class="c1"># Bitwise XOR operation</span>
<span class="n">result_xor</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a ^ b = </span><span class="si">%i</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result_xor</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">result_xor</span><span class="p">)))</span>

<span class="c1"># Bitwise NOT operation</span>
<span class="n">result_not</span> <span class="o">=</span> <span class="o">~</span><span class="n">a</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;~a  = </span><span class="si">%i</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result_not</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">result_not</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Binary for 21 = 0b10101
Binary for 28 = 0b11100
a ^ b = 9 (0b1001)
~a  = -22 (-0b10110)
</pre></div>
</div>
</div>
</div>
<div class="important admonition">
<p class="admonition-title">Remark</p>
<p>When you use the <code class="docutils literal notranslate"><span class="pre">bin()</span></code> function in Python, it returns a string that includes a negative sign (<code class="docutils literal notranslate"><span class="pre">-</span></code>) and the binary representation. This is consistent with the two’s complement representation used for signed integers.</p>
<p>Let’s break down the example to clarify:</p>
<ol class="arabic">
<li><p>Given: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">21</span></code>. The binary representation of <code class="docutils literal notranslate"><span class="pre">21</span></code> is <code class="docutils literal notranslate"><span class="pre">10101</span></code> (5 bits, assuming 32-bit representation).</p></li>
<li><p>Applying the bitwise NOT (<code class="docutils literal notranslate"><span class="pre">~</span></code>) operation to <code class="docutils literal notranslate"><span class="pre">21</span></code> inverts each bit: <code class="docutils literal notranslate"><span class="pre">01010</span></code>.</p></li>
<li><p>Now, let’s interpret this result as a signed integer:</p>
<ul class="simple">
<li><p>In binary, <code class="docutils literal notranslate"><span class="pre">01010</span></code> is the binary representation of the decimal value <code class="docutils literal notranslate"><span class="pre">10</span></code>. This is the positive interpretation.</p></li>
<li><p>However, in signed two’s complement representation, to get the negative value, you first invert all the bits and then add 1.</p></li>
</ul>
<p>Inverting <code class="docutils literal notranslate"><span class="pre">01010</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">10101</span>
</pre></div>
</div>
<p>Adding 1 to the inverted value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">10110</span>
</pre></div>
</div>
</li>
<li><p>The result is <code class="docutils literal notranslate"><span class="pre">-10110</span></code>. When you use the <code class="docutils literal notranslate"><span class="pre">bin()</span></code> function to convert this to a binary string, Python includes the negative sign (<code class="docutils literal notranslate"><span class="pre">-</span></code>) and the binary representation, resulting in <code class="docutils literal notranslate"><span class="pre">-0b10110</span></code>.</p></li>
</ol>
<p>So, it’s important to understand that the <code class="docutils literal notranslate"><span class="pre">~</span></code> operator does perform bitwise inversion, but when the result is interpreted as a signed integer (in two’s complement representation), the negative sign is included in the binary string representation. This is why you see <code class="docutils literal notranslate"><span class="pre">-0b10110</span></code> as the output when <code class="docutils literal notranslate"><span class="pre">~a</span></code> is <code class="docutils literal notranslate"><span class="pre">-22</span></code>.</p>
</div>
<p>These bitwise operations are fundamental building blocks in binary image manipulation and can be applied to individual pixel values when working with image data. When working with images in OpenCV, you can use these operations to perform tasks such as masking, image blending, and more by applying them to the pixel values of the images.</p>
<p>These operations are particularly efficient and are often used in low-level programming, such as optimizing memory usage, performing pixel-level operations in image processing, and implementing various data manipulation algorithms.</p>
<p>In image processing, bitwise operations can be used for tasks such as creating masks, extracting specific color channels, setting or clearing specific bits, and combining images using logical conditions. In hardware design, bitwise operations are essential for controlling individual bits in registers and memory-mapped devices.</p>
<p>OpenCV provides several essential bitwise operations for manipulating individual bits within arrays. These operations offer the ability to perform logical operations at the bit level, making them useful for various image processing tasks that involve binary data. Here’s an explanation of each bitwise operation along with links to their documentation <span id="id8">[<a class="reference internal" href="../References.html#id37" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="../References.html#id38" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>:</p>
<section id="bitwise-and-operation-with-cv2-bitwise-and">
<h3><span class="section-number">8.1.5.1. </span>Bitwise AND Operation with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code><a class="headerlink" href="#bitwise-and-operation-with-cv2-bitwise-and" title="Permalink to this heading">#</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code> function in OpenCV is a versatile tool for performing element-wise bitwise conjunction (logical AND) operations between arrays. This function allows you to apply the AND operation between corresponding elements of two input arrays or an array and a scalar. The resulting array, <code class="docutils literal notranslate"><span class="pre">dst</span></code>, has the same size and data type as the input arrays, making it useful for a variety of image processing tasks <span id="id9">[<a class="reference internal" href="../References.html#id37" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="../References.html#id38" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p><strong>Key Concepts:</strong></p>
<ol class="arabic">
<li><p><strong>Operation on Two Arrays (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code> with the same size):</strong></p>
<ul>
<li><p>When both input arrays (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>) have the same size, the function computes the logical AND operation between corresponding elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1(I) AND src2(I) if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>The operation is performed element-wise. Each element in the resulting array <code class="docutils literal notranslate"><span class="pre">dst</span></code> is the result of the logical AND operation between the corresponding elements in <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
<li><p>The optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> parameter allows you to selectively apply the operation based on the mask values. If <code class="docutils literal notranslate"><span class="pre">mask(I)</span></code> is non-zero, the operation is applied; otherwise, the corresponding element in <code class="docutils literal notranslate"><span class="pre">dst</span></code> remains unchanged.</p></li>
</ul>
</li>
<li><p><strong>Operation on an Array and a Scalar (<code class="docutils literal notranslate"><span class="pre">src2</span></code> as a scalar):</strong></p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">src2</span></code> is a scalar (a single value), the function computes the bitwise AND operation between each element of <code class="docutils literal notranslate"><span class="pre">src1</span></code> and the scalar value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1(I) AND src2 if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>If the number of elements in <code class="docutils literal notranslate"><span class="pre">src1</span></code> matches the number of channels in <code class="docutils literal notranslate"><span class="pre">src2</span></code>, the operation can be performed. The scalar is first converted to an array of the same type as <code class="docutils literal notranslate"><span class="pre">src1</span></code>.</p></li>
</ul>
</li>
<li><p><strong>Operation on a Scalar and an Array (<code class="docutils literal notranslate"><span class="pre">src1</span></code> as a scalar):</strong></p>
<ul>
<li><p>Similarly, if <code class="docutils literal notranslate"><span class="pre">src1</span></code> is a scalar, the function computes the bitwise AND operation between the scalar value and each element of <code class="docutils literal notranslate"><span class="pre">src2</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1 AND src2(I) if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>If the number of elements in <code class="docutils literal notranslate"><span class="pre">src2</span></code> matches the number of channels in <code class="docutils literal notranslate"><span class="pre">src1</span></code>, the scalar is first converted to an array of the same type as <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
</ul>
</li>
<li><p><strong>Handling Floating-Point Arrays and Multi-Channel Arrays:</strong></p>
<ul class="simple">
<li><p>For floating-point input arrays, the machine-specific bit representations (usually IEEE754-compliant) are used for the operation.</p></li>
<li><p>When dealing with multi-channel input arrays (e.g., a color image with separate channels), the operation is applied independently to each channel.</p></li>
</ul>
</li>
</ol>
<p><strong>Function Syntax</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">src1</span><span class="p">,</span> <span class="n">src2</span><span class="p">[,</span> <span class="n">dst</span><span class="p">[,</span> <span class="n">mask</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">dst</span>
</pre></div>
</div>
<p><strong>Description</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code> function is part of the OpenCV library in Python, and it performs element-wise bitwise AND operations between two input arrays <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>. An optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> can be provided to specify the region where the operation is applied. The result of the operation is stored in the output array <code class="docutils literal notranslate"><span class="pre">dst</span></code>.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src1</span></code>: The first input array (image) on which the bitwise AND operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">src2</span></code>: The second input array (image) on which the bitwise AND operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code> (optional): The output array to store the result of the operation. If not provided, the function creates a new array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mask</span></code> (optional): A mask specifying the region where the operation should be performed. The dimensions of the mask must match the dimensions of <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
</ul>
<p><strong>Return</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The output array containing the result of the bitwise AND operation between <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>. If <code class="docutils literal notranslate"><span class="pre">dst</span></code> is provided as an argument, the function stores the result in <code class="docutils literal notranslate"><span class="pre">dst</span></code>. Otherwise, a new array is created to hold the result.</p></li>
</ul>
<p><strong>Usage</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code> function is commonly used in image processing to perform bitwise AND operations on corresponding pixels of two images. This can be useful for tasks such as masking or extracting specific regions of interest (ROI) from an image based on a provided mask.</p>
<p>For more detailed information on <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code>, you can refer to the <a class="reference external" href="https://docs.opencv.org/2.4/modules/core/doc/operations_on_arrays.html#bitwise-and">OpenCV documentation</a>.</p>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create two sample images with different shapes</span>
<span class="n">Image1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image1</span><span class="p">[</span><span class="mi">50</span><span class="p">:</span><span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Blue region</span>

<span class="n">Image2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image2</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span> <span class="mi">150</span><span class="p">:</span><span class="mi">250</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Green region</span>

<span class="c1"># Perform a bitwise AND operation between the two images</span>
<span class="n">Result</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">Image1</span><span class="p">,</span> <span class="n">Image2</span><span class="p">)</span>

<span class="c1"># Create a subplot with three images for visualization</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">9.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="c1"># Display the first image on the first subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image1</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Image 1&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Display the second image on the second subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image2</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Image 2&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Display the result of the bitwise AND operation on the third subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Result</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Bitwise AND Result&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Set aspect ratio and turn off axes for all subplots</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/40510a65cc17c9a15d3c607b6575421439d96b1a76805830284f23a5483b6469.png" src="../_images/40510a65cc17c9a15d3c607b6575421439d96b1a76805830284f23a5483b6469.png" />
</div>
</div>
<p>The provided code snippet generates three images and displays them using Matplotlib subplots. It uses the OpenCV library to perform a bitwise AND operation between two sample images, creating a new resulting image. Let’s break down the code step by step:</p>
<ol class="arabic simple">
<li><p><strong>Creating Sample Images:</strong>
The code creates two sample images with different shapes, both initialized as black images (all pixel values are set to zero). These images are represented as NumPy arrays with dimensions (200, 300, 3), where 200 is the height, 300 is the width, and 3 represents the three color channels (red, green, blue) for each pixel.</p>
<ul class="simple">
<li><p><strong>Image1:</strong> A blue region (pixels with blue color, [255, 0, 0]) is set within the region defined by [50:150, 100:200].</p></li>
<li><p><strong>Image2:</strong> A green region (pixels with green color, [0, 255, 0]) is set within the region defined by [100:200, 150:250].</p></li>
</ul>
</li>
<li><p><strong>Bitwise AND Operation:</strong>
The code performs a bitwise AND operation between Image1 and Image2 using OpenCV’s <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code> function. This operation combines the two images, preserving only the regions where both images have non-zero (i.e., colored) pixels. The result is stored in the “Result” variable.</p></li>
</ol>
</section>
<section id="element-wise-bitwise-or-with-cv2-bitwise-or">
<h3><span class="section-number">8.1.5.2. </span>Element-Wise Bitwise OR with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code><a class="headerlink" href="#element-wise-bitwise-or-with-cv2-bitwise-or" title="Permalink to this heading">#</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code> function in OpenCV is a powerful tool for performing an element-wise bitwise disjunction (logical OR) operation on input arrays. This operation combines the binary representation of each element in the input arrays, producing a new array with the same size and data type as the input arrays. Here’s a detailed breakdown of how <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code> behaves <span id="id10">[<a class="reference internal" href="../References.html#id37" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="../References.html#id38" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>:</p>
<p><strong>1. Operation on Two Arrays (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code> with the same size):</strong></p>
<ul>
<li><p>When both input arrays (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>) have the same size, the function computes the logical disjunction (bitwise OR) between corresponding elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1(I) OR src2(I) if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>The operation is performed element-wise. Each element in the resulting array <code class="docutils literal notranslate"><span class="pre">dst</span></code> is the result of the logical OR operation between the corresponding elements in <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
<li><p>The optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> parameter allows for selective application of the operation based on the mask values. If <code class="docutils literal notranslate"><span class="pre">mask(I)</span></code> is non-zero, the operation is applied; otherwise, the corresponding element in <code class="docutils literal notranslate"><span class="pre">dst</span></code> remains unchanged.</p></li>
</ul>
<p><strong>2. Operation on an Array and a Scalar (<code class="docutils literal notranslate"><span class="pre">src2</span></code> as a scalar):</strong></p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">src2</span></code> is a scalar (a single value), the function computes the bitwise OR operation between each element of <code class="docutils literal notranslate"><span class="pre">src1</span></code> and the scalar value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1(I) OR src2 if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>If the number of elements in <code class="docutils literal notranslate"><span class="pre">src1</span></code> matches the number of channels in <code class="docutils literal notranslate"><span class="pre">src2</span></code>, the operation can be performed. The scalar is first converted to an array of the same type as <code class="docutils literal notranslate"><span class="pre">src1</span></code>.</p></li>
</ul>
<p><strong>3. Operation on a Scalar and an Array (<code class="docutils literal notranslate"><span class="pre">src1</span></code> as a scalar):</strong></p>
<ul>
<li><p>Similarly, if <code class="docutils literal notranslate"><span class="pre">src1</span></code> is a scalar, the function computes the bitwise OR operation between the scalar value and each element of <code class="docutils literal notranslate"><span class="pre">src2</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1 OR src2(I) if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>If the number of elements in <code class="docutils literal notranslate"><span class="pre">src2</span></code> matches the number of channels in <code class="docutils literal notranslate"><span class="pre">src1</span></code>, the scalar is first converted to an array of the same type as <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
</ul>
<p><strong>4. Handling Floating-Point Arrays and Multi-Channel Arrays:</strong></p>
<ul class="simple">
<li><p>For floating-point input arrays, the machine-specific bit representations (usually IEEE754-compliant) are used for the operation.</p></li>
<li><p>If the input arrays are multi-channel (e.g., a color image with separate channels), the operation is applied independently to each channel.</p></li>
</ul>
<p><strong>Function Syntax</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">src1</span><span class="p">,</span> <span class="n">src2</span><span class="p">[,</span> <span class="n">dst</span><span class="p">[,</span> <span class="n">mask</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">dst</span>
</pre></div>
</div>
<p><strong>Description</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code> function is part of the OpenCV library in Python. It performs the element-wise bitwise disjunction (OR operation) between two input arrays <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>. An optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> can be provided to specify the region where the operation is to be applied. The result of the operation is stored in the output array <code class="docutils literal notranslate"><span class="pre">dst</span></code>.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src1</span></code>: The first input array (image) on which the bitwise OR operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">src2</span></code>: The second input array (image) on which the bitwise OR operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code> (optional): The output array used to store the result of the operation. If not provided, the function creates a new array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mask</span></code> (optional): A mask specifying the region where the operation should be performed. The dimensions of the mask must match the dimensions of <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
</ul>
<p><strong>Return</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The output array containing the result of the bitwise OR operation applied to the input <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>. If <code class="docutils literal notranslate"><span class="pre">dst</span></code> is provided as an argument, the function stores the result in <code class="docutils literal notranslate"><span class="pre">dst</span></code>. Otherwise, a new array is created to hold the result.</p></li>
</ul>
<p><strong>Usage</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code> function is commonly used in image processing to perform logical OR operations on corresponding pixels of two images. It’s often used to combine binary data or create masks. By providing a mask, you can control which regions of the input images are subject to the bitwise OR operation.</p>
<p>For further details on <code class="docutils literal notranslate"><span class="pre">bitwise_or</span></code>, refer to the <a class="reference external" href="https://docs.opencv.org/2.4/modules/core/doc/operations_on_arrays.html#bitwise-or">OpenCV documentation</a>.</p>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create two sample images with different shapes</span>
<span class="n">Image1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image1</span><span class="p">[</span><span class="mi">50</span><span class="p">:</span><span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Blue region</span>

<span class="n">Image2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image2</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span> <span class="mi">150</span><span class="p">:</span><span class="mi">250</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Green region</span>

<span class="c1"># Perform a bitwise OR operation between the two images</span>
<span class="n">Result</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">Image1</span><span class="p">,</span> <span class="n">Image2</span><span class="p">)</span>

<span class="c1"># Create a subplot with three images for visualization</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">9.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="c1"># Display the first image on the first subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image1</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Image 1&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Display the second image on the second subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image2</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Image 2&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Display the result of the bitwise OR operation on the third subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Result</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Bitwise OR Result&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Set aspect ratio and turn off axes for all subplots</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/5122303c37d4409c0d668df9593cce0656dce049ca13a762a18887ccfe148601.png" src="../_images/5122303c37d4409c0d668df9593cce0656dce049ca13a762a18887ccfe148601.png" />
</div>
</div>
<p>The provided code snippet generates three images and displays them using Matplotlib subplots. It utilizes OpenCV’s bitwise OR operation to combine pixel values from two sample images. Let’s break down the code step by step:</p>
<ol class="arabic simple">
<li><p><strong>Creating Sample Images:</strong></p>
<ul class="simple">
<li><p>Two sample images, <code class="docutils literal notranslate"><span class="pre">Image1</span></code> and <code class="docutils literal notranslate"><span class="pre">Image2</span></code>, are created using NumPy. Both images have dimensions (200, 300, 3), which means they are 200 pixels in height, 300 pixels in width, and have 3 color channels (red, green, blue) for each pixel.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">Image1</span></code>, a blue region is created by assigning the value [255, 0, 0] (pure blue) to a specific rectangular region ([50:150, 100:200]) within the image.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">Image2</span></code>, a green region is created by assigning the value [0, 255, 0] (pure green) to a specific rectangular region ([100:200, 150:250]) within the image.</p></li>
</ul>
</li>
<li><p><strong>Bitwise OR Operation:</strong></p>
<ul class="simple">
<li><p>The code performs a bitwise OR operation between <code class="docutils literal notranslate"><span class="pre">Image1</span></code> and <code class="docutils literal notranslate"><span class="pre">Image2</span></code> using OpenCV’s <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code> function. This operation combines the two images by taking the maximum pixel value for each channel at corresponding pixel locations. The result is stored in the “Result” variable.</p></li>
</ul>
</li>
</ol>
<div class="warning admonition">
<p class="admonition-title">Note</p>
<p>In this context, we have discussed two fundamental bitwise operations, <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code> and <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code>. Nevertheless, it’s important to note that the OpenCV library offers a suite of fundamental bitwise operations for image processing, including <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code>, <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code>, <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code>, and <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code>. To gain a comprehensive understanding, let’s explore the distinctions and commonalities among these operations briefly:</p>
<ol class="arabic simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and(src1,</span> <span class="pre">src2[,</span> <span class="pre">dst[,</span> <span class="pre">mask]])</span></code></strong>:</p>
<ul class="simple">
<li><p><strong>Function</strong>: Performs a bitwise AND operation between corresponding pixels of two input images (src1 and src2).</p></li>
<li><p><strong>Usage</strong>: This operation results in an output image where the corresponding pixels are retained if both corresponding pixels in the input images are non-zero.</p></li>
<li><p><strong>Similarity</strong>: Similar to the logical AND operation but operates at the bit level for each pixel in the images.</p></li>
</ul>
</li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not(src[,</span> <span class="pre">dst[,</span> <span class="pre">mask]])</span></code></strong>:</p>
<ul class="simple">
<li><p><strong>Function</strong>: Inverts every bit of the input image (src).</p></li>
<li><p><strong>Usage</strong>: This operation results in an output image where all the 1s (white pixels) in the input image become 0s (black pixels), and vice versa.</p></li>
<li><p><strong>Similarity</strong>: Similar to the logical NOT operation but operates at the bit level for each pixel in the image.</p></li>
</ul>
</li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or(src1,</span> <span class="pre">src2[,</span> <span class="pre">dst[,</span> <span class="pre">mask]])</span></code></strong>:</p>
<ul class="simple">
<li><p><strong>Function</strong>: Performs a bitwise OR operation between corresponding pixels of two input images (src1 and src2).</p></li>
<li><p><strong>Usage</strong>: This operation results in an output image where the corresponding pixels are retained if at least one of the corresponding pixels in the input images is non-zero.</p></li>
<li><p><strong>Similarity</strong>: Similar to the logical OR operation but operates at the bit level for each pixel in the images.</p></li>
</ul>
</li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor(src1,</span> <span class="pre">src2[,</span> <span class="pre">dst[,</span> <span class="pre">mask]])</span></code></strong>:</p>
<ul class="simple">
<li><p><strong>Function</strong>: Performs a bitwise XOR (exclusive OR) operation between corresponding pixels of two input images (src1 and src2).</p></li>
<li><p><strong>Usage</strong>: This operation results in an output image where the corresponding pixels are retained if the corresponding pixels in the input images are different (one is 0 and the other is 1).</p></li>
<li><p><strong>Similarity</strong>: Similar to the logical XOR operation but operates at the bit level for each pixel in the images.</p></li>
</ul>
</li>
</ol>
<p><strong>Differences</strong>:</p>
<ul class="simple">
<li><p>The primary difference lies in the specific bitwise operation each function performs (AND, NOT, OR, XOR) on the corresponding pixels.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">bitwise_and</span></code> and <code class="docutils literal notranslate"><span class="pre">bitwise_or</span></code> functions retain specific pixel combinations based on the logical AND and OR conditions, respectively.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">bitwise_not</span></code> function inverts the bits of the input image.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">bitwise_xor</span></code> function retains pixels only when there is a difference between the corresponding pixels in the input images.</p></li>
</ul>
<p><strong>Similarities</strong>:</p>
<ul class="simple">
<li><p>All these operations work at the bit level, meaning they operate on individual bits of the pixel values.</p></li>
<li><p>They are useful for various image processing tasks, including masking, combining regions, and altering specific aspects of images based on pixel values.</p></li>
<li><p>They allow for fine-grained control over pixel manipulation in image processing tasks.</p></li>
</ul>
</div>
</section>
</section>
<section id="colorspace-conversion-with-cv2-cvtcolor">
<h2><span class="section-number">8.1.6. </span>Colorspace Conversion with <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code><a class="headerlink" href="#colorspace-conversion-with-cv2-cvtcolor" title="Permalink to this heading">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code> function in the Python OpenCV library is a powerful tool for changing the colorspace of an input image or rearranging its image channels. It allows you to convert an input image (source) from one colorspace to another, based on a specified color conversion code. The resulting image can be stored in the output (destination) image, if provided, or a new image is created to hold the converted result <span id="id11">[<a class="reference internal" href="../References.html#id37" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="../References.html#id38" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p>Here’s an in-depth explanation of the parameters and the purpose of this function:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src</span></code>: This parameter represents the input image (source) that you intend to convert. It should be a numpy array, effectively representing the image you want to transform.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">code</span></code>: The <code class="docutils literal notranslate"><span class="pre">code</span></code> parameter specifies the color conversion code or the type of transformation that defines how the input image’s colors will be converted. This code is an integer value corresponding to a specific colorspace conversion or channel rearrangement. For example, <code class="docutils literal notranslate"><span class="pre">cv2.COLOR_BGR2GRAY</span></code> indicates converting from the BGR colorspace to grayscale. The available conversion codes are defined in OpenCV’s documentation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code> (optional): The <code class="docutils literal notranslate"><span class="pre">dst</span></code> parameter serves as the output image (destination) where the result of the colorspace conversion will be stored. If this parameter is not provided, a new image will be created to store the converted result.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dstCn</span></code> (optional): The <code class="docutils literal notranslate"><span class="pre">dstCn</span></code> parameter specifies the number of channels in the destination image. It is used when you want to change the number of channels in the output image. If this parameter is not specified, it defaults to 0, and the number of channels is inferred based on the conversion code.</p></li>
</ul>
<p>Here’s the structure of the function signature:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">code</span><span class="p">[,</span> <span class="n">dst</span><span class="p">[,</span> <span class="n">dstCn</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">dst</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code> function provides a versatile way to transform images between various colorspace representations, such as RGB, grayscale, HSV, YUV, and more. It is a fundamental operation in image processing that enables you to adapt images to different processing techniques or to analyze them from various color perspectives.</p>
<p>For more detailed information and the list of available color conversion codes, you can refer to the <a class="reference external" href="https://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html#cvtcolor">OpenCV documentation on <code class="docutils literal notranslate"><span class="pre">cvtColor</span></code></a>. This function plays a crucial role in image manipulation and analysis, allowing you to work with images in different colorspaces, which is essential in various computer vision and image processing tasks.</p>
<section id="rgb-to-grayscale">
<h3><span class="section-number">8.1.6.1. </span>RGB to Grayscale<a class="headerlink" href="#rgb-to-grayscale" title="Permalink to this heading">#</a></h3>
<p>To convert an image from the RGB (Red, Green, Blue) color space to grayscale, you can use the <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code> function from the OpenCV library with the appropriate color conversion code.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code> function, which is part of the OpenCV library, transforms an RGB (Red, Green, Blue) image to grayscale using a well-defined mathematical formula. This operation is widely used in image processing and computer vision applications.</p>
<p>The process of converting an RGB image to grayscale involves weighted averaging of the color channels (R, G, and B). The formula used by <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code> is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Grayscale</span> <span class="n">Value</span> <span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.299</span> <span class="o">*</span> <span class="n">Red</span> <span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.587</span> <span class="o">*</span> <span class="n">Green</span> <span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.114</span> <span class="o">*</span> <span class="n">Blue</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>In this formula, the coefficients 0.299, 0.587, and 0.114 are specific weights assigned to the Red, Green, and Blue channels, respectively. These weights are based on the human perception of color, as the human eye is more sensitive to green and less sensitive to blue when perceiving grayscale intensity. Please see <a class="reference external" href="https://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html#cvtcolor">this link</a> for more details.</p>
<div class="warning admonition">
<p class="admonition-title">Note</p>
<p>Note that</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load a set of sample images and store them in the &#39;Images&#39; array.</span>
<span class="n">Images</span> <span class="o">=</span> <span class="n">load_sample_images</span><span class="p">()[</span><span class="s1">&#39;images&#39;</span><span class="p">]</span>

<span class="c1"># Select the first image from the &#39;Images&#39; array and assign it to &#39;Img&#39;.</span>
<span class="n">Img</span> <span class="o">=</span> <span class="n">Images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Calculate the grayscale version of the image using custom weighted conversion.</span>
<span class="c1"># The formula 0.299 * R + 0.587 * G + 0.114 * B is employed for each pixel.</span>
<span class="n">Img_GrayScale_</span> <span class="o">=</span> <span class="mf">0.299</span> <span class="o">*</span> <span class="n">Img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.587</span> <span class="o">*</span> <span class="n">Img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.114</span> <span class="o">*</span> <span class="n">Img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">Img_GrayScale_</span> <span class="o">=</span> <span class="n">Img_GrayScale_</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

<span class="c1"># Utilize OpenCV&#39;s inbuilt function to convert &#39;Img&#39; to grayscale using the BGR to Gray transformation.</span>
<span class="n">Img_GrayScale_cv2</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">Img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>

</pre></div>
</div>
<p>These two methods yield different slightly results when converting an image to grayscale</p>
</div>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Note that `Images` and `Names` were defined in the first example.</span>

<span class="c1"># Convert RGB to Grayscale</span>
<span class="n">gray_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">Images</span><span class="p">]</span>
<span class="c1"># Convert each RGB image in the list `Images` to grayscale using cv2.COLOR_BGR2GRAY</span>
<span class="n">inverted_gray_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">gray_images</span><span class="p">]</span>
<span class="c1"># Invert the colors of the grayscale images using bitwise_not to create inverted grayscale images</span>

<span class="c1"># Create titles for the images</span>
<span class="n">gray_titles</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> (Gray)&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">Names</span><span class="p">]</span>
<span class="c1"># Create titles for grayscale images by adding &quot;(Gray)&quot; to the original image names</span>
<span class="n">inverted_gray_titles</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> (Inverted Gray)&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">Names</span><span class="p">]</span>
<span class="c1"># Create titles for inverted grayscale images by adding &quot;(Inverted Gray)&quot; to the original image names</span>

<span class="c1"># Note: Grayscale images only have one color channel (band).</span>
<span class="c1"># Plot the images</span>
<span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">(</span><span class="n">gray_images</span><span class="p">,</span> <span class="n">gray_titles</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;RGB to Grayscale&#39;</span><span class="p">,</span> <span class="n">grayscale</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># Display the grayscale images using the ImShow function with appropriate titles and a grayscale flag</span>
<span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">(</span><span class="n">inverted_gray_images</span><span class="p">,</span> <span class="n">inverted_gray_titles</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;RGB to Grayscale (Inverted)&#39;</span><span class="p">,</span> <span class="n">grayscale</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># Display the inverted grayscale images using the ImShow function with appropriate titles and a grayscale flag</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/e9cfd27f9c46bfb3ab3dec21a07c0591a3e68f12eaddebf36c6421c2019b78f8.png" src="../_images/e9cfd27f9c46bfb3ab3dec21a07c0591a3e68f12eaddebf36c6421c2019b78f8.png" />
<img alt="../_images/e6a4c91611ff18d1d1b69f36a5abdd09e48911167ac75ea430894e08c654724d.png" src="../_images/e6a4c91611ff18d1d1b69f36a5abdd09e48911167ac75ea430894e08c654724d.png" />
</div>
</div>
<div class="warning admonition">
<p class="admonition-title">Note</p>
<p>Grayscale images only have one color channel (band).</p>
</div>
</section>
<section id="rgb-to-hsv">
<h3><span class="section-number">8.1.6.2. </span>RGB to HSV<a class="headerlink" href="#rgb-to-hsv" title="Permalink to this heading">#</a></h3>
<p>Converting an image from the RGB (Red, Green, Blue) color space to the HSV (Hue, Saturation, Value) color space is a common operation in image processing. The HSV color space separates the color information into three components: hue (the color itself), saturation (the intensity of the color), and value (the brightness). Here’s how to perform the RGB to HSV conversion using OpenCV in Python:</p>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Note that `Images` and `Names` were defined in the first example.</span>

<span class="c1"># Convert Images from RGB to HSV color space</span>
<span class="n">augmented_images_hsv</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2HSV</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">Images</span><span class="p">]</span>

<span class="c1"># Display the augmented images in HSV color space</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">(</span><span class="n">augmented_images_hsv</span><span class="p">,</span> <span class="n">Names</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;RGB to HSV&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/84b7f32644c290d396473587123a3dbf6af2395e8dbeeb4b5b81ab228b594caf.png" src="../_images/84b7f32644c290d396473587123a3dbf6af2395e8dbeeb4b5b81ab228b594caf.png" />
</div>
</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./chapter_08"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="ReadMe.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">8. </span>An Introduction to Computer Vision</p>
      </div>
    </a>
    <a class="right-next"
       href="ENGG_680_C08S2.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">8.2. </span>Geometric Transformations</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#sample-images">8.1.1. Sample Images</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#accessing-and-manipulating-pixel-values-in-images">8.1.2. Accessing and Manipulating Pixel Values in Images</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#adding-padding-exploring-border-types-in-opencv-optional-content">8.1.3. Adding Padding: Exploring Border Types in OpenCV (Optional Content)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#image-blending-using-the-cv2-addweighted-function">8.1.4. Image Blending: Using the <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> Function</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bitwise-operations-in-opencv-optional-content">8.1.5. Bitwise Operations in OpenCV (Optional Content)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bitwise-and-operation-with-cv2-bitwise-and">8.1.5.1. Bitwise AND Operation with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#element-wise-bitwise-or-with-cv2-bitwise-or">8.1.5.2. Element-Wise Bitwise OR with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#colorspace-conversion-with-cv2-cvtcolor">8.1.6. Colorspace Conversion with <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rgb-to-grayscale">8.1.6.1. RGB to Grayscale</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rgb-to-hsv">8.1.6.2. RGB to HSV</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Hatef Dastour
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=365ca57ee442770a23c6"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=365ca57ee442770a23c6"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>