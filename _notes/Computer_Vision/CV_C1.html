

<!DOCTYPE html>


<html >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1. Getting Started with OpenCV &#8212; Computer Vision</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/myfile.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'CV_C1';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2. Geometric Transformations" href="CV_C2.html" />
    <link rel="prev" title="Getting Started with Python" href="Getting_Started.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="None"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="Getting_Started.html">
  
  
  
  
    
    
      
    
    
    <img src="_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">1. Getting Started with OpenCV</a></li>
<li class="toctree-l1"><a class="reference internal" href="CV_C2.html">2. Geometric Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="CV_C3.html">3. Drawing Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="CV_C4.html">4. Image Thresholding</a></li>
<li class="toctree-l1"><a class="reference internal" href="CV_C5.html">5. Image Filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="CV_C6.html">6. Morphological Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="References.html">7. References</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Getting Started with OpenCV</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#sample-images">1.1. Sample Images</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#accessing-and-manipulating-pixel-values-in-images">1.2. Accessing and Manipulating Pixel Values in Images</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#adding-padding-exploring-border-types-in-opencv">1.3. Adding Padding: Exploring Border Types in OpenCV</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#image-blending-using-the-cv2-addweighted-function">1.4. Image Blending: Using the <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> Function</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bitwise-operations-in-opencv">1.5. Bitwise Operations in OpenCV</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bitwise-and-operation-with-cv2-bitwise-and">1.5.1. Bitwise AND Operation with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#element-wise-bitwise-not-with-cv2-bitwise-not">1.5.2. Element-Wise Bitwise NOT with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#element-wise-bitwise-or-with-cv2-bitwise-or">1.5.3. Element-Wise Bitwise OR with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#element-wise-bitwise-xor-with-cv2-bitwise-xor">1.5.4. Element-Wise Bitwise XOR with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#colorspace-conversion-with-cv2-cvtcolor">1.6. Colorspace Conversion with <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rgb-to-grayscale">1.6.1. RGB to Grayscale</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rgb-to-hsv">1.6.2. RGB to HSV</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#feature-detection">1.7. Feature Detection</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <div class="tex2jax_ignore mathjax_ignore section" id="getting-started-with-opencv">
<h1><span class="section-number">1. </span>Getting Started with OpenCV<a class="headerlink" href="#getting-started-with-opencv" title="Permalink to this headline">#</a></h1>
<p>OpenCV (Open Source Computer Vision) is a widely acclaimed open-source library that forms the backbone of many computer vision applications. With a rich history dating back to its inception in 1999, OpenCV has evolved into a versatile toolkit that empowers developers to create innovative solutions in the field of image and video analysis. Released under a permissive BSD license, OpenCV has garnered a strong community of researchers, engineers, and enthusiasts who contribute to its growth and enhancement <span id="id1">[<a class="reference internal" href="References.html#id25" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id26" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p>CV2, often referred to as “opencv-python,” is the Python wrapper for the OpenCV library. This wrapper brings the power of OpenCV’s vast functionality to the Python programming ecosystem, making it accessible and convenient for Python developers. With CV2, you can perform a wide range of tasks, including image processing, feature extraction, object detection, video analysis, and more, using the intuitive and expressive syntax of Python.</p>
<p>CV2’s integration with Python has contributed to its popularity and ubiquity in the field of computer vision. It offers a comprehensive suite of functions and tools that enable users to manipulate, analyze, and interpret visual data effortlessly. From simple tasks like image resizing and filtering to complex tasks such as building deep learning models for image recognition, CV2 provides the necessary building blocks.</p>
<p>This tutorial serves as an introductory guide, delving into the fundamental operations of OpenCV. Our journey will be facilitated by the image dataset sourced from scikit-learn, a widely-used machine learning library.</p>
<div class="section" id="sample-images">
<h2><span class="section-number">1.1. </span>Sample Images<a class="headerlink" href="#sample-images" title="Permalink to this headline">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">sklearn.datasets.load_sample_images()</span></code> is a function provided by scikit-learn <span id="id2">[<a class="reference internal" href="References.html#id57" title="scikit-learn Developers. Scikit-learn user guide. https://scikit-learn.org/stable/user_guide.html, 2023. [Online; accessed 01-August-2023].">scikit-learn Developers, 2023</a>]</span>, a popular machine learning library in Python. This function is used to load a collection of sample images, which can be useful for testing and experimenting with image-based machine learning algorithms and data analysis pipelines.</p>
<p>When you call <code class="docutils literal notranslate"><span class="pre">load_sample_images()</span></code>, it retrieves a predefined set of sample images that are bundled with the scikit-learn library. These images cover a range of subjects and formats, providing a diverse set of data for practicing and developing image processing, computer vision, and machine learning techniques.</p>
<p>The loaded images are usually provided as a dictionary-like object, containing the images themselves, information about the images, and sometimes additional metadata. This allows you to quickly access and work with the sample images for various tasks.
If you’re interested, you can access the detailed documentation for this image dataset <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_sample_images.html#sklearn.datasets.load_sample_images">here</a>.</p>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import necessary libraries</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  <span class="c1"># Import the plotting library</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_sample_images</span>  <span class="c1"># Import a function to load sample images</span>

<span class="c1"># Set font properties for plots</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.family&#39;</span><span class="p">:</span> <span class="s1">&#39;Calibri&#39;</span><span class="p">,</span> <span class="s1">&#39;axes.titlesize&#39;</span><span class="p">:</span> <span class="mi">16</span><span class="p">})</span>

<span class="c1"># Define a function to display images with titles and optional settings</span>
<span class="k">def</span> <span class="nf">ImShow</span><span class="p">(</span><span class="n">Images</span><span class="p">,</span> <span class="n">Names</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Images&#39;</span><span class="p">,</span> <span class="n">grayscale</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># Create a figure with two subplots</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">9.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>  <span class="c1"># Create a figure with 1 row and 2 columns of subplots</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># Flatten the subplots for easier manipulation</span>

    <span class="c1"># Iterate over the first two images</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="c1"># Display the image in grayscale if grayscale is True, otherwise in color</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Images</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span> <span class="k">if</span> <span class="n">grayscale</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Set aspect ratio to 1 (square aspect)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>  <span class="c1"># Turn off axis</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">Names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>  <span class="c1"># Set image title with bold font</span>

    <span class="k">if</span> <span class="n">title</span><span class="p">:</span>
        <span class="c1"># Set main title if provided</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>  <span class="c1"># Adjust layout for better spacing</span>

    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>

<span class="c1"># Load sample images</span>
<span class="n">Images</span> <span class="o">=</span> <span class="n">load_sample_images</span><span class="p">()[</span><span class="s1">&#39;images&#39;</span><span class="p">]</span>  <span class="c1"># Load the sample images</span>
<span class="c1"># Extract image names from file paths, removing extension and converting to title case</span>
<span class="n">Names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.jpg&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">load_sample_images</span><span class="p">()[</span><span class="s1">&#39;filenames&#39;</span><span class="p">]]</span>

<span class="c1"># Display the original images</span>
<span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">(</span><span class="n">Images</span><span class="p">,</span> <span class="n">Names</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Original Images&#39;</span><span class="p">)</span>  <span class="c1"># Call the ImShow function to display images</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/8d5103b2d02ae8474dcdfa4cf31de501ba20502759a5464101f7bc1af6dad85b.png" src="_images/8d5103b2d02ae8474dcdfa4cf31de501ba20502759a5464101f7bc1af6dad85b.png" />
</div>
</div>
<p>This code is a Python script that performs the following tasks:</p>
<ol class="arabic simple">
<li><p><strong>Importing Necessary Libraries</strong>:</p>
<ul class="simple">
<li><p>It begins by importing two libraries:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot</span> <span class="pre">as</span> <span class="pre">plt</span></code>: This library is used for creating plots and visualizing data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sklearn.datasets.load_sample_images</span></code>: This function is imported from the scikit-learn library and is used to load sample images for demonstration purposes.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Setting Font Properties for Plots</strong>:</p>
<ul class="simple">
<li><p>The code sets specific font properties for the plots created using Matplotlib. It sets the font family to ‘Calibri’ and the title font size to 16.</p></li>
</ul>
</li>
<li><p><strong>Defining a Function - <code class="docutils literal notranslate"><span class="pre">ImShow</span></code></strong>:</p>
<ul class="simple">
<li><p>This code defines a function named <code class="docutils literal notranslate"><span class="pre">ImShow</span></code> which is used to display images with titles and optional settings. The function takes the following parameters:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Images</span></code>: A list of images to be displayed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Names</span></code>: A list of corresponding image names.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">title</span></code> (optional): A title for the set of images.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">grayscale</span></code> (optional): A flag to indicate whether the images should be displayed in grayscale.</p></li>
</ul>
</li>
<li><p>Inside the function:</p>
<ul>
<li><p>It creates a figure with two subplots arranged in a single row and two columns.</p></li>
<li><p>It flattens the subplots into a one-dimensional array for easier manipulation.</p></li>
<li><p>It iterates over the first two images in the <code class="docutils literal notranslate"><span class="pre">Images</span></code> list and displays them in grayscale or color based on the <code class="docutils literal notranslate"><span class="pre">grayscale</span></code> flag.</p></li>
<li><p>It sets the aspect ratio of each subplot to 1 (making them square), turns off the axis, and sets a title for each image with a bold font.</p></li>
<li><p>If a <code class="docutils literal notranslate"><span class="pre">title</span></code> is provided, it sets a main title for the figure with a bold font and a specified fontsize.</p></li>
<li><p>Finally, it adjusts the layout for better spacing and returns the figure and axis objects.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Loading Sample Images</strong>:</p>
<ul class="simple">
<li><p>It uses the <code class="docutils literal notranslate"><span class="pre">load_sample_images</span></code> function from scikit-learn to load a set of sample images. These images are stored in the <code class="docutils literal notranslate"><span class="pre">Images</span></code> variable.</p></li>
<li><p>It also extracts image names from file paths, removes the ‘.jpg’ extension, and converts them to title case. These names are stored in the <code class="docutils literal notranslate"><span class="pre">Names</span></code> variable.</p></li>
</ul>
</li>
<li><p><strong>Displaying Original Images</strong>:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">ImShow</span></code> function is called to display the original images loaded from the sample dataset. The function is provided with the loaded images (<code class="docutils literal notranslate"><span class="pre">Images</span></code>), their corresponding names (<code class="docutils literal notranslate"><span class="pre">Names</span></code>), and a title (‘Original Images’).</p></li>
<li><p>The results of the function call are not assigned to any variables (indicated by <code class="docutils literal notranslate"><span class="pre">_</span></code>) as the function returns both the figure and axis objects, but they are not used further in this code.</p></li>
</ul>
</li>
</ol>
</div>
<div class="section" id="accessing-and-manipulating-pixel-values-in-images">
<h2><span class="section-number">1.2. </span>Accessing and Manipulating Pixel Values in Images<a class="headerlink" href="#accessing-and-manipulating-pixel-values-in-images" title="Permalink to this headline">#</a></h2>
<p>To gain precise control over pixel values within an image, we leverage the versatile <code class="docutils literal notranslate"><span class="pre">split</span></code> function <span id="id3">[<a class="reference internal" href="References.html#id25" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id26" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>. This function proves invaluable in dissecting the intricate tapestry of color channels present within an image.</p>
<p>In the digital imaging realm, each channel corresponds to a distinct color component. In the ubiquitous RGB color model, we encounter the vibrant Red, Green, and Blue channels. Alternatively, the CMYK model introduces Cyan, Magenta, Yellow, and Black channels. These models, alongside others, collectively govern an image’s appearance through their distinctive channels.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cv2</span>

<span class="c1"># Split the channels of the first image in the &#39;Images&#39; dataset</span>
<span class="n">B</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">Images</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>The following line of code utilizes the <code class="docutils literal notranslate"><span class="pre">cv2.split()</span></code> function to split the channels of the first image in the ‘Images’ dataset. This function separates the image into its individual color channels, where <code class="docutils literal notranslate"><span class="pre">B</span></code> corresponds to the Blue channel, <code class="docutils literal notranslate"><span class="pre">G</span></code> to the Green channel, and <code class="docutils literal notranslate"><span class="pre">R</span></code> to the Red channel. These channels represent the components that collectively create the image’s color when combined.</p>
<p>Alternatively, we can access the red, green, and blue channels of <code class="docutils literal notranslate"><span class="pre">Img</span></code> using the indexing syntax <code class="docutils literal notranslate"><span class="pre">Img[:,:,0]</span></code>, <code class="docutils literal notranslate"><span class="pre">Img[:,:,1]</span></code>, and <code class="docutils literal notranslate"><span class="pre">Img[:,:,2]</span></code>. This concise notation allows direct access to each color channel within the image, where the indices 0, 1, and 2 correspond to the red, green, and blue channels respectively. This indexing approach provides a convenient and efficient way to work with individual color channels, enabling focused manipulation and analysis of the image’s color components.</p>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_sample_image</span>

<span class="c1"># Load an example image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">load_sample_image</span><span class="p">(</span><span class="s1">&#39;flower.jpg&#39;</span><span class="p">)</span>

<span class="c1"># Create a figure with three subplots to display the color channels</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">9.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">))</span>
<span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># Flatten the subplots for easier manipulation</span>

<span class="c1"># Set the main title to the name of the image</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Flower&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

<span class="c1"># Iterate over the three color channels</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">channel_name</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Red&#39;</span><span class="p">,</span> <span class="s1">&#39;Green&#39;</span><span class="p">,</span> <span class="s1">&#39;Blue&#39;</span><span class="p">])):</span>
    <span class="c1"># Create an image with all zeros (black image) of the same size as the original image</span>
    <span class="n">channel_image</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">image</span>
    <span class="c1"># Assign the values of the current color channel to the corresponding channel in the black image</span>
    <span class="n">channel_image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span>
    <span class="c1"># Display the image for the current color channel in the subplot</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">channel_image</span><span class="p">)</span>
    <span class="c1"># Set aspect ratio to 1 to avoid stretching</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Turn off axis for cleaner visualization</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="c1"># Add text label indicating the color channel</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">channel_name</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s2">&quot;square&quot;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;LightSkyBlue&#39;</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/01b47c8673a18072109f48d1e18f54439e53df9ffe3f1cb8c289431c4ff1dc4e.png" src="_images/01b47c8673a18072109f48d1e18f54439e53df9ffe3f1cb8c289431c4ff1dc4e.png" />
</div>
</div>
<p>This code demonstrates how to visualize the individual color channels (Red, Green, and Blue) of an image using Matplotlib. Let’s break down the code step by step:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">matplotlib.pyplot</span> <span class="pre">as</span> <span class="pre">plt</span></code>:</p>
<ul class="simple">
<li><p>This line imports the <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> library’s <code class="docutils literal notranslate"><span class="pre">pyplot</span></code> module and aliases it as <code class="docutils literal notranslate"><span class="pre">plt</span></code>. It allows you to create visualizations and plots.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">sklearn.datasets</span> <span class="pre">import</span> <span class="pre">load_sample_image</span></code>:</p>
<ul class="simple">
<li><p>This line imports the <code class="docutils literal notranslate"><span class="pre">load_sample_image</span></code> function from the <code class="docutils literal notranslate"><span class="pre">datasets</span></code> module of the <code class="docutils literal notranslate"><span class="pre">sklearn</span></code> (scikit-learn) library. It is used to load an example image.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">image</span> <span class="pre">=</span> <span class="pre">load_sample_image('flower.jpg')</span></code>:</p>
<ul class="simple">
<li><p>Here, the <code class="docutils literal notranslate"><span class="pre">load_sample_image</span></code> function is called with the argument <code class="docutils literal notranslate"><span class="pre">'flower.jpg'</span></code>. It loads an example image named ‘flower.jpg’ and assigns it to the variable <code class="docutils literal notranslate"><span class="pre">image</span></code>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">fig,</span> <span class="pre">axes</span> <span class="pre">=</span> <span class="pre">plt.subplots(1,</span> <span class="pre">3,</span> <span class="pre">figsize=(9.5,</span> <span class="pre">2.5))</span></code>:</p>
<ul class="simple">
<li><p>This line creates a figure (<code class="docutils literal notranslate"><span class="pre">fig</span></code>) with three subplots arranged in one row and three columns. The <code class="docutils literal notranslate"><span class="pre">figsize</span></code> parameter sets the dimensions of the figure to 9.5 inches in width and 2.5 inches in height. The resulting <code class="docutils literal notranslate"><span class="pre">axes</span></code> variable is a collection of the subplot axes.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">axes</span> <span class="pre">=</span> <span class="pre">axes.ravel()</span></code>:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">axes</span></code> variable, which initially contains a 2D array of subplots, is flattened into a 1D array using the <code class="docutils literal notranslate"><span class="pre">ravel()</span></code> method. This makes it easier to manipulate the subplots.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">_</span> <span class="pre">=</span> <span class="pre">fig.suptitle('Flower',</span> <span class="pre">weight='bold',</span> <span class="pre">fontsize=18)</span></code>:</p>
<ul class="simple">
<li><p>This line sets the main title of the figure to ‘Flower’ with a bold font style and a font size of 18. The use of <code class="docutils literal notranslate"><span class="pre">_</span></code> suggests that the return value is not explicitly used, which is common when setting titles or labels.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i,</span> <span class="pre">(ax,</span> <span class="pre">channel_name)</span> <span class="pre">in</span> <span class="pre">enumerate(zip(axes,</span> <span class="pre">['Red',</span> <span class="pre">'Green',</span> <span class="pre">'Blue'])):</span></code>:</p>
<ul class="simple">
<li><p>This is a for loop that iterates over three color channels: Red, Green, and Blue. It uses the <code class="docutils literal notranslate"><span class="pre">enumerate</span></code> function to get both the index <code class="docutils literal notranslate"><span class="pre">i</span></code> and the corresponding subplot <code class="docutils literal notranslate"><span class="pre">ax</span></code> and channel name <code class="docutils literal notranslate"><span class="pre">channel_name</span></code>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">channel_image</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">*</span> <span class="pre">image</span></code>:</p>
<ul class="simple">
<li><p>Inside the loop, a new variable <code class="docutils literal notranslate"><span class="pre">channel_image</span></code> is created, initialized as a black image (all values set to 0) with the same dimensions as the original <code class="docutils literal notranslate"><span class="pre">image</span></code>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">channel_image[:,</span> <span class="pre">:,</span> <span class="pre">i]</span> <span class="pre">=</span> <span class="pre">image[:,</span> <span class="pre">:,</span> <span class="pre">i]</span></code>:</p>
<ul class="simple">
<li><p>This line assigns the values of the current color channel (Red, Green, or Blue) from the original <code class="docutils literal notranslate"><span class="pre">image</span></code> to the corresponding channel in the <code class="docutils literal notranslate"><span class="pre">channel_image</span></code>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">_</span> <span class="pre">=</span> <span class="pre">ax.imshow(channel_image)</span></code>:</p>
<ul class="simple">
<li><p>It displays the <code class="docutils literal notranslate"><span class="pre">channel_image</span></code> in the current subplot <code class="docutils literal notranslate"><span class="pre">ax</span></code> using <code class="docutils literal notranslate"><span class="pre">imshow</span></code>, showing the isolated color channel.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">_</span> <span class="pre">=</span> <span class="pre">ax.set_aspect(1)</span></code>:</p>
<ul class="simple">
<li><p>This sets the aspect ratio of the subplot to 1, ensuring that the image is displayed without stretching.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">_</span> <span class="pre">=</span> <span class="pre">ax.axis('off')</span></code>:</p>
<ul class="simple">
<li><p>It turns off the axis (ticks and labels) for the current subplot, providing a cleaner visualization.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">_</span> <span class="pre">=</span> <span class="pre">ax.text(x=0,</span> <span class="pre">y=0,</span> <span class="pre">s=channel_name,</span> <span class="pre">size=14,</span> <span class="pre">color='Navy',</span> <span class="pre">bbox=dict(boxstyle=&quot;square&quot;,</span> <span class="pre">ec='Navy',</span> <span class="pre">fc='LightSkyBlue'))</span></code>:</p>
<ul class="simple">
<li><p>This line adds a text label to the current subplot. It displays the <code class="docutils literal notranslate"><span class="pre">channel_name</span></code> (e.g., ‘Red’, ‘Green’, ‘Blue’) in Navy color with a LightSkyBlue background in a square-shaped box at coordinates (0, 0).</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">plt.tight_layout()</span></code>:</p>
<ul class="simple">
<li><p>Finally, <code class="docutils literal notranslate"><span class="pre">tight_layout()</span></code> is called to ensure that the subplots are neatly arranged within the figure without overlapping.</p></li>
</ul>
</li>
</ol>
</div>
<div class="section" id="adding-padding-exploring-border-types-in-opencv">
<h2><span class="section-number">1.3. </span>Adding Padding: Exploring Border Types in OpenCV<a class="headerlink" href="#adding-padding-exploring-border-types-in-opencv" title="Permalink to this headline">#</a></h2>
<p>In image processing, padding or adding borders to an image is a common operation, often used in tasks like convolution or resizing. OpenCV provides several border types, each with its own unique behavior <span id="id4">[<a class="reference internal" href="References.html#id25" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id26" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>. The <code class="docutils literal notranslate"><span class="pre">cv2.copyMakeBorder</span></code> function in OpenCV is used to create a new image (destination, <code class="docutils literal notranslate"><span class="pre">dst</span></code>) by adding a border around the original image (source, <code class="docutils literal notranslate"><span class="pre">src</span></code>). The border is created based on the specified parameters, such as the offset, border type, and value of the border pixels. Here’s an explanation of the function signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cv2.copyMakeBorder(src, dst, offset, bordertype, value=(0, 0, 0, 0)) → None
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src</span></code>: The source image, which is the input image to which the border will be added.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The destination image, where the result (image with border) will be stored. It should have the size of the output image, which can be calculated based on the input image and the specified offset.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">offset</span></code>: A tuple <code class="docutils literal notranslate"><span class="pre">(top,</span> <span class="pre">bottom,</span> <span class="pre">left,</span> <span class="pre">right)</span></code> that specifies the number of pixels for each side (top, bottom, left, right) by which the image will be extended with the border.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bordertype</span></code>: The type of border to be added, specified as an integer constant. Common border types include <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_CONSTANT</span></code>, <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REPLICATE</span></code>, <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REFLECT</span></code>, and others.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value of the border pixels. This parameter is optional and is only used when the <code class="docutils literal notranslate"><span class="pre">bordertype</span></code> is set to <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_CONSTANT</span></code>. The default value is <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0)</span></code>, which corresponds to black in grayscale images.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.copyMakeBorder</span></code> function modifies the <code class="docutils literal notranslate"><span class="pre">dst</span></code> image by adding a border around the <code class="docutils literal notranslate"><span class="pre">src</span></code> image based on the specified offset and border type. The resulting image in <code class="docutils literal notranslate"><span class="pre">dst</span></code> will have a larger size than the original image, with the specified border.</p>
<p>It’s important to note that the <code class="docutils literal notranslate"><span class="pre">dst</span></code> image should be pre-allocated to accommodate the new size, and the dimensions of the <code class="docutils literal notranslate"><span class="pre">dst</span></code> image can be calculated based on the dimensions of the <code class="docutils literal notranslate"><span class="pre">src</span></code> image and the specified offset.</p>
<p>Let’s delve into these border types:</p>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_CONSTANT</span></code></strong>: This option introduces a border with a consistent color, effectively extending the image’s dimensions. The border’s color remains the same throughout, making it suitable for scenarios where a constant background is desired.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REFLECT</span></code></strong>: When using this option, the border is generated by reflecting the elements along the boundary. This results in a pattern that resembles a mirror reflection, such as “fedcba|abcdefgh|hgfedcb”. It provides a smooth and continuous appearance at the border.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REFLECT_101</span></code> (or <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_DEFAULT</span></code>)</strong>: Similar to <code class="docutils literal notranslate"><span class="pre">BORDER_REFLECT</span></code>, this option creates a border with mirrored reflection. However, the pattern differs slightly, appearing as “gfedcb|abcdefgh|gfedcba”. This border type is popular for tasks that require symmetry preservation.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REPLICATE</span></code></strong>: This option duplicates the last element of each row or column to form the border. The resulting pattern looks like “aaaaaa|abcdefgh|hhhhhhh”, effectively maintaining the edge consistency.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_WRAP</span></code></strong>: Utilizing this option, the image wraps around to form a circular-like pattern in the border. The pattern could be described as “cdefgh|abcdefgh|abcdefg”. This border type is particularly useful for applications dealing with cyclic or periodic data.</p></li>
</ul>
<p>For an in-depth understanding of these border types, along with practical code examples and usage scenarios, it’s highly recommended to refer to the official OpenCV documentation available <a class="reference external" href="https://docs.opencv.org/3.4/dc/da3/tutorial_copyMakeBorder.html">here</a>. This documentation provides detailed insights and examples, enabling you to leverage these border types effectively in various image processing tasks <span id="id5">[<a class="reference internal" href="References.html#id25" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id26" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Mapping of OpenCV border types to their descriptive names</span>
<span class="n">cv2_border_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_CONSTANT</span><span class="p">:</span> <span class="s1">&#39;BORDER_CONSTANT&#39;</span><span class="p">,</span>
                   <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REPLICATE</span><span class="p">:</span> <span class="s1">&#39;BORDER_REPLICATE&#39;</span><span class="p">,</span>
                   <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REFLECT</span><span class="p">:</span> <span class="s1">&#39;BORDER_REFLECT&#39;</span><span class="p">,</span>
                   <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_WRAP</span><span class="p">:</span> <span class="s1">&#39;BORDER_WRAP&#39;</span><span class="p">,</span>
                   <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REFLECT_101</span><span class="p">:</span> <span class="s1">&#39;BORDER_REFLECT_101&#39;</span><span class="p">}</span>

<span class="c1"># RGB Colors for the border</span>
<span class="n">RGB</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">RGB</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">255</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;RGB Colors:&#39;</span><span class="p">,</span> <span class="n">RGB</span><span class="p">)</span>

<span class="c1"># Create a 2x3 grid of subplots to display images</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">9.5</span><span class="p">,</span> <span class="mf">5.5</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="n">fig</span><span class="o">.</span><span class="n">delaxes</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Remove the last subplot (blank)</span>

<span class="c1"># Set the title for the overall figure</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Border Types Applied&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

<span class="c1"># Iterate over the different border types and apply them to the image</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">border_type</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cv2_border_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
    <span class="c1"># Apply the specified border to the image (Images[1]) with padding values</span>
    <span class="n">img_with_border</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">copyMakeBorder</span><span class="p">(</span><span class="n">Images</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="n">border_type</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">RGB</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="c1"># Display the image with the applied border on the current subplot</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img_with_border</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>RGB Colors: [[255, 0, 0], [0, 255, 0], [0, 0, 255]]
</pre></div>
</div>
<img alt="_images/23a221cb735d1cda5606c8a37c32f64983106a2f5776828f462f3b3d203f9c7f.png" src="_images/23a221cb735d1cda5606c8a37c32f64983106a2f5776828f462f3b3d203f9c7f.png" />
</div>
</div>
<p>This code demonstrates the application of different border types to an image using the OpenCV library and visualizes the results using Matplotlib subplots. Let’s break down the code step by step:</p>
<ol class="arabic simple">
<li><p>Importing Libraries:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">cv2</span></code>: This imports the OpenCV library, which is used for computer vision tasks.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">matplotlib.pyplot</span> <span class="pre">as</span> <span class="pre">plt</span></code>: This imports the Matplotlib library for creating plots and visualizations.</p></li>
</ul>
</li>
<li><p>Creating a Dictionary:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cv2_border_dict</span></code>: This is a Python dictionary that maps OpenCV border types to their descriptive names. It’s used to label the different borders in the visualization.</p></li>
</ul>
</li>
<li><p>Defining RGB Colors:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RGB</span></code>: This is a list of lists representing RGB colors. In this case, it’s initialized to three lists, each representing black (all zeros). Then, the diagonal elements (R, G, and B) are set to 255 to create white, which is used for border color.</p></li>
</ul>
</li>
<li><p>Creating a 2x3 Subplot Grid:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fig,</span> <span class="pre">ax</span> <span class="pre">=</span> <span class="pre">plt.subplots(2,</span> <span class="pre">3,</span> <span class="pre">figsize=(9.5,</span> <span class="pre">5.5))</span></code>: This creates a 2x3 grid of subplots for displaying images. The <code class="docutils literal notranslate"><span class="pre">fig</span></code> represents the entire figure, and <code class="docutils literal notranslate"><span class="pre">ax</span></code> is an array of subplot axes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ax</span> <span class="pre">=</span> <span class="pre">ax.ravel()</span></code>: This flattens the 2x3 grid into a 1D array for easier iteration.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fig.delaxes(ax[-1])</span></code>: This removes the last subplot in the grid, making it appear as if there are only five subplots (2x2 grid) since the last one is blank.</p></li>
</ul>
</li>
<li><p>Setting Figure Title:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fig.suptitle('Border</span> <span class="pre">Types</span> <span class="pre">Applied',</span> <span class="pre">weight='bold',</span> <span class="pre">fontsize=18)</span></code>: This sets the title for the entire figure with a bold font and a font size of 18.</p></li>
</ul>
</li>
<li><p>Iterating Over Border Types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i,</span> <span class="pre">(border_type,</span> <span class="pre">name)</span> <span class="pre">in</span> <span class="pre">enumerate(cv2_border_dict.items()):</span></code>: This loop iterates through the <code class="docutils literal notranslate"><span class="pre">cv2_border_dict</span></code> dictionary to access each border type and its descriptive name.</p></li>
</ul>
</li>
<li><p>Applying Borders to Images:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">img_with_border</span> <span class="pre">=</span> <span class="pre">cv2.copyMakeBorder(Images[1],</span> <span class="pre">15,</span> <span class="pre">15,</span> <span class="pre">15,</span> <span class="pre">15,</span> <span class="pre">border_type,</span> <span class="pre">value=RGB[0])</span></code>: Inside the loop, this line applies the specified border type (from <code class="docutils literal notranslate"><span class="pre">cv2_border_dict</span></code>) to an image (assumed to be stored in <code class="docutils literal notranslate"><span class="pre">Images[1]</span></code>) with specified padding values and a border color of white.</p></li>
</ul>
</li>
<li><p>Displaying Images:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ax[i].imshow(img_with_border)</span></code>: This displays the image with the applied border on the current subplot.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ax[i].set_aspect(1)</span></code>: It sets the aspect ratio of the subplot to 1, ensuring that the image is displayed without distortion.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ax[i].axis('off')</span></code>: This removes the axis labels and ticks from the subplot.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ax[i].set_title(name,</span> <span class="pre">weight='bold',</span> <span class="pre">fontsize=12)</span></code>: It sets the title for the current subplot using the descriptive name of the border type with a bold font and a font size of 12.</p></li>
</ul>
</li>
<li><p>Finalizing the Plot:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">plt.tight_layout()</span></code>: This command adjusts the layout of the subplots to ensure they fit properly in the figure.</p></li>
</ul>
</li>
</ol>
</div>
<div class="section" id="image-blending-using-the-cv2-addweighted-function">
<h2><span class="section-number">1.4. </span>Image Blending: Using the <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> Function<a class="headerlink" href="#image-blending-using-the-cv2-addweighted-function" title="Permalink to this headline">#</a></h2>
<p>Image blending is a fundamental technique in image processing that combines two images to create a new composite image. OpenCV provides the <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> function, which performs image blending based on a weighted sum of the input images and an additional constant value. Here’s an explanation of the blending formula and how it works
<span id="id6">[<a class="reference internal" href="References.html#id25" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id26" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>:</p>
<p>The formula for image blending using <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> is as follows:</p>
<div class="amsmath math notranslate nohighlight" id="equation-b6a5b9fe-62a7-47b9-9b42-e9a9741f902e">
<span class="eqno">(1.1)<a class="headerlink" href="#equation-b6a5b9fe-62a7-47b9-9b42-e9a9741f902e" title="Permalink to this equation">#</a></span>\[\begin{equation}
dst = \alpha \cdot src1 + \beta \cdot src2 + \gamma
\end{equation}\]</div>
<p>In this formula:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code> are the two input images to be blended.</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha\)</span> is a weighting factor that determines the influence of <code class="docutils literal notranslate"><span class="pre">src1</span></code> in the final output. It satisfies the condition <span class="math notranslate nohighlight">\(0 \leq \alpha \leq 1\)</span>, meaning it controls the relative contribution of <code class="docutils literal notranslate"><span class="pre">src1</span></code> to the blended image.</p></li>
<li><p><span class="math notranslate nohighlight">\((1 - \alpha)\)</span> represents the weighting factor for <code class="docutils literal notranslate"><span class="pre">src2</span></code>, ensuring that the sum of the weights for both images is 1.</p></li>
<li><p><span class="math notranslate nohighlight">\(\gamma\)</span> is an additional constant value that can be added to the blended result. It is an integer value that can be used for brightness adjustment.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> function in OpenCV is used for image blending, which combines two input images (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>) together using a specified weight for each image. The resulting blended image is stored in the destination image (<code class="docutils literal notranslate"><span class="pre">dst</span></code>). Here’s an explanation of the function signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cv2.addWeighted(src1, alpha, src2, beta, gamma, dst) → None
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src1</span></code>: The first source image, which is the primary input image for blending.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alpha</span></code>: The weight applied to the first source image (<code class="docutils literal notranslate"><span class="pre">src1</span></code>). This value determines the contribution of <code class="docutils literal notranslate"><span class="pre">src1</span></code> to the final result. A larger <code class="docutils literal notranslate"><span class="pre">alpha</span></code> value increases the influence of <code class="docutils literal notranslate"><span class="pre">src1</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">src2</span></code>: The second source image, which is the secondary input image for blending.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">beta</span></code>: The weight applied to the second source image (<code class="docutils literal notranslate"><span class="pre">src2</span></code>). This value determines the contribution of <code class="docutils literal notranslate"><span class="pre">src2</span></code> to the final result. A larger <code class="docutils literal notranslate"><span class="pre">beta</span></code> value increases the influence of <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gamma</span></code>: A scalar added to the weighted sum of the two source images. This value can be used to control the brightness or contrast of the resulting image.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The destination image, where the blended image is stored. The dimensions of this image should match the dimensions of the input images.</p></li>
</ul>
<p>You can see the full description of this function <a class="reference external" href="https://docs.opencv.org/3.4/d5/dc4/tutorial_adding_images.html">here</a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> function performs a linear combination of the two source images (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>) based on the specified weights <code class="docutils literal notranslate"><span class="pre">alpha</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code>, and then adds the scalar <code class="docutils literal notranslate"><span class="pre">gamma</span></code> to the resulting sum. The resulting blended image is written to the <code class="docutils literal notranslate"><span class="pre">dst</span></code> image <span id="id7">[<a class="reference internal" href="References.html#id25" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id26" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p>This function is commonly used for image fusion, creating special effects, adjusting image brightness and contrast, and other image processing tasks where combining two images with different weights is required. The <code class="docutils literal notranslate"><span class="pre">alpha</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code> values control the influence of each source image, and the <code class="docutils literal notranslate"><span class="pre">gamma</span></code> value can be used to control the overall brightness or contrast of the final image.</p>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import necessary libraries</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>  <span class="c1"># Import numpy for array operations</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  <span class="c1"># Import matplotlib for visualization</span>
<span class="kn">import</span> <span class="nn">cv2</span>  <span class="c1"># Import OpenCV for image processing</span>

<span class="c1"># Load example images (&#39;china.jpg&#39; and &#39;flower.jpg&#39; assumed to be available)</span>
<span class="n">Img1</span> <span class="o">=</span> <span class="n">load_sample_image</span><span class="p">(</span><span class="s1">&#39;china.jpg&#39;</span><span class="p">)</span>
<span class="n">Img2</span> <span class="o">=</span> <span class="n">load_sample_image</span><span class="p">(</span><span class="s1">&#39;flower.jpg&#39;</span><span class="p">)</span>

<span class="c1"># Method 1: Using cv2.addWeighted for Image Blending</span>
<span class="c1"># Blend two different images using weighted sums</span>
<span class="c1"># 0.7 and 0.3 are the weights applied to the first and second image, respectively</span>
<span class="c1"># 0 is the scalar value added to the resulting image</span>
<span class="n">augmented_img_01</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">addWeighted</span><span class="p">(</span><span class="n">Img1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="n">Img2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># Method 2: Custom Image Blending</span>
<span class="c1"># Blend two different images using custom weighted sums</span>
<span class="c1"># We use numpy for element-wise multiplication and addition, rounding the result, and converting to &#39;uint8&#39; data type</span>
<span class="c1"># This technique allows manual control of blending weights</span>
<span class="n">augmented_img_02</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="mf">0.7</span> <span class="o">*</span> <span class="n">Img1</span> <span class="o">+</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">Img2</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>

<span class="c1"># Display the original and transformed images with titles</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">(</span><span class="n">Images</span><span class="o">=</span><span class="p">[</span><span class="n">augmented_img_01</span><span class="p">,</span> <span class="n">augmented_img_02</span><span class="p">],</span>
                 <span class="n">Names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cv2.addWeighted&#39;</span><span class="p">,</span> <span class="s1">&#39;Custom Blend&#39;</span><span class="p">],</span>
                 <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Image Blending&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/29d1de00fdfb6d031a436a1802989b738c99c632727f46de7b466be85c6bb628.png" src="_images/29d1de00fdfb6d031a436a1802989b738c99c632727f46de7b466be85c6bb628.png" />
</div>
</div>
<p>This code demonstrates image blending using two different methods, and it showcases the results in a side-by-side comparison using subplots. Here’s a step-by-step explanation:</p>
<ol class="arabic simple">
<li><p>Importing Libraries:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">numpy</span> <span class="pre">as</span> <span class="pre">np</span></code>: This imports the NumPy library, which is commonly used for array operations and numerical computations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">matplotlib.pyplot</span> <span class="pre">as</span> <span class="pre">plt</span></code>: This imports the Matplotlib library, particularly the <code class="docutils literal notranslate"><span class="pre">pyplot</span></code> module, for creating visualizations and plots.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">cv2</span></code>: This imports the OpenCV library, which is used for various image processing tasks.</p></li>
</ul>
</li>
<li><p>Loading Images:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Img1</span> <span class="pre">=</span> <span class="pre">load_sample_image('china.jpg')</span></code>: This code assumes that there is a function named <code class="docutils literal notranslate"><span class="pre">load_sample_image</span></code> that loads the image named ‘china.jpg’ and assigns it to the variable <code class="docutils literal notranslate"><span class="pre">Img1</span></code>. Similarly, ‘flower.jpg’ is loaded into <code class="docutils literal notranslate"><span class="pre">Img2</span></code>. The assumption is that these image files are available in the working directory.</p></li>
</ul>
</li>
<li><p>Method 1: Using <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> for Image Blending:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">augmented_img_01</span> <span class="pre">=</span> <span class="pre">cv2.addWeighted(Img1,</span> <span class="pre">0.7,</span> <span class="pre">Img2,</span> <span class="pre">0.3,</span> <span class="pre">0)</span></code>: This line blends two different images, <code class="docutils literal notranslate"><span class="pre">Img1</span></code> and <code class="docutils literal notranslate"><span class="pre">Img2</span></code>, using the <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> function. It applies a weighted sum where 0.7 and 0.3 are the weights applied to the first and second images, respectively. The last parameter (0) specifies a scalar value added to the resulting image, effectively acting as an offset.</p></li>
</ul>
</li>
<li><p>Method 2: Custom Image Blending:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">augmented_img_02</span> <span class="pre">=</span> <span class="pre">np.round((0.7</span> <span class="pre">*</span> <span class="pre">Img1</span> <span class="pre">+</span> <span class="pre">0.3</span> <span class="pre">*</span> <span class="pre">Img2)).astype('uint8')</span></code>: In this method, two different images (<code class="docutils literal notranslate"><span class="pre">Img1</span></code> and <code class="docutils literal notranslate"><span class="pre">Img2</span></code>) are blended using custom weighted sums. NumPy is used for element-wise multiplication and addition of the pixel values. The result is rounded and cast to ‘uint8’ data type, which is a common data type for image pixels. This technique allows manual control of the blending weights.</p></li>
</ul>
</li>
<li><p>Displaying Images:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fig,</span> <span class="pre">ax</span> <span class="pre">=</span> <span class="pre">ImShow(Images=[augmented_img_01,</span> <span class="pre">augmented_img_02],</span> <span class="pre">...</span></code>: This code attempts to display the original and transformed images side by side using a function called <code class="docutils literal notranslate"><span class="pre">ImShow</span></code>. The <code class="docutils literal notranslate"><span class="pre">Images</span></code> list contains the blended images (<code class="docutils literal notranslate"><span class="pre">augmented_img_01</span></code> and <code class="docutils literal notranslate"><span class="pre">augmented_img_02</span></code>), and the <code class="docutils literal notranslate"><span class="pre">Names</span></code> list provides titles for each image, ‘cv2.addWeighted’ and ‘Custom Blend’. The <code class="docutils literal notranslate"><span class="pre">title</span></code> argument specifies the title for the entire visualization.</p></li>
</ul>
</li>
</ol>
</div>
<div class="section" id="bitwise-operations-in-opencv">
<h2><span class="section-number">1.5. </span>Bitwise Operations in OpenCV<a class="headerlink" href="#bitwise-operations-in-opencv" title="Permalink to this headline">#</a></h2>
<p>Bitwise operations are fundamental operations in computer programming and image processing that manipulate individual bits within binary representations of data. These operations involve performing logical and mathematical operations at the bit level, which can be particularly useful in tasks such as image manipulation, data compression, encryption, and hardware-level operations. You can perform bitwise operations on integers and use these operations for image processing with libraries like OpenCV. Here’s a brief overview of how bitwise operations work in Python:</p>
<div class="figure align-left" id="id16">
<a class="reference internal image-reference" href="_images/bitwise_op.png"><img alt="_images/bitwise_op.png" src="_images/bitwise_op.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 1.1 </span><span class="caption-text">Examples of Bitwise Operations.</span><a class="headerlink" href="#id16" title="Permalink to this image">#</a></p>
</div>
<ol class="arabic simple">
<li><p><strong>Bitwise AND (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) and OR (<code class="docutils literal notranslate"><span class="pre">|</span></code>)</strong>:
You can use the <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> operator for bitwise AND and the <code class="docutils literal notranslate"><span class="pre">|</span></code> operator for bitwise OR. These operators compare corresponding bits of two integers and produce a new integer where each bit is the result of the corresponding bitwise operation.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Given integers</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">28</span>

<span class="c1"># Print the binary representation of a and b</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Binary for </span><span class="si">%i</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Binary for </span><span class="si">%i</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>

<span class="c1"># Bitwise AND operation</span>
<span class="n">result_and</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span>  <span class="c1"># Bitwise AND: 0001 (1 in decimal)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a &amp; b = </span><span class="si">%i</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result_and</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">result_and</span><span class="p">)))</span>

<span class="c1"># Bitwise OR operation</span>
<span class="n">result_or</span> <span class="o">=</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span>   <span class="c1"># Bitwise OR: 0111 (7 in decimal)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a | b = </span><span class="si">%i</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result_or</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">result_or</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Binary for 21 = 0b10101
Binary for 28 = 0b11100
a &amp; b = 20 (0b10100)
a | b = 29 (0b11101)
</pre></div>
</div>
</div>
</div>
<div class="important admonition">
<p class="admonition-title">Remark</p>
<p>To convert a number to its binary representation in Python, you can use the <code class="docutils literal notranslate"><span class="pre">bin()</span></code> function. This function takes an integer as input and returns a string that represents the binary value of that integer, with the “0b” prefix <span id="id8">[<a class="reference internal" href="References.html#id5" title="Python Software Foundation. Python 3.11.4 documentation. https://docs.python.org/, 2023. [Online; accessed 01-August-2023].">Python Software Foundation, 2023</a>]</span>.</p>
<p>Here’s an example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">number</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">binary_value</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">binary_value</span><span class="p">)</span>  <span class="c1"># Output: &#39;0b101010&#39;</span>
</pre></div>
</div>
<p>If you want to remove the “0b” prefix and get the binary representation as a plain string, you can use string slicing:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">number</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">binary_string</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">number</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">binary_string</span><span class="p">)</span>  <span class="c1"># Output: &#39;101010&#39;</span>
</pre></div>
</div>
<p>If you need to pad the binary representation with leading zeros to a certain length (e.g., 8 bits), you can use the <code class="docutils literal notranslate"><span class="pre">format()</span></code> function with the <code class="docutils literal notranslate"><span class="pre">'b'</span></code> format specifier:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">number</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">binary_padded</span> <span class="o">=</span> <span class="nb">format</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="s1">&#39;08b&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">binary_padded</span><span class="p">)</span>  <span class="c1"># Output: &#39;00101010&#39;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">'08b'</span></code> format specifier means:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'0'</span></code>: The character used for padding (leading zeros).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'8'</span></code>: The width of the output string (total length).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'b'</span></code>: Indicates binary representation.</p></li>
</ul>
<p>Futhermore, you can convert a binary string to an integer using the <code class="docutils literal notranslate"><span class="pre">int()</span></code> function with the base set to 2. Here’s an example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">binary_string</span> <span class="o">=</span> <span class="s2">&quot;1101&quot;</span>
<span class="n">integer_value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">binary_string</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Binary:&quot;</span><span class="p">,</span> <span class="n">binary_string</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Integer:&quot;</span><span class="p">,</span> <span class="n">integer_value</span><span class="p">)</span>
</pre></div>
</div>
<p>This code converts the binary string “1101” to the corresponding integer value, which is 13 in decimal representation. The <code class="docutils literal notranslate"><span class="pre">int()</span></code> function takes two arguments: the first argument is the string containing the binary representation, and the second argument specifies the base, which is 2 for binary. The resulting integer value is then printed.</p>
</div>
<ol class="arabic simple" start="2">
<li><p><strong>Bitwise XOR (<code class="docutils literal notranslate"><span class="pre">^</span></code>) and NOT (<code class="docutils literal notranslate"><span class="pre">~</span></code>)</strong>:
The <code class="docutils literal notranslate"><span class="pre">^</span></code> operator is used for bitwise XOR, which compares corresponding bits and produces a new integer with the XOR result. The <code class="docutils literal notranslate"><span class="pre">~</span></code> operator is used for bitwise NOT, which inverts all bits of an integer.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Given integers</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">28</span>

<span class="c1"># Print the binary representation of a and b</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Binary for </span><span class="si">%i</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Binary for </span><span class="si">%i</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>

<span class="c1"># Bitwise XOR operation</span>
<span class="n">result_xor</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a ^ b = </span><span class="si">%i</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result_xor</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">result_xor</span><span class="p">)))</span>

<span class="c1"># Bitwise NOT operation</span>
<span class="n">result_not</span> <span class="o">=</span> <span class="o">~</span><span class="n">a</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;~a  = </span><span class="si">%i</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result_not</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">result_not</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Binary for 21 = 0b10101
Binary for 28 = 0b11100
a ^ b = 9 (0b1001)
~a  = -22 (-0b10110)
</pre></div>
</div>
</div>
</div>
<div class="important admonition">
<p class="admonition-title">Remark</p>
<p>When you use the <code class="docutils literal notranslate"><span class="pre">bin()</span></code> function in Python, it returns a string that includes a negative sign (<code class="docutils literal notranslate"><span class="pre">-</span></code>) and the binary representation. This is consistent with the two’s complement representation used for signed integers.</p>
<p>Let’s break down the example to clarify:</p>
<ol class="arabic">
<li><p>Given: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">21</span></code>. The binary representation of <code class="docutils literal notranslate"><span class="pre">21</span></code> is <code class="docutils literal notranslate"><span class="pre">10101</span></code> (5 bits, assuming 32-bit representation).</p></li>
<li><p>Applying the bitwise NOT (<code class="docutils literal notranslate"><span class="pre">~</span></code>) operation to <code class="docutils literal notranslate"><span class="pre">21</span></code> inverts each bit: <code class="docutils literal notranslate"><span class="pre">01010</span></code>.</p></li>
<li><p>Now, let’s interpret this result as a signed integer:</p>
<ul class="simple">
<li><p>In binary, <code class="docutils literal notranslate"><span class="pre">01010</span></code> is the binary representation of the decimal value <code class="docutils literal notranslate"><span class="pre">10</span></code>. This is the positive interpretation.</p></li>
<li><p>However, in signed two’s complement representation, to get the negative value, you first invert all the bits and then add 1.</p></li>
</ul>
<p>Inverting <code class="docutils literal notranslate"><span class="pre">01010</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">10101</span>
</pre></div>
</div>
<p>Adding 1 to the inverted value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">10110</span>
</pre></div>
</div>
</li>
<li><p>The result is <code class="docutils literal notranslate"><span class="pre">-10110</span></code>. When you use the <code class="docutils literal notranslate"><span class="pre">bin()</span></code> function to convert this to a binary string, Python includes the negative sign (<code class="docutils literal notranslate"><span class="pre">-</span></code>) and the binary representation, resulting in <code class="docutils literal notranslate"><span class="pre">-0b10110</span></code>.</p></li>
</ol>
<p>So, it’s important to understand that the <code class="docutils literal notranslate"><span class="pre">~</span></code> operator does perform bitwise inversion, but when the result is interpreted as a signed integer (in two’s complement representation), the negative sign is included in the binary string representation. This is why you see <code class="docutils literal notranslate"><span class="pre">-0b10110</span></code> as the output when <code class="docutils literal notranslate"><span class="pre">~a</span></code> is <code class="docutils literal notranslate"><span class="pre">-22</span></code>.</p>
</div>
<p>These bitwise operations are fundamental building blocks in binary image manipulation and can be applied to individual pixel values when working with image data. When working with images in OpenCV, you can use these operations to perform tasks such as masking, image blending, and more by applying them to the pixel values of the images.</p>
<p>These operations are particularly efficient and are often used in low-level programming, such as optimizing memory usage, performing pixel-level operations in image processing, and implementing various data manipulation algorithms.</p>
<p>In image processing, bitwise operations can be used for tasks such as creating masks, extracting specific color channels, setting or clearing specific bits, and combining images using logical conditions. In hardware design, bitwise operations are essential for controlling individual bits in registers and memory-mapped devices.</p>
<p>OpenCV provides several essential bitwise operations for manipulating individual bits within arrays. These operations offer the ability to perform logical operations at the bit level, making them useful for various image processing tasks that involve binary data. Here’s an explanation of each bitwise operation along with links to their documentation <span id="id9">[<a class="reference internal" href="References.html#id25" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id26" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>:</p>
<div class="section" id="bitwise-and-operation-with-cv2-bitwise-and">
<h3><span class="section-number">1.5.1. </span>Bitwise AND Operation with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code><a class="headerlink" href="#bitwise-and-operation-with-cv2-bitwise-and" title="Permalink to this headline">#</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code> function in OpenCV is a versatile tool for performing element-wise bitwise conjunction (logical AND) operations between arrays. This function allows you to apply the AND operation between corresponding elements of two input arrays or an array and a scalar. The resulting array, <code class="docutils literal notranslate"><span class="pre">dst</span></code>, has the same size and data type as the input arrays, making it useful for a variety of image processing tasks <span id="id10">[<a class="reference internal" href="References.html#id25" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id26" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p><strong>Key Concepts:</strong></p>
<ol class="arabic">
<li><p><strong>Operation on Two Arrays (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code> with the same size):</strong></p>
<ul>
<li><p>When both input arrays (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>) have the same size, the function computes the logical AND operation between corresponding elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1(I) AND src2(I) if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>The operation is performed element-wise. Each element in the resulting array <code class="docutils literal notranslate"><span class="pre">dst</span></code> is the result of the logical AND operation between the corresponding elements in <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
<li><p>The optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> parameter allows you to selectively apply the operation based on the mask values. If <code class="docutils literal notranslate"><span class="pre">mask(I)</span></code> is non-zero, the operation is applied; otherwise, the corresponding element in <code class="docutils literal notranslate"><span class="pre">dst</span></code> remains unchanged.</p></li>
</ul>
</li>
<li><p><strong>Operation on an Array and a Scalar (<code class="docutils literal notranslate"><span class="pre">src2</span></code> as a scalar):</strong></p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">src2</span></code> is a scalar (a single value), the function computes the bitwise AND operation between each element of <code class="docutils literal notranslate"><span class="pre">src1</span></code> and the scalar value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1(I) AND src2 if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>If the number of elements in <code class="docutils literal notranslate"><span class="pre">src1</span></code> matches the number of channels in <code class="docutils literal notranslate"><span class="pre">src2</span></code>, the operation can be performed. The scalar is first converted to an array of the same type as <code class="docutils literal notranslate"><span class="pre">src1</span></code>.</p></li>
</ul>
</li>
<li><p><strong>Operation on a Scalar and an Array (<code class="docutils literal notranslate"><span class="pre">src1</span></code> as a scalar):</strong></p>
<ul>
<li><p>Similarly, if <code class="docutils literal notranslate"><span class="pre">src1</span></code> is a scalar, the function computes the bitwise AND operation between the scalar value and each element of <code class="docutils literal notranslate"><span class="pre">src2</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1 AND src2(I) if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>If the number of elements in <code class="docutils literal notranslate"><span class="pre">src2</span></code> matches the number of channels in <code class="docutils literal notranslate"><span class="pre">src1</span></code>, the scalar is first converted to an array of the same type as <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
</ul>
</li>
<li><p><strong>Handling Floating-Point Arrays and Multi-Channel Arrays:</strong></p>
<ul class="simple">
<li><p>For floating-point input arrays, the machine-specific bit representations (usually IEEE754-compliant) are used for the operation.</p></li>
<li><p>When dealing with multi-channel input arrays (e.g., a color image with separate channels), the operation is applied independently to each channel.</p></li>
</ul>
</li>
</ol>
<p><strong>Function Syntax</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">src1</span><span class="p">,</span> <span class="n">src2</span><span class="p">[,</span> <span class="n">dst</span><span class="p">[,</span> <span class="n">mask</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">dst</span>
</pre></div>
</div>
<p><strong>Description</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code> function is part of the OpenCV library in Python, and it performs element-wise bitwise AND operations between two input arrays <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>. An optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> can be provided to specify the region where the operation is applied. The result of the operation is stored in the output array <code class="docutils literal notranslate"><span class="pre">dst</span></code>.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src1</span></code>: The first input array (image) on which the bitwise AND operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">src2</span></code>: The second input array (image) on which the bitwise AND operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code> (optional): The output array to store the result of the operation. If not provided, the function creates a new array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mask</span></code> (optional): A mask specifying the region where the operation should be performed. The dimensions of the mask must match the dimensions of <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
</ul>
<p><strong>Return</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The output array containing the result of the bitwise AND operation between <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>. If <code class="docutils literal notranslate"><span class="pre">dst</span></code> is provided as an argument, the function stores the result in <code class="docutils literal notranslate"><span class="pre">dst</span></code>. Otherwise, a new array is created to hold the result.</p></li>
</ul>
<p><strong>Usage</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code> function is commonly used in image processing to perform bitwise AND operations on corresponding pixels of two images. This can be useful for tasks such as masking or extracting specific regions of interest (ROI) from an image based on a provided mask.</p>
<p>For more detailed information on <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code>, you can refer to the <a class="reference external" href="https://docs.opencv.org/2.4/modules/core/doc/operations_on_arrays.html#bitwise-and">OpenCV documentation</a>.</p>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create two sample images with different shapes</span>
<span class="n">Image1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image1</span><span class="p">[</span><span class="mi">50</span><span class="p">:</span><span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Blue region</span>

<span class="n">Image2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image2</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span> <span class="mi">150</span><span class="p">:</span><span class="mi">250</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Green region</span>

<span class="c1"># Perform a bitwise AND operation between the two images</span>
<span class="n">Result</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">Image1</span><span class="p">,</span> <span class="n">Image2</span><span class="p">)</span>

<span class="c1"># Create a subplot with three images for visualization</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">9.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="c1"># Display the first image on the first subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image1</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Image 1&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Display the second image on the second subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image2</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Image 2&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Display the result of the bitwise AND operation on the third subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Result</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Bitwise AND Result&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Set aspect ratio and turn off axes for all subplots</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/f31e3ea8c8ef90fac1cf4fad158fa09f6a3b06918725fb94a7d364cad514816d.png" src="_images/f31e3ea8c8ef90fac1cf4fad158fa09f6a3b06918725fb94a7d364cad514816d.png" />
</div>
</div>
<p>The provided code snippet generates three images and displays them using Matplotlib subplots. It uses the OpenCV library to perform a bitwise AND operation between two sample images, creating a new resulting image. Let’s break down the code step by step:</p>
<ol class="arabic simple">
<li><p><strong>Creating Sample Images:</strong>
The code creates two sample images with different shapes, both initialized as black images (all pixel values are set to zero). These images are represented as NumPy arrays with dimensions (200, 300, 3), where 200 is the height, 300 is the width, and 3 represents the three color channels (red, green, blue) for each pixel.</p>
<ul class="simple">
<li><p><strong>Image1:</strong> A blue region (pixels with blue color, [255, 0, 0]) is set within the region defined by [50:150, 100:200].</p></li>
<li><p><strong>Image2:</strong> A green region (pixels with green color, [0, 255, 0]) is set within the region defined by [100:200, 150:250].</p></li>
</ul>
</li>
<li><p><strong>Bitwise AND Operation:</strong>
The code performs a bitwise AND operation between Image1 and Image2 using OpenCV’s <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code> function. This operation combines the two images, preserving only the regions where both images have non-zero (i.e., colored) pixels. The result is stored in the “Result” variable.</p></li>
</ol>
</div>
<div class="section" id="element-wise-bitwise-not-with-cv2-bitwise-not">
<h3><span class="section-number">1.5.2. </span>Element-Wise Bitwise NOT with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code><a class="headerlink" href="#element-wise-bitwise-not-with-cv2-bitwise-not" title="Permalink to this headline">#</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code> function in OpenCV is a valuable tool for performing an element-wise bitwise NOT operation on an input array. This operation inverts every bit, effectively flipping 0s to 1s and 1s to 0s, in the binary representation of each element within the input array. The resulting array, <code class="docutils literal notranslate"><span class="pre">dst</span></code>, maintains the same size and data type as the input array, making it suitable for various image processing tasks <span id="id11">[<a class="reference internal" href="References.html#id25" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id26" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p><strong>Key Concepts:</strong></p>
<ol class="arabic">
<li><p><strong>Purpose:</strong>
The primary purpose of <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code> is to compute the bitwise NOT (bitwise inversion) of each element in the input array. This creates a corresponding output array with inverted bit values.</p></li>
<li><p><strong>Operation:</strong>
For each element in the input array <code class="docutils literal notranslate"><span class="pre">src</span></code>, the bitwise NOT operation is applied independently. Mathematically, the operation can be represented as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = ¬src(I)
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">dst(I)</span></code> is the value at the same position in the output array, and <code class="docutils literal notranslate"><span class="pre">src(I)</span></code> is the value in the input array.</p>
</li>
<li><p><strong>Handling Floating-Point Input:</strong>
If the input array is of floating-point type (e.g., single-precision or double-precision floating-point), the function uses the machine-specific bit representation of each floating-point element to perform the bitwise NOT operation. This representation typically adheres to the IEEE 754 standard for floating-point representation.</p></li>
<li><p><strong>Multi-Channel Arrays:</strong>
When dealing with multi-channel input arrays (e.g., a color image represented as separate channels), the operation is applied independently to each channel. Consequently, each channel’s bit values are inverted, resulting in a multi-channel output array.</p></li>
</ol>
<p><strong>Function Syntax</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">src</span><span class="p">[,</span> <span class="n">dst</span><span class="p">[,</span> <span class="n">mask</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">dst</span>
</pre></div>
</div>
<p><strong>Description</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code> function is a part of the OpenCV library in Python. It performs the element-wise bitwise negation operation (NOT operation) on the input array <code class="docutils literal notranslate"><span class="pre">src</span></code>. Additionally, it allows for an optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> to specify the region where the operation is to be applied. The result of the operation is stored in the output array <code class="docutils literal notranslate"><span class="pre">dst</span></code>.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src</span></code>: The input array (image) on which the bitwise NOT operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code> (optional): The output array used to store the result of the operation. If not provided, the function creates a new array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mask</span></code> (optional): An 8-bit, single-channel array that specifies elements of the output array to be modified. This mask parameter allows the selective application of the bitwise NOT operation to specific elements based on the mask values.</p></li>
</ul>
<p><strong>Return</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The output array containing the result of the bitwise NOT operation applied to the input <code class="docutils literal notranslate"><span class="pre">src</span></code>. If <code class="docutils literal notranslate"><span class="pre">dst</span></code> is provided as an argument, the function stores the result in <code class="docutils literal notranslate"><span class="pre">dst</span></code>. Otherwise, a new array is created to hold the result.</p></li>
</ul>
<p><strong>Usage</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code> function is commonly used in image processing to invert every bit (pixel value) of an image. This operation is useful for creating the complement of a binary image or for inverting a mask. By specifying a mask, you can control which region of the image is subject to the bitwise NOT operation.</p>
<p>For more detailed information on <code class="docutils literal notranslate"><span class="pre">bitwise_not</span></code>, you can refer to the <a class="reference external" href="https://docs.opencv.org/2.4/modules/core/doc/operations_on_arrays.html#bitwise-not">OpenCV documentation</a>.</p>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">io</span>

<span class="c1"># Load the GitHub logo from a URL</span>
<span class="n">Git</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s1">&#39;https://github.githubassets.com/images/modules/open_graph/github-mark.png&#39;</span><span class="p">)</span>

<span class="c1"># Define the scale factor for resizing (5% of the original size)</span>
<span class="n">scale</span> <span class="o">=</span> <span class="mf">0.05</span>

<span class="c1"># Resize the GitHub logo using OpenCV</span>
<span class="n">Git_resized</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">Git</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">Git</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)),</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">INTER_AREA</span><span class="p">)</span>

<span class="c1"># Invert the colors of the resized logo using bitwise NOT</span>
<span class="n">Git_resized</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">Git_resized</span><span class="p">)</span>

<span class="c1"># Get the first image from the dataset</span>
<span class="n">Img</span> <span class="o">=</span> <span class="n">Images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Create an empty mask with the same dimensions as Img</span>
<span class="n">Mask</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">Img</span>

<span class="c1"># Place the resized and inverted logo (Git_resized) onto the mask</span>
<span class="n">Mask</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="n">Git_resized</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">:</span> <span class="n">Git_resized</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Git_resized</span>

<span class="c1"># Add the mask with the logo to the original image (Img)</span>
<span class="n">Img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Img</span><span class="p">,</span> <span class="n">Mask</span><span class="p">)</span>

<span class="c1"># Apply a binary threshold to the &quot;Img&quot; image</span>
<span class="c1"># The threshold value is 130, and the maximum value after thresholding is 255</span>
<span class="c1"># The result is stored in the &quot;Out&quot; image</span>
<span class="n">_</span><span class="p">,</span> <span class="n">Out</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">Img</span><span class="p">,</span> <span class="mi">130</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">THRESH_BINARY</span><span class="p">)</span>

<span class="c1"># Show both the original &quot;Img&quot; image and the thresholded &quot;Out&quot; image</span>
<span class="c1"># Add titles to the images for clarity</span>
<span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">([</span><span class="n">Mask</span><span class="p">,</span> <span class="n">Img</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Logo&#39;</span><span class="p">,</span> <span class="s1">&#39;Image + Logo&#39;</span><span class="p">],</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;cv2.bitwise_not&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/68ff77fb31440c1050df5d3a4c0a3568c1c5785e96b6c7b7e047798b71b297d8.png" src="_images/68ff77fb31440c1050df5d3a4c0a3568c1c5785e96b6c7b7e047798b71b297d8.png" />
</div>
</div>
<p>This code loads the GitHub logo from a URL, resizes and inverts it, and then adds the resized logo to an image from a dataset. The final result is shown in a subplot, illustrating the original image with the added logo. The use of <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code> inverts the logo, and the logo is placed on the mask using slicing. The <code class="docutils literal notranslate"><span class="pre">cv2.add</span></code> function is used to combine the original image and the mask with the logo. The code also provides visualizations using matplotlib subplots for comparison.</p>
</div>
<div class="section" id="element-wise-bitwise-or-with-cv2-bitwise-or">
<h3><span class="section-number">1.5.3. </span>Element-Wise Bitwise OR with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code><a class="headerlink" href="#element-wise-bitwise-or-with-cv2-bitwise-or" title="Permalink to this headline">#</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code> function in OpenCV is a powerful tool for performing an element-wise bitwise disjunction (logical OR) operation on input arrays. This operation combines the binary representation of each element in the input arrays, producing a new array with the same size and data type as the input arrays. Here’s a detailed breakdown of how <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code> behaves <span id="id12">[<a class="reference internal" href="References.html#id25" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id26" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>:</p>
<p><strong>1. Operation on Two Arrays (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code> with the same size):</strong></p>
<ul>
<li><p>When both input arrays (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>) have the same size, the function computes the logical disjunction (bitwise OR) between corresponding elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1(I) OR src2(I) if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>The operation is performed element-wise. Each element in the resulting array <code class="docutils literal notranslate"><span class="pre">dst</span></code> is the result of the logical OR operation between the corresponding elements in <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
<li><p>The optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> parameter allows for selective application of the operation based on the mask values. If <code class="docutils literal notranslate"><span class="pre">mask(I)</span></code> is non-zero, the operation is applied; otherwise, the corresponding element in <code class="docutils literal notranslate"><span class="pre">dst</span></code> remains unchanged.</p></li>
</ul>
<p><strong>2. Operation on an Array and a Scalar (<code class="docutils literal notranslate"><span class="pre">src2</span></code> as a scalar):</strong></p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">src2</span></code> is a scalar (a single value), the function computes the bitwise OR operation between each element of <code class="docutils literal notranslate"><span class="pre">src1</span></code> and the scalar value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1(I) OR src2 if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>If the number of elements in <code class="docutils literal notranslate"><span class="pre">src1</span></code> matches the number of channels in <code class="docutils literal notranslate"><span class="pre">src2</span></code>, the operation can be performed. The scalar is first converted to an array of the same type as <code class="docutils literal notranslate"><span class="pre">src1</span></code>.</p></li>
</ul>
<p><strong>3. Operation on a Scalar and an Array (<code class="docutils literal notranslate"><span class="pre">src1</span></code> as a scalar):</strong></p>
<ul>
<li><p>Similarly, if <code class="docutils literal notranslate"><span class="pre">src1</span></code> is a scalar, the function computes the bitwise OR operation between the scalar value and each element of <code class="docutils literal notranslate"><span class="pre">src2</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1 OR src2(I) if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>If the number of elements in <code class="docutils literal notranslate"><span class="pre">src2</span></code> matches the number of channels in <code class="docutils literal notranslate"><span class="pre">src1</span></code>, the scalar is first converted to an array of the same type as <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
</ul>
<p><strong>4. Handling Floating-Point Arrays and Multi-Channel Arrays:</strong></p>
<ul class="simple">
<li><p>For floating-point input arrays, the machine-specific bit representations (usually IEEE754-compliant) are used for the operation.</p></li>
<li><p>If the input arrays are multi-channel (e.g., a color image with separate channels), the operation is applied independently to each channel.</p></li>
</ul>
<p><strong>Function Syntax</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">src1</span><span class="p">,</span> <span class="n">src2</span><span class="p">[,</span> <span class="n">dst</span><span class="p">[,</span> <span class="n">mask</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">dst</span>
</pre></div>
</div>
<p><strong>Description</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code> function is part of the OpenCV library in Python. It performs the element-wise bitwise disjunction (OR operation) between two input arrays <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>. An optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> can be provided to specify the region where the operation is to be applied. The result of the operation is stored in the output array <code class="docutils literal notranslate"><span class="pre">dst</span></code>.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src1</span></code>: The first input array (image) on which the bitwise OR operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">src2</span></code>: The second input array (image) on which the bitwise OR operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code> (optional): The output array used to store the result of the operation. If not provided, the function creates a new array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mask</span></code> (optional): A mask specifying the region where the operation should be performed. The dimensions of the mask must match the dimensions of <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
</ul>
<p><strong>Return</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The output array containing the result of the bitwise OR operation applied to the input <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>. If <code class="docutils literal notranslate"><span class="pre">dst</span></code> is provided as an argument, the function stores the result in <code class="docutils literal notranslate"><span class="pre">dst</span></code>. Otherwise, a new array is created to hold the result.</p></li>
</ul>
<p><strong>Usage</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code> function is commonly used in image processing to perform logical OR operations on corresponding pixels of two images. It’s often used to combine binary data or create masks. By providing a mask, you can control which regions of the input images are subject to the bitwise OR operation.</p>
<p>For further details on <code class="docutils literal notranslate"><span class="pre">bitwise_or</span></code>, refer to the <a class="reference external" href="https://docs.opencv.org/2.4/modules/core/doc/operations_on_arrays.html#bitwise-or">OpenCV documentation</a>.</p>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create two sample images with different shapes</span>
<span class="n">Image1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image1</span><span class="p">[</span><span class="mi">50</span><span class="p">:</span><span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Blue region</span>

<span class="n">Image2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image2</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span> <span class="mi">150</span><span class="p">:</span><span class="mi">250</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Green region</span>

<span class="c1"># Perform a bitwise OR operation between the two images</span>
<span class="n">Result</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">Image1</span><span class="p">,</span> <span class="n">Image2</span><span class="p">)</span>

<span class="c1"># Create a subplot with three images for visualization</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">9.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="c1"># Display the first image on the first subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image1</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Image 1&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Display the second image on the second subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image2</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Image 2&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Display the result of the bitwise OR operation on the third subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Result</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Bitwise OR Result&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Set aspect ratio and turn off axes for all subplots</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/305aa627cab59b2b9f725dccaba72daefcced909dec5c1c77dcf6744f0494764.png" src="_images/305aa627cab59b2b9f725dccaba72daefcced909dec5c1c77dcf6744f0494764.png" />
</div>
</div>
<p>The provided code snippet generates three images and displays them using Matplotlib subplots. It utilizes OpenCV’s bitwise OR operation to combine pixel values from two sample images. Let’s break down the code step by step:</p>
<ol class="arabic simple">
<li><p><strong>Creating Sample Images:</strong></p>
<ul class="simple">
<li><p>Two sample images, <code class="docutils literal notranslate"><span class="pre">Image1</span></code> and <code class="docutils literal notranslate"><span class="pre">Image2</span></code>, are created using NumPy. Both images have dimensions (200, 300, 3), which means they are 200 pixels in height, 300 pixels in width, and have 3 color channels (red, green, blue) for each pixel.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">Image1</span></code>, a blue region is created by assigning the value [255, 0, 0] (pure blue) to a specific rectangular region ([50:150, 100:200]) within the image.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">Image2</span></code>, a green region is created by assigning the value [0, 255, 0] (pure green) to a specific rectangular region ([100:200, 150:250]) within the image.</p></li>
</ul>
</li>
<li><p><strong>Bitwise OR Operation:</strong></p>
<ul class="simple">
<li><p>The code performs a bitwise OR operation between <code class="docutils literal notranslate"><span class="pre">Image1</span></code> and <code class="docutils literal notranslate"><span class="pre">Image2</span></code> using OpenCV’s <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code> function. This operation combines the two images by taking the maximum pixel value for each channel at corresponding pixel locations. The result is stored in the “Result” variable.</p></li>
</ul>
</li>
</ol>
</div>
<div class="section" id="element-wise-bitwise-xor-with-cv2-bitwise-xor">
<h3><span class="section-number">1.5.4. </span>Element-Wise Bitwise XOR with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code><a class="headerlink" href="#element-wise-bitwise-xor-with-cv2-bitwise-xor" title="Permalink to this headline">#</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code> function in OpenCV is a versatile tool for performing an element-wise bitwise exclusive OR (XOR) operation on input arrays. This operation combines the binary representation of each element in the input arrays, producing a new array with the same size and data type as the input arrays. Here’s a detailed breakdown of how <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code> behaves <span id="id13">[<a class="reference internal" href="References.html#id25" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id26" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>:</p>
<p><strong>1. Operation on Two Arrays (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code> with the same size):</strong></p>
<ul>
<li><p>When both input arrays (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>) have the same size, the function computes the logical exclusive OR (bitwise XOR) between corresponding elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1(I) XOR src2(I) if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>The operation is performed element-wise. Each element in the resulting array <code class="docutils literal notranslate"><span class="pre">dst</span></code> is the result of the logical XOR operation between the corresponding elements in <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
<li><p>The optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> parameter allows for selective application of the operation based on the mask values. If <code class="docutils literal notranslate"><span class="pre">mask(I)</span></code> is non-zero, the operation is applied; otherwise, the corresponding element in <code class="docutils literal notranslate"><span class="pre">dst</span></code> remains unchanged.</p></li>
</ul>
<p><strong>2. Operation on an Array and a Scalar (<code class="docutils literal notranslate"><span class="pre">src2</span></code> as a scalar):</strong></p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">src2</span></code> is a scalar (a single value), the function computes the bitwise XOR operation between each element of <code class="docutils literal notranslate"><span class="pre">src1</span></code> and the scalar value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1(I) XOR src2 if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>If the number of elements in <code class="docutils literal notranslate"><span class="pre">src1</span></code> matches the number of channels in <code class="docutils literal notranslate"><span class="pre">src2</span></code>, the operation can be performed. The scalar is first converted to an array of the same type as <code class="docutils literal notranslate"><span class="pre">src1</span></code>.</p></li>
</ul>
<p><strong>3. Operation on a Scalar and an Array (<code class="docutils literal notranslate"><span class="pre">src1</span></code> as a scalar):</strong></p>
<ul>
<li><p>Similarly, if <code class="docutils literal notranslate"><span class="pre">src1</span></code> is a scalar, the function computes the bitwise XOR operation between the scalar value and each element of <code class="docutils literal notranslate"><span class="pre">src2</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1 XOR src2(I) if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>If the number of elements in <code class="docutils literal notranslate"><span class="pre">src2</span></code> matches the number of channels in <code class="docutils literal notranslate"><span class="pre">src1</span></code>, the scalar is first converted to an array of the same type as <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
</ul>
<p><strong>4. Handling Floating-Point Arrays and Multi-Channel Arrays:</strong></p>
<ul class="simple">
<li><p>For floating-point input arrays, the machine-specific bit representations (usually IEEE754-compliant) are used for the operation.</p></li>
<li><p>If the input arrays are multi-channel (e.g., a color image with separate channels), the operation is applied independently to each channel.</p></li>
</ul>
<p><strong>Function Syntax</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="n">src1</span><span class="p">,</span> <span class="n">src2</span><span class="p">[,</span> <span class="n">dst</span><span class="p">[,</span> <span class="n">mask</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">dst</span>
</pre></div>
</div>
<p><strong>Description</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code> function is part of the OpenCV library in Python. It performs the element-wise bitwise exclusive OR (XOR) operation between two input arrays <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>. An optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> can be provided to specify the region where the operation is to be applied. The result of the operation is stored in the output array <code class="docutils literal notranslate"><span class="pre">dst</span></code>.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src1</span></code>: The first input array (image) on which the bitwise XOR operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">src2</span></code>: The second input array (image) on which the bitwise XOR operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code> (optional): The output array used to store the result of the operation. If not provided, the function creates a new array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mask</span></code> (optional): A mask specifying the region where the operation should be performed. The dimensions of the mask must match the dimensions of <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
</ul>
<p><strong>Return</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The output array containing the result of the bitwise XOR operation between <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>. If <code class="docutils literal notranslate"><span class="pre">dst</span></code> is provided as an argument, the function stores the result in <code class="docutils literal notranslate"><span class="pre">dst</span></code>. Otherwise, a new array is created to hold the result.</p></li>
</ul>
<p><strong>Usage</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code> function is commonly used in image processing to perform logical XOR operations on corresponding pixels of two images. It’s useful for tasks like creating binary patterns, detecting differences between images, and other operations that involve exclusive combinations of binary data. By providing a mask, you can control which regions of the input images are subject to the bitwise XOR operation.</p>
<p>By utilizing the <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code> function, you can manipulate images at the bit level, enabling a wide range of operations for binary data manipulation in various computer vision applications. Understanding these operations is valuable for various computer vision tasks involving binary representations.</p>
<p>For further details on <code class="docutils literal notranslate"><span class="pre">bitwise_xor</span></code>, refer to the <a class="reference external" href="https://docs.opencv.org/2.4/modules/core/doc/operations_on_arrays.html#bitwise-xor">OpenCV documentation</a>.</p>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create two sample images with different shapes</span>
<span class="n">Image1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image1</span><span class="p">[</span><span class="mi">50</span><span class="p">:</span><span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Blue region</span>

<span class="n">Image2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image2</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span> <span class="mi">150</span><span class="p">:</span><span class="mi">250</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Green region</span>

<span class="c1"># Perform a bitwise XOR operation between the two images</span>
<span class="n">Result</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="n">Image1</span><span class="p">,</span> <span class="n">Image2</span><span class="p">)</span>

<span class="c1"># Create a subplot with three images for visualization</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">9.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="c1"># Display the first image on the first subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image1</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Image 1&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Display the second image on the second subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image2</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Image 2&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Display the result of the bitwise XOR operation on the third subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Result</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Bitwise XOR Result&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Set aspect ratio and turn off axes for all subplots</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/0590dee4a74fd4912bd24156b0ff2a3cc551c1f8f59f0233a704fa55952b2af9.png" src="_images/0590dee4a74fd4912bd24156b0ff2a3cc551c1f8f59f0233a704fa55952b2af9.png" />
</div>
</div>
<p>Let’s break down the code step by step:</p>
<ol class="arabic simple">
<li><p><strong>Creating Sample Images:</strong></p>
<ul class="simple">
<li><p>Two sample images, <code class="docutils literal notranslate"><span class="pre">Image1</span></code> and <code class="docutils literal notranslate"><span class="pre">Image2</span></code>, are created using NumPy. Both images have dimensions (200, 300, 3), which means they are 200 pixels in height, 300 pixels in width, and have 3 color channels (red, green, blue) for each pixel.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">Image1</span></code>, a blue region is created by assigning the value [255, 0, 0] (pure blue) to a specific rectangular region ([50:150, 100:200]) within the image.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">Image2</span></code>, a green region is created by assigning the value [0, 255, 0] (pure green) to a specific rectangular region ([100:200, 150:250]) within the image.</p></li>
</ul>
</li>
<li><p><strong>Bitwise XOR Operation:</strong></p>
<ul class="simple">
<li><p>The code performs a bitwise XOR operation between <code class="docutils literal notranslate"><span class="pre">Image1</span></code> and <code class="docutils literal notranslate"><span class="pre">Image2</span></code> using OpenCV’s <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code> function. This operation combines the two images by applying the XOR operation to the pixel values for each channel at corresponding pixel locations. The result is stored in the “Result” variable</p></li>
</ul>
</li>
</ol>
<div class="tip admonition">
<p class="admonition-title">Summary</p>
<p><code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code>, <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code>, <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code>, and <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code> are fundamental bitwise operations provided by the OpenCV library for image processing. Here are the differences and similarities between these operations:</p>
<ol class="arabic simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and(src1,</span> <span class="pre">src2[,</span> <span class="pre">dst[,</span> <span class="pre">mask]])</span></code></strong>:</p>
<ul class="simple">
<li><p><strong>Function</strong>: Performs a bitwise AND operation between corresponding pixels of two input images (src1 and src2).</p></li>
<li><p><strong>Usage</strong>: This operation results in an output image where the corresponding pixels are retained if both corresponding pixels in the input images are non-zero.</p></li>
<li><p><strong>Similarity</strong>: Similar to the logical AND operation but operates at the bit level for each pixel in the images.</p></li>
</ul>
</li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not(src[,</span> <span class="pre">dst[,</span> <span class="pre">mask]])</span></code></strong>:</p>
<ul class="simple">
<li><p><strong>Function</strong>: Inverts every bit of the input image (src).</p></li>
<li><p><strong>Usage</strong>: This operation results in an output image where all the 1s (white pixels) in the input image become 0s (black pixels), and vice versa.</p></li>
<li><p><strong>Similarity</strong>: Similar to the logical NOT operation but operates at the bit level for each pixel in the image.</p></li>
</ul>
</li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or(src1,</span> <span class="pre">src2[,</span> <span class="pre">dst[,</span> <span class="pre">mask]])</span></code></strong>:</p>
<ul class="simple">
<li><p><strong>Function</strong>: Performs a bitwise OR operation between corresponding pixels of two input images (src1 and src2).</p></li>
<li><p><strong>Usage</strong>: This operation results in an output image where the corresponding pixels are retained if at least one of the corresponding pixels in the input images is non-zero.</p></li>
<li><p><strong>Similarity</strong>: Similar to the logical OR operation but operates at the bit level for each pixel in the images.</p></li>
</ul>
</li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor(src1,</span> <span class="pre">src2[,</span> <span class="pre">dst[,</span> <span class="pre">mask]])</span></code></strong>:</p>
<ul class="simple">
<li><p><strong>Function</strong>: Performs a bitwise XOR (exclusive OR) operation between corresponding pixels of two input images (src1 and src2).</p></li>
<li><p><strong>Usage</strong>: This operation results in an output image where the corresponding pixels are retained if the corresponding pixels in the input images are different (one is 0 and the other is 1).</p></li>
<li><p><strong>Similarity</strong>: Similar to the logical XOR operation but operates at the bit level for each pixel in the images.</p></li>
</ul>
</li>
</ol>
<p><strong>Differences</strong>:</p>
<ul class="simple">
<li><p>The primary difference lies in the specific bitwise operation each function performs (AND, NOT, OR, XOR) on the corresponding pixels.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">bitwise_and</span></code> and <code class="docutils literal notranslate"><span class="pre">bitwise_or</span></code> functions retain specific pixel combinations based on the logical AND and OR conditions, respectively.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">bitwise_not</span></code> function inverts the bits of the input image.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">bitwise_xor</span></code> function retains pixels only when there is a difference between the corresponding pixels in the input images.</p></li>
</ul>
<p><strong>Similarities</strong>:</p>
<ul class="simple">
<li><p>All these operations work at the bit level, meaning they operate on individual bits of the pixel values.</p></li>
<li><p>They are useful for various image processing tasks, including masking, combining regions, and altering specific aspects of images based on pixel values.</p></li>
<li><p>They allow for fine-grained control over pixel manipulation in image processing tasks.</p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="colorspace-conversion-with-cv2-cvtcolor">
<h2><span class="section-number">1.6. </span>Colorspace Conversion with <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code><a class="headerlink" href="#colorspace-conversion-with-cv2-cvtcolor" title="Permalink to this headline">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code> function in the Python OpenCV library is a powerful tool for changing the colorspace of an input image or rearranging its image channels. It allows you to convert an input image (source) from one colorspace to another, based on a specified color conversion code. The resulting image can be stored in the output (destination) image, if provided, or a new image is created to hold the converted result <span id="id14">[<a class="reference internal" href="References.html#id25" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id26" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p>Here’s an in-depth explanation of the parameters and the purpose of this function:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src</span></code>: This parameter represents the input image (source) that you intend to convert. It should be a numpy array, effectively representing the image you want to transform.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">code</span></code>: The <code class="docutils literal notranslate"><span class="pre">code</span></code> parameter specifies the color conversion code or the type of transformation that defines how the input image’s colors will be converted. This code is an integer value corresponding to a specific colorspace conversion or channel rearrangement. For example, <code class="docutils literal notranslate"><span class="pre">cv2.COLOR_BGR2GRAY</span></code> indicates converting from the BGR colorspace to grayscale. The available conversion codes are defined in OpenCV’s documentation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code> (optional): The <code class="docutils literal notranslate"><span class="pre">dst</span></code> parameter serves as the output image (destination) where the result of the colorspace conversion will be stored. If this parameter is not provided, a new image will be created to store the converted result.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dstCn</span></code> (optional): The <code class="docutils literal notranslate"><span class="pre">dstCn</span></code> parameter specifies the number of channels in the destination image. It is used when you want to change the number of channels in the output image. If this parameter is not specified, it defaults to 0, and the number of channels is inferred based on the conversion code.</p></li>
</ul>
<p>Here’s the structure of the function signature:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">code</span><span class="p">[,</span> <span class="n">dst</span><span class="p">[,</span> <span class="n">dstCn</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">dst</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code> function provides a versatile way to transform images between various colorspace representations, such as RGB, grayscale, HSV, YUV, and more. It is a fundamental operation in image processing that enables you to adapt images to different processing techniques or to analyze them from various color perspectives.</p>
<p>For more detailed information and the list of available color conversion codes, you can refer to the <a class="reference external" href="https://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html#cvtcolor">OpenCV documentation on <code class="docutils literal notranslate"><span class="pre">cvtColor</span></code></a>. This function plays a crucial role in image manipulation and analysis, allowing you to work with images in different colorspaces, which is essential in various computer vision and image processing tasks.</p>
<div class="section" id="rgb-to-grayscale">
<h3><span class="section-number">1.6.1. </span>RGB to Grayscale<a class="headerlink" href="#rgb-to-grayscale" title="Permalink to this headline">#</a></h3>
<p>To convert an image from the RGB (Red, Green, Blue) color space to grayscale, you can use the <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code> function from the OpenCV library with the appropriate color conversion code. Here’s how to do it in Python:</p>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Convert RGB to Grayscale</span>
<span class="n">gray_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">Images</span><span class="p">]</span>
<span class="n">inverted_gray_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">gray_images</span><span class="p">]</span>

<span class="c1"># Create titles for the images</span>
<span class="n">gray_titles</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> (Gray)&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">Names</span><span class="p">]</span>
<span class="n">inverted_gray_titles</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> (Inverted Gray)&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">Names</span><span class="p">]</span>

<span class="c1"># Plot the images</span>
<span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">(</span> <span class="n">gray_images</span><span class="p">,</span> <span class="n">gray_titles</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span> <span class="s1">&#39;RGB to Grayscale&#39;</span> <span class="p">,</span><span class="n">grayscale</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">(</span> <span class="n">inverted_gray_images</span><span class="p">,</span> <span class="n">inverted_gray_titles</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span> <span class="s1">&#39;RGB to Grayscale (Inverted)&#39;</span> <span class="p">,</span><span class="n">grayscale</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/7c1a348c9997c90ebc9fcec4b7ea2695cfe88a3955fe7453bd412f88de86d9af.png" src="_images/7c1a348c9997c90ebc9fcec4b7ea2695cfe88a3955fe7453bd412f88de86d9af.png" />
<img alt="_images/26239fb4614e5088b8d5273250a9689778b1a4296a4d4f1adaf30e9553e4792c.png" src="_images/26239fb4614e5088b8d5273250a9689778b1a4296a4d4f1adaf30e9553e4792c.png" />
</div>
</div>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.font_manager</span> <span class="kn">import</span> <span class="n">FontProperties</span>

<span class="c1"># Function to plot a set of images with titles</span>
<span class="k">def</span> <span class="nf">plot_images</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">titles</span><span class="p">,</span> <span class="n">suptitle</span><span class="p">):</span>
    <span class="n">num_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
    <span class="c1"># Create a figure and a row of subplots with the specified size</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_images</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># Flatten the subplot array for easier access</span>
    
    <span class="c1"># Iterate through images and titles</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_images</span><span class="p">):</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;gray&#39;</span><span class="p">)</span>  <span class="c1"># Display the image in grayscale</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>  <span class="c1"># Adjust aspect ratio to auto</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>  <span class="c1"># Turn off axis labels</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>  <span class="c1"># Set the image title</span>
    
    <span class="n">_</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>  <span class="c1"># Adjust spacing between subplots</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">suptitle</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>  <span class="c1"># Set the overall title</span>

<span class="c1"># Convert RGB to Grayscale</span>
<span class="n">gray_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">Images</span><span class="p">]</span>
<span class="n">inverted_gray_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">gray_images</span><span class="p">]</span>

<span class="c1"># Create titles for the images</span>
<span class="n">gray_titles</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> (Gray)&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">Names</span><span class="p">]</span>
<span class="n">inverted_gray_titles</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> (Inverted Gray)&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">Names</span><span class="p">]</span>

<span class="c1"># Plot the images</span>
<span class="n">plot_images</span><span class="p">(</span><span class="n">gray_images</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">gray_titles</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;RGB to Grayscale&#39;</span><span class="p">)</span>
<span class="n">plot_images</span><span class="p">(</span><span class="n">inverted_gray_images</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">inverted_gray_titles</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;RGB to Grayscale (Inverted)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/5d11bb2af5b411b85dd10e096051a869f1d18ea0ca64cb2e51a29a5b157acfbc.png" src="_images/5d11bb2af5b411b85dd10e096051a869f1d18ea0ca64cb2e51a29a5b157acfbc.png" />
<img alt="_images/c87e7465016620483664b59c708baa8f2f5dd206d77f0a07dc48adb69141031e.png" src="_images/c87e7465016620483664b59c708baa8f2f5dd206d77f0a07dc48adb69141031e.png" />
</div>
</div>
<p>This code performs the following steps:</p>
<ol class="arabic simple">
<li><p><strong>Importing Libraries</strong>: It imports the necessary libraries for working with images and visualization, namely <code class="docutils literal notranslate"><span class="pre">cv2</span></code> (OpenCV) for image processing, and <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> for plotting images.</p></li>
<li><p><strong>Preparation</strong>: It includes comments instructing you to load or obtain the actual image data and labels (names) that you want to process and visualize. You need to replace the placeholders <code class="docutils literal notranslate"><span class="pre">Images</span></code> and <code class="docutils literal notranslate"><span class="pre">Names</span></code> with your actual image data and labels.</p></li>
<li><p><strong>Font Definition</strong>: It defines a bold font (<code class="docutils literal notranslate"><span class="pre">font</span></code>) to be used for image titles.</p></li>
<li><p><strong>Image Plotting Function</strong>: It defines a function called <code class="docutils literal notranslate"><span class="pre">plot_images</span></code> that takes a list of images, their corresponding titles, and an overall title for the set of images. This function creates a row of subplots with the specified size and displays the images in grayscale format, turning off axis labels, and setting the titles using the specified font.</p></li>
<li><p><strong>RGB to Grayscale Conversion</strong>: It converts a list of RGB images (presumably stored in the <code class="docutils literal notranslate"><span class="pre">Images</span></code> variable) to grayscale format using the OpenCV function <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor</span></code> with the conversion code <code class="docutils literal notranslate"><span class="pre">cv2.COLOR_BGR2GRAY</span></code>. The resulting grayscale images are stored in the <code class="docutils literal notranslate"><span class="pre">gray_images</span></code> variable.</p></li>
<li><p><strong>Inverted Grayscale Images</strong>: It creates a list of inverted grayscale images by applying the <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code> operation to each image in the <code class="docutils literal notranslate"><span class="pre">gray_images</span></code> list. The resulting images are stored in the <code class="docutils literal notranslate"><span class="pre">inverted_gray_images</span></code> variable.</p></li>
<li><p><strong>Title Creation</strong>: It generates titles for the grayscale and inverted grayscale images. These titles are based on the original names from the <code class="docutils literal notranslate"><span class="pre">Names</span></code> variable but with added labels indicating the type of processing.</p></li>
<li><p><strong>Image Plotting</strong>: It calls the <code class="docutils literal notranslate"><span class="pre">plot_images</span></code> function twice: once to display the first two grayscale images with their titles, and once to display the first two inverted grayscale images with their titles. The overall titles for these sets of images are “RGB to Grayscale” and “RGB to Grayscale (Inverted)”, respectively.</p></li>
<li><p><strong>Display</strong>: Finally, the code uses <code class="docutils literal notranslate"><span class="pre">plt.show()</span></code> to display the plotted images with their titles.</p></li>
</ol>
</div>
<div class="section" id="rgb-to-hsv">
<h3><span class="section-number">1.6.2. </span>RGB to HSV<a class="headerlink" href="#rgb-to-hsv" title="Permalink to this headline">#</a></h3>
<p>Converting an image from the RGB (Red, Green, Blue) color space to the HSV (Hue, Saturation, Value) color space is a common operation in image processing. The HSV color space separates the color information into three components: hue (the color itself), saturation (the intensity of the color), and value (the brightness). Here’s how to perform the RGB to HSV conversion using OpenCV in Python:</p>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Convert Images from RGB to HSV color space</span>
<span class="n">augmented_images_hsv</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2HSV</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">Images</span><span class="p">]</span>

<span class="c1"># Display the augmented images in HSV color space</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">(</span><span class="n">augmented_images_hsv</span><span class="p">,</span> <span class="n">Names</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;RGB to HSV&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/fda9f7d1a90a4fd59e4a93119f55becdc15b0f954f447de7ed7be5efd4cb0a37.png" src="_images/fda9f7d1a90a4fd59e4a93119f55becdc15b0f954f447de7ed7be5efd4cb0a37.png" />
</div>
</div>
</div>
</div>
<div class="section" id="feature-detection">
<h2><span class="section-number">1.7. </span>Feature Detection<a class="headerlink" href="#feature-detection" title="Permalink to this headline">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.Canny</span></code> function <span id="id15">[<a class="reference internal" href="References.html#id140" title="John Canny. A computational approach to edge detection. IEEE Transactions on pattern analysis and machine intelligence, pages 679–698, 1986.">Canny, 1986</a>]</span> in OpenCV is used for edge detection in images. It identifies the edges in a given single-channel (grayscale) 8-bit input image and produces an output edge map of the same size and type as the input image. Here’s an explanation of the parameters and how the function works:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">image</span></code>: This is the input image on which edge detection is performed. It should be a single-channel 8-bit image, typically in grayscale.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edges</span></code>: This is the output edge map that will store the detected edges. It has the same size and type as the input image. The edges are represented as white lines on a black background.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">threshold1</span></code> and <code class="docutils literal notranslate"><span class="pre">threshold2</span></code>: These parameters specify the thresholds used in the hysteresis procedure, which is a critical part of the Canny edge detection algorithm. The algorithm works as follows:</p>
<ul>
<li><p>It first applies gradient operators (typically Sobel operators) to calculate the gradient magnitude and direction at each pixel.</p></li>
<li><p>Then, it marks pixels as potential edge points if their gradient magnitude is above <code class="docutils literal notranslate"><span class="pre">threshold1</span></code>.</p></li>
<li><p>Next, it traces along the potential edges and marks pixels as final edges if their gradient magnitude is above <code class="docutils literal notranslate"><span class="pre">threshold2</span></code> and is connected to a strong edge point.</p></li>
<li><p>The choice of <code class="docutils literal notranslate"><span class="pre">threshold1</span></code> and <code class="docutils literal notranslate"><span class="pre">threshold2</span></code> determines the sensitivity of edge detection. Smaller values will detect more edges, while larger values will detect fewer edges.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">apertureSize</span></code>: This parameter specifies the aperture size for the Sobel operator, which is used to compute the image gradient. It determines the size of the pixel neighborhood over which the gradient is calculated. The default value is typically 3, which corresponds to a 3x3 pixel neighborhood. You can adjust this value depending on the characteristics of your image and the desired level of detail in edge detection.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">L2gradient</span></code>: This is a boolean flag that determines whether a more accurate L2 norm or the default L1 norm should be used to calculate the image gradient magnitude. If <code class="docutils literal notranslate"><span class="pre">L2gradient</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, it calculates the gradient magnitude as <span class="math notranslate nohighlight">\(\sqrt{(dI/dx)^2 + (dI/dy)^2}\)</span>, which is the Euclidean distance in the gradient space. If <code class="docutils literal notranslate"><span class="pre">L2gradient</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, it uses the L1 norm, which is the sum of the absolute values of the gradients (<span class="math notranslate nohighlight">\(|dI/dx| + |dI/dy|\)</span>). Using the L2 norm can provide slightly more accurate results but is computationally more expensive.</p></li>
</ul>
<p><font color='Blue'><b>Example:</b></font></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a 2x2 grid of subplots for displaying images</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">9.5</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># Flatten the subplots for easier manipulation</span>

<span class="c1"># Loop to display original images and their edges</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">original_img</span> <span class="o">=</span> <span class="n">Images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">edge_img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Canny</span><span class="p">(</span><span class="n">original_img</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
    
    <span class="c1"># Display the original image in the left subplot</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">original_img</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Original Image - </span><span class="si">{</span><span class="n">Names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    
    <span class="c1"># Display the edge-detected image in the right subplot</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">edge_img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">))</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Image Edges - </span><span class="si">{</span><span class="n">Names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Set aspect ratio to 1 (square aspect)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>    <span class="c1"># Turn off axis</span>
    
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/0a3d354b0b457539878108cb60d55d7234d07dfdfc1f38d7cccbea4214bd4d4c.png" src="_images/0a3d354b0b457539878108cb60d55d7234d07dfdfc1f38d7cccbea4214bd4d4c.png" />
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="Getting_Started.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Getting Started with Python</p>
      </div>
    </a>
    <a class="right-next"
       href="CV_C2.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">2. </span>Geometric Transformations</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#sample-images">1.1. Sample Images</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#accessing-and-manipulating-pixel-values-in-images">1.2. Accessing and Manipulating Pixel Values in Images</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#adding-padding-exploring-border-types-in-opencv">1.3. Adding Padding: Exploring Border Types in OpenCV</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#image-blending-using-the-cv2-addweighted-function">1.4. Image Blending: Using the <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> Function</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bitwise-operations-in-opencv">1.5. Bitwise Operations in OpenCV</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bitwise-and-operation-with-cv2-bitwise-and">1.5.1. Bitwise AND Operation with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#element-wise-bitwise-not-with-cv2-bitwise-not">1.5.2. Element-Wise Bitwise NOT with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#element-wise-bitwise-or-with-cv2-bitwise-or">1.5.3. Element-Wise Bitwise OR with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#element-wise-bitwise-xor-with-cv2-bitwise-xor">1.5.4. Element-Wise Bitwise XOR with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#colorspace-conversion-with-cv2-cvtcolor">1.6. Colorspace Conversion with <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rgb-to-grayscale">1.6.1. RGB to Grayscale</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rgb-to-hsv">1.6.2. RGB to HSV</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#feature-detection">1.7. Feature Detection</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Hatef Dastour
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>