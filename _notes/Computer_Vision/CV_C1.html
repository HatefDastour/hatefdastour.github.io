

<!DOCTYPE html>


<html >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1. Getting Started with OpenCV &#8212; Computer Vision</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/myfile.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'CV_C1';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2. Geometric Transformations" href="CV_C2.html" />
    <link rel="prev" title="Getting Started with Python" href="Getting_Started.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="None"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="Getting_Started.html">
  
  
  
  
    
    
      
    
    
    <img src="_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="Getting_Started.html">
                    Getting Started with Python
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">1. Getting Started with OpenCV</a></li>
<li class="toctree-l1"><a class="reference internal" href="CV_C2.html">2. Geometric Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="CV_C3.html">3. Drawing Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="CV_C4.html">4. Image Thresholding</a></li>
<li class="toctree-l1"><a class="reference internal" href="CV_C5.html">5. Image Filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="CV_C6.html">6. Morphological Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="References.html">7. References</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://hatefdastour.github.io/notes/Computer_Vision/issues/new?title=Issue%20on%20page%20%2FCV_C1.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button"
   title="Open an issue"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/CV_C1.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Getting Started with OpenCV</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#sample-images">1.1. Sample Images</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#accessing-and-manipulating-pixel-values-in-images">1.2. Accessing and Manipulating Pixel Values in Images</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#adding-padding-exploring-border-types-in-opencv">1.3. Adding Padding: Exploring Border Types in OpenCV</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#image-blending-using-the-cv2-addweighted-function">1.4. Image Blending: Using the <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> Function</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bitwise-operations-in-opencv">1.5. Bitwise Operations in OpenCV</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bitwise-and-operation-with-cv2-bitwise-and">1.6. Bitwise AND Operation with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#element-wise-bitwise-not-with-cv2-bitwise-not">1.7. Element-Wise Bitwise NOT with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#element-wise-bitwise-or-with-cv2-bitwise-or">1.8. Element-Wise Bitwise OR with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#element-wise-bitwise-xor-with-cv2-bitwise-xor">1.9. Element-Wise Bitwise XOR with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#colorspace-conversion-with-cv2-cvtcolor">1.10. Colorspace Conversion with <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rgb-to-grayscale">1.10.1. RGB to Grayscale</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rgb-to-hsv">1.10.2. RGB to HSV</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <div class="tex2jax_ignore mathjax_ignore section" id="getting-started-with-opencv">
<h1><span class="section-number">1. </span>Getting Started with OpenCV<a class="headerlink" href="#getting-started-with-opencv" title="Permalink to this headline">#</a></h1>
<p>OpenCV (Open Source Computer Vision) is a widely acclaimed open-source library that forms the backbone of many computer vision applications. With a rich history dating back to its inception in 1999, OpenCV has evolved into a versatile toolkit that empowers developers to create innovative solutions in the field of image and video analysis. Released under a permissive BSD license, OpenCV has garnered a strong community of researchers, engineers, and enthusiasts who contribute to its growth and enhancement <span id="id1">[<a class="reference internal" href="References.html#id24" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id25" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p>CV2, often referred to as “opencv-python,” is the Python wrapper for the OpenCV library. This wrapper brings the power of OpenCV’s vast functionality to the Python programming ecosystem, making it accessible and convenient for Python developers. With CV2, you can perform a wide range of tasks, including image processing, feature extraction, object detection, video analysis, and more, using the intuitive and expressive syntax of Python.</p>
<p>CV2’s integration with Python has contributed to its popularity and ubiquity in the field of computer vision. It offers a comprehensive suite of functions and tools that enable users to manipulate, analyze, and interpret visual data effortlessly. From simple tasks like image resizing and filtering to complex tasks such as building deep learning models for image recognition, CV2 provides the necessary building blocks.</p>
<p>This tutorial serves as an introductory guide, delving into the fundamental operations of OpenCV. Our journey will be facilitated by the image dataset sourced from scikit-learn, a widely-used machine learning library.</p>
<div class="section" id="sample-images">
<h2><span class="section-number">1.1. </span>Sample Images<a class="headerlink" href="#sample-images" title="Permalink to this headline">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">sklearn.datasets.load_sample_images()</span></code> is a function provided by scikit-learn <span id="id2">[<a class="reference internal" href="References.html#id4" title="F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, P. Prettenhofer, R. Weiss, V. Dubourg, J. Vanderplas, A. Passos, D. Cournapeau, M. Brucher, M. Perrot, and E. Duchesnay. Scikit-learn: machine learning in Python. Journal of Machine Learning Research, 12:2825–2830, 2011.">Pedregosa <em>et al.</em>, 2011</a>]</span>, a popular machine learning library in Python. This function is used to load a collection of sample images, which can be useful for testing and experimenting with image-based machine learning algorithms and data analysis pipelines.</p>
<p>When you call <code class="docutils literal notranslate"><span class="pre">load_sample_images()</span></code>, it retrieves a predefined set of sample images that are bundled with the scikit-learn library. These images cover a range of subjects and formats, providing a diverse set of data for practicing and developing image processing, computer vision, and machine learning techniques.</p>
<p>The loaded images are usually provided as a dictionary-like object, containing the images themselves, information about the images, and sometimes additional metadata. This allows you to quickly access and work with the sample images for various tasks.
If you’re interested, you can access the detailed documentation for this image dataset <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_sample_images.html#sklearn.datasets.load_sample_images">here</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import necessary libraries</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  <span class="c1"># Import the plotting library</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.family&#39;</span> <span class="p">:</span> <span class="s1">&#39;Calibri&#39;</span><span class="p">,</span> <span class="s1">&#39;axes.titlesize&#39;</span> <span class="p">:</span> <span class="mi">16</span><span class="p">})</span>  <span class="c1"># Set font properties for plots</span>
<span class="kn">import</span> <span class="nn">cv2</span>  <span class="c1"># Import the OpenCV library</span>

<span class="c1"># Define a function to display images with titles and optional settings</span>
<span class="k">def</span> <span class="nf">ImShow</span><span class="p">(</span><span class="n">Images</span><span class="p">,</span> <span class="n">Names</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Images&#39;</span><span class="p">,</span> <span class="n">grayscale</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># Create a figure with two subplots</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>  <span class="c1"># Create a figure with 1 row and 2 columns of subplots</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># Flatten the subplots for easier manipulation</span>

    <span class="c1"># Iterate over the first two images</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">grayscale</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Images</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;gray&#39;</span><span class="p">)</span>  <span class="c1"># Display the image in grayscale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Images</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c1"># Display the image in color</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Set aspect ratio to 1 (square aspect)</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>  <span class="c1"># Turn off axis</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">Names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>  <span class="c1"># Set image title with bold font</span>

    <span class="k">if</span> <span class="n">title</span><span class="p">:</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>  <span class="c1"># Set main title if provided</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>  <span class="c1"># Adjust layout for better spacing</span>

    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>

<span class="c1"># Load sample images</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_sample_images</span>  <span class="c1"># Import a function to load sample images</span>
<span class="n">Images</span> <span class="o">=</span> <span class="n">load_sample_images</span><span class="p">()[</span><span class="s1">&#39;images&#39;</span><span class="p">]</span>  <span class="c1"># Load the sample images</span>
<span class="c1"># Extract image names from file paths, removing extension and converting to title case</span>
<span class="n">Names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.jpg&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">load_sample_images</span><span class="p">()[</span><span class="s1">&#39;filenames&#39;</span><span class="p">]]</span>

<span class="c1"># Display the original images</span>
<span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">(</span><span class="n">Images</span><span class="p">,</span> <span class="n">Names</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Original Images&#39;</span><span class="p">)</span>  <span class="c1"># Call the ImShow function to display images</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/24fd090ad60f9920df6a6eea84efd41a551ab00bada912389272485aff7ee509.png" src="_images/24fd090ad60f9920df6a6eea84efd41a551ab00bada912389272485aff7ee509.png" />
</div>
</div>
<p>This code snippet is a Python script that demonstrates how to use the scikit-learn library to load sample images, process the image names, and create a function for displaying the images with titles and optional settings using matplotlib.</p>
<p>Here’s a step-by-step explanation of the code:</p>
<ol class="arabic simple">
<li><p><strong>Import Libraries</strong>: The code starts by importing the necessary libraries and modules:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">load_sample_images</span></code> from <code class="docutils literal notranslate"><span class="pre">sklearn.datasets</span></code>: This function allows us to load a set of sample images provided by scikit-learn.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code> as <code class="docutils literal notranslate"><span class="pre">plt</span></code>: This module from Matplotlib is used for creating visualizations, including plotting images.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">matplotlib.font_manager.FontProperties</span></code>: This is used to customize font properties for titles.</p></li>
</ul>
</li>
<li><p><strong>Load Sample Images</strong>: The code calls <code class="docutils literal notranslate"><span class="pre">load_sample_images()</span></code> to load a set of sample images. These images are provided by scikit-learn for testing and demonstration purposes. The resulting <code class="docutils literal notranslate"><span class="pre">Images</span></code> variable holds the image data.</p></li>
<li><p><strong>Process Image Names</strong>: The code extracts the filenames of the loaded sample images, processes them to remove the file extension (<code class="docutils literal notranslate"><span class="pre">.jpg</span></code>), and converts them to title case. The resulting list of processed image names is stored in the <code class="docutils literal notranslate"><span class="pre">Names</span></code> variable.</p></li>
<li><p><strong>Display Function Definition</strong>: The code defines a function called <code class="docutils literal notranslate"><span class="pre">ImShow</span></code> that is used to display the images. This function takes several parameters, including the images to be displayed (<code class="docutils literal notranslate"><span class="pre">Images</span></code>), the processed image names (<code class="docutils literal notranslate"><span class="pre">Names</span></code>), an optional title for the entire figure (<code class="docutils literal notranslate"><span class="pre">Title</span></code>), and a flag to indicate whether the axis should be tight (<code class="docutils literal notranslate"><span class="pre">axis_tight</span></code>).</p></li>
<li><p><strong>Display Images</strong>: The function <code class="docutils literal notranslate"><span class="pre">ImShow</span></code> is called with the loaded images (<code class="docutils literal notranslate"><span class="pre">Images</span></code>), the processed image names (<code class="docutils literal notranslate"><span class="pre">Names</span></code>), and a title (“Original Images”). The purpose of this call is to display the first two images from the sample image dataset along with their titles. The function handles the arrangement, aspect ratio, and axis settings for the subplots.</p></li>
</ol>
</div>
<div class="section" id="accessing-and-manipulating-pixel-values-in-images">
<h2><span class="section-number">1.2. </span>Accessing and Manipulating Pixel Values in Images<a class="headerlink" href="#accessing-and-manipulating-pixel-values-in-images" title="Permalink to this headline">#</a></h2>
<p>To gain precise control over pixel values within an image, we leverage the versatile <code class="docutils literal notranslate"><span class="pre">split</span></code> function <span id="id3">[<a class="reference internal" href="References.html#id24" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id25" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>. This function proves invaluable in dissecting the intricate tapestry of color channels present within an image.</p>
<p>In the digital imaging realm, each channel corresponds to a distinct color component. In the ubiquitous RGB color model, we encounter the vibrant Red, Green, and Blue channels. Alternatively, the CMYK model introduces Cyan, Magenta, Yellow, and Black channels. These models, alongside others, collectively govern an image’s appearance through their distinctive channels.</p>
<p>With the adept application of the “split” function, we dissect an image into its elemental color constituents, effectively creating multiple images. Each of these resultant images uniquely embodies a specific color channel. This division grants us the remarkable capability to independently access and manipulate pixel values within each channel. Such autonomy equips us with a plethora of possibilities.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cv2</span>

<span class="c1"># Split the channels of the first image in the &#39;Images&#39; dataset</span>
<span class="n">B</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">Images</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>The following line of code utilizes the <code class="docutils literal notranslate"><span class="pre">cv2.split()</span></code> function to split the channels of the first image in the ‘Images’ dataset. This function separates the image into its individual color channels, where <code class="docutils literal notranslate"><span class="pre">B</span></code> corresponds to the Blue channel, <code class="docutils literal notranslate"><span class="pre">G</span></code> to the Green channel, and <code class="docutils literal notranslate"><span class="pre">R</span></code> to the Red channel. These channels represent the components that collectively create the image’s color when combined.</p>
<p>Alternatively, we can access the red, green, and blue channels of <code class="docutils literal notranslate"><span class="pre">Img</span></code> using the indexing syntax <code class="docutils literal notranslate"><span class="pre">Img[:,:,0]</span></code>, <code class="docutils literal notranslate"><span class="pre">Img[:,:,1]</span></code>, and <code class="docutils literal notranslate"><span class="pre">Img[:,:,2]</span></code>. This concise notation allows direct access to each color channel within the image, where the indices 0, 1, and 2 correspond to the red, green, and blue channels respectively. This indexing approach provides a convenient and efficient way to work with individual color channels, enabling focused manipulation and analysis of the image’s color components.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Create a figure with three subplots to display the color channels</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># Flatten the subplots for easier manipulation</span>

<span class="c1"># Set the main title to the name of the image</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">Names</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

<span class="c1"># Define the names of the color channels</span>
<span class="n">Channels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Red&#39;</span><span class="p">,</span> <span class="s1">&#39;Green&#39;</span><span class="p">,</span> <span class="s1">&#39;Blue&#39;</span><span class="p">]</span>

<span class="c1"># Iterate over the three color channels</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="c1"># Create an image with all zeros (black image) of the same size as the original image</span>
    <span class="n">img</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">Images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Assign the values of the current color channel to the corresponding channel in the black image</span>
    <span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Images</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span>
    <span class="c1"># Display the image for the current color channel in the subplot</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="c1"># Set aspect ratio to 1 to avoid stretching</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Turn off axis for cleaner visualization</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="c1"># Add text label indicating the color channel</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">Channels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span>
                   <span class="n">color</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s2">&quot;square&quot;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;Navy&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;LightSkyBlue&#39;</span><span class="p">))</span>
<span class="c1"># Display the plot</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ba4aeb3a4d0c55c92603d2ba1b874dea5b638e4c7ec55b39856a677d5a2d6e1b.png" src="_images/ba4aeb3a4d0c55c92603d2ba1b874dea5b638e4c7ec55b39856a677d5a2d6e1b.png" />
</div>
</div>
<p>This code demonstrates how to visualize the individual color channels (Red, Green, and Blue) of an image using Matplotlib. Let’s break down the code step by step:</p>
<ol class="arabic simple">
<li><p><strong>Import Matplotlib</strong>: Import the <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code> module for creating visualizations, and the <code class="docutils literal notranslate"><span class="pre">FontProperties</span></code> class from <code class="docutils literal notranslate"><span class="pre">matplotlib.font_manager</span></code> for customizing font properties.</p></li>
<li><p><strong>Create Subplots</strong>: Create a figure with one row and three columns of subplots (1x3 arrangement) to display the color channels. The <code class="docutils literal notranslate"><span class="pre">figsize</span></code> parameter sets the size of the figure. The subplots are flattened into a 1D array <code class="docutils literal notranslate"><span class="pre">ax</span></code> for easier manipulation.</p></li>
<li><p><strong>Set Title Font Properties</strong>: Create a <code class="docutils literal notranslate"><span class="pre">FontProperties</span></code> object and set it to bold. This font will be used for the main title of the figure.</p></li>
<li><p><strong>Set Main Title</strong>: Set the main title of the figure to the name of the image using <code class="docutils literal notranslate"><span class="pre">fig.suptitle()</span></code>. The title uses the bold font properties defined earlier and a font size of 18.</p></li>
<li><p><strong>Define Channel Names</strong>: Create a list called <code class="docutils literal notranslate"><span class="pre">Channels</span></code> that contains the names of the color channels: ‘Red’, ‘Green’, and ‘Blue’.</p></li>
<li><p><strong>Iterate Over Channels</strong>: Loop through the range (0 to 2) representing the three color channels. For each channel:</p>
<ul class="simple">
<li><p>Create a new image (<code class="docutils literal notranslate"><span class="pre">img</span></code>) filled with zeros (black image) of the same size as the original image.</p></li>
<li><p>Assign the values of the current color channel from the original image to the corresponding channel in the black image (<code class="docutils literal notranslate"><span class="pre">img</span></code>).</p></li>
<li><p>Display the image for the current color channel in the subplot at the appropriate position (<code class="docutils literal notranslate"><span class="pre">ax[i]</span></code>).</p></li>
<li><p>Set the aspect ratio of the subplot to 1 to avoid stretching.</p></li>
<li><p>Turn off the axis to clean up the visualization.</p></li>
<li><p>Add a text label indicating the color channel (e.g., ‘Red’, ‘Green’, ‘Blue’) in a colored box (<code class="docutils literal notranslate"><span class="pre">bbox</span></code>) at the position (x=0, y=0) in the subplot. The label is styled with a size of 14, navy color, and a light sky blue background color.</p></li>
</ul>
</li>
</ol>
</div>
<div class="section" id="adding-padding-exploring-border-types-in-opencv">
<h2><span class="section-number">1.3. </span>Adding Padding: Exploring Border Types in OpenCV<a class="headerlink" href="#adding-padding-exploring-border-types-in-opencv" title="Permalink to this headline">#</a></h2>
<p>In image processing, padding or adding borders to an image is a common operation, often used in tasks like convolution or resizing. OpenCV provides several border types, each with its own unique behavior <span id="id4">[<a class="reference internal" href="References.html#id24" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id25" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>. The <code class="docutils literal notranslate"><span class="pre">cv2.copyMakeBorder</span></code> function in OpenCV is used to create a new image (destination, <code class="docutils literal notranslate"><span class="pre">dst</span></code>) by adding a border around the original image (source, <code class="docutils literal notranslate"><span class="pre">src</span></code>). The border is created based on the specified parameters, such as the offset, border type, and value of the border pixels. Here’s an explanation of the function signature:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>cv2.copyMakeBorder(src, dst, offset, bordertype, value=(0, 0, 0, 0)) → None
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src</span></code>: The source image, which is the input image to which the border will be added.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The destination image, where the result (image with border) will be stored. It should have the size of the output image, which can be calculated based on the input image and the specified offset.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">offset</span></code>: A tuple <code class="docutils literal notranslate"><span class="pre">(top,</span> <span class="pre">bottom,</span> <span class="pre">left,</span> <span class="pre">right)</span></code> that specifies the number of pixels for each side (top, bottom, left, right) by which the image will be extended with the border.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bordertype</span></code>: The type of border to be added, specified as an integer constant. Common border types include <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_CONSTANT</span></code>, <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REPLICATE</span></code>, <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REFLECT</span></code>, and others.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value of the border pixels. This parameter is optional and is only used when the <code class="docutils literal notranslate"><span class="pre">bordertype</span></code> is set to <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_CONSTANT</span></code>. The default value is <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0)</span></code>, which corresponds to black in grayscale images.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.copyMakeBorder</span></code> function modifies the <code class="docutils literal notranslate"><span class="pre">dst</span></code> image by adding a border around the <code class="docutils literal notranslate"><span class="pre">src</span></code> image based on the specified offset and border type. The resulting image in <code class="docutils literal notranslate"><span class="pre">dst</span></code> will have a larger size than the original image, with the specified border.</p>
<p>It’s important to note that the <code class="docutils literal notranslate"><span class="pre">dst</span></code> image should be pre-allocated to accommodate the new size, and the dimensions of the <code class="docutils literal notranslate"><span class="pre">dst</span></code> image can be calculated based on the dimensions of the <code class="docutils literal notranslate"><span class="pre">src</span></code> image and the specified offset.</p>
<p>Let’s delve into these border types:</p>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_CONSTANT</span></code></strong>: This option introduces a border with a consistent color, effectively extending the image’s dimensions. The border’s color remains the same throughout, making it suitable for scenarios where a constant background is desired.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REFLECT</span></code></strong>: When using this option, the border is generated by reflecting the elements along the boundary. This results in a pattern that resembles a mirror reflection, such as “fedcba|abcdefgh|hgfedcb”. It provides a smooth and continuous appearance at the border.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REFLECT_101</span></code> (or <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_DEFAULT</span></code>)</strong>: Similar to <code class="docutils literal notranslate"><span class="pre">BORDER_REFLECT</span></code>, this option creates a border with mirrored reflection. However, the pattern differs slightly, appearing as “gfedcb|abcdefgh|gfedcba”. This border type is popular for tasks that require symmetry preservation.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REPLICATE</span></code></strong>: This option duplicates the last element of each row or column to form the border. The resulting pattern looks like “aaaaaa|abcdefgh|hhhhhhh”, effectively maintaining the edge consistency.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_WRAP</span></code></strong>: Utilizing this option, the image wraps around to form a circular-like pattern in the border. The pattern could be described as “cdefgh|abcdefgh|abcdefg”. This border type is particularly useful for applications dealing with cyclic or periodic data.</p></li>
</ul>
<p>For an in-depth understanding of these border types, along with practical code examples and usage scenarios, it’s highly recommended to refer to the official OpenCV documentation available <a class="reference external" href="https://docs.opencv.org/3.4/dc/da3/tutorial_copyMakeBorder.html">here</a>. This documentation provides detailed insights and examples, enabling you to leverage these border types effectively in various image processing tasks <span id="id5">[<a class="reference internal" href="References.html#id24" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id25" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Mapping of OpenCV border types to their descriptive names</span>
<span class="n">cv2_border_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_CONSTANT</span><span class="p">:</span> <span class="s1">&#39;BORDER_CONSTANT&#39;</span><span class="p">,</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REPLICATE</span><span class="p">:</span> <span class="s1">&#39;BORDER_REPLICATE&#39;</span><span class="p">,</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REFLECT</span><span class="p">:</span> <span class="s1">&#39;BORDER_REFLECT&#39;</span><span class="p">,</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_WRAP</span><span class="p">:</span> <span class="s1">&#39;BORDER_WRAP&#39;</span><span class="p">,</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REFLECT_101</span><span class="p">:</span> <span class="s1">&#39;BORDER_REFLECT_101&#39;</span>
<span class="p">}</span>

<span class="c1"># RGB Colors for the border</span>
<span class="n">RGB</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">RGB</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">255</span>

<span class="c1"># Create a 2x3 grid of subplots to display images</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="n">fig</span><span class="o">.</span><span class="n">delaxes</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Remove the last subplot (blank)</span>

<span class="c1"># Set the title for the overall figure</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Border Types Applied&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

<span class="c1"># Iterate over the different border types and apply them to the image</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">border_type</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cv2_border_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
    <span class="c1"># Apply the specified border to the image (Images[1]) with padding values</span>
    <span class="n">img_with_border</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">copyMakeBorder</span><span class="p">(</span><span class="n">Images</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="n">border_type</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">RGB</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="c1"># Display the image with the applied border on the current subplot</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img_with_border</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    
<span class="c1"># Display the plot</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/cd9702d4d389048dfde8e923dc07683b80e717b823c75e78c95e934eabb3dcac.png" src="_images/cd9702d4d389048dfde8e923dc07683b80e717b823c75e78c95e934eabb3dcac.png" />
</div>
</div>
<p>This code demonstrates the application of different border types to an image using the OpenCV library and visualizes the results using Matplotlib subplots. Let’s break down the code step by step:</p>
<ol class="arabic simple">
<li><p><strong>Importing Libraries</strong>: The code imports necessary libraries: OpenCV (cv2) for image processing, Matplotlib for visualization, and FontProperties from Matplotlib for managing font properties.</p></li>
<li><p><strong>Creating a Dictionary for Border Types</strong>: A dictionary named <code class="docutils literal notranslate"><span class="pre">cv2_border_dict</span></code> is created to map OpenCV border type constants to their descriptive names. This mapping helps in making the code more readable and provides a clear reference for the border types being applied.</p></li>
<li><p><strong>Defining RGB Colors</strong>: An RGB color list named <code class="docutils literal notranslate"><span class="pre">RGB</span></code> is created to define the border color. Each element in the list corresponds to an RGB value. Here, we create a list with three elements, each representing a different primary color (R, G, B). In this case, we create a list of three colors: [255, 0, 0] (Red), [0, 255, 0] (Green), and [0, 0, 255] (Blue).</p></li>
<li><p><strong>Creating Subplots</strong>: The code creates a 2x3 grid of subplots using Matplotlib’s <code class="docutils literal notranslate"><span class="pre">subplots</span></code> function. The <code class="docutils literal notranslate"><span class="pre">ax</span></code> variable is flattened into a one-dimensional array for easier manipulation. The last subplot (bottom right) is removed using <code class="docutils literal notranslate"><span class="pre">fig.delaxes</span></code> to ensure a clean layout.</p></li>
<li><p><strong>Setting the Figure Title</strong>: A main title for the entire figure is set using <code class="docutils literal notranslate"><span class="pre">fig.suptitle</span></code>. The title is set to ‘Border Types Applied’, and the font properties and fontsize are specified.</p></li>
<li><p><strong>Applying Border Types</strong>: The code iterates over the different border types in the <code class="docutils literal notranslate"><span class="pre">cv2_border_dict</span></code> dictionary using a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop. For each border type, the <code class="docutils literal notranslate"><span class="pre">cv2.copyMakeBorder</span></code> function is used to apply the specified border type to the second image (Images[1]) with padding values (15 pixels on each side). The resulting image with the applied border is stored in the <code class="docutils literal notranslate"><span class="pre">img_with_border</span></code> variable.</p></li>
<li><p><strong>Displaying Images with Borders</strong>: The images with the applied borders are displayed on the subplots. For each subplot, the <code class="docutils literal notranslate"><span class="pre">imshow</span></code> function is used to display the image, and additional settings such as aspect ratio, axis off, and subplot title are applied for better visualization.</p></li>
</ol>
<p>The final output is a grid of subplots, each showing the image with a different border type applied, and the corresponding border type name as the subplot title. This code provides a clear visual representation of the effects of various border types on an image.</p>
</div>
<div class="section" id="image-blending-using-the-cv2-addweighted-function">
<h2><span class="section-number">1.4. </span>Image Blending: Using the <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> Function<a class="headerlink" href="#image-blending-using-the-cv2-addweighted-function" title="Permalink to this headline">#</a></h2>
<p>Image blending is a fundamental technique in image processing that combines two images to create a new composite image. OpenCV provides the <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> function, which performs image blending based on a weighted sum of the input images and an additional constant value. Here’s an explanation of the blending formula and how it works
<span id="id6">[<a class="reference internal" href="References.html#id24" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id25" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>:</p>
<p>The formula for image blending using <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> is as follows:</p>
<div class="amsmath math notranslate nohighlight" id="equation-d1f50f19-b41f-4e23-9d16-c06df7234d67">
<span class="eqno">(1.1)<a class="headerlink" href="#equation-d1f50f19-b41f-4e23-9d16-c06df7234d67" title="Permalink to this equation">#</a></span>\[\begin{equation}
\text{Output Image} = \alpha \cdot \text{Image1} + (1 - \alpha) \cdot \text{Image2} + \gamma
\end{equation}\]</div>
<p>In this formula:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Image1</span></code> and <code class="docutils literal notranslate"><span class="pre">Image2</span></code> are the two input images to be blended.</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha\)</span> is a weighting factor that determines the influence of <code class="docutils literal notranslate"><span class="pre">Image1</span></code> in the final output. It satisfies the condition <span class="math notranslate nohighlight">\(0 \leq \alpha \leq 1\)</span>, meaning it controls the relative contribution of <code class="docutils literal notranslate"><span class="pre">Image1</span></code> to the blended image.</p></li>
<li><p><span class="math notranslate nohighlight">\((1 - \alpha)\)</span> represents the weighting factor for <code class="docutils literal notranslate"><span class="pre">Image2</span></code>, ensuring that the sum of the weights for both images is 1.</p></li>
<li><p><span class="math notranslate nohighlight">\(\gamma\)</span> is an additional constant value that can be added to the blended result. It is an integer value that can be used for brightness adjustment.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> function in OpenCV is used for image blending, which combines two input images (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>) together using a specified weight for each image. The resulting blended image is stored in the destination image (<code class="docutils literal notranslate"><span class="pre">dst</span></code>). Here’s an explanation of the function signature:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>cv2.addWeighted(src1, alpha, src2, beta, gamma, dst) → None
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src1</span></code>: The first source image, which is the primary input image for blending.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alpha</span></code>: The weight applied to the first source image (<code class="docutils literal notranslate"><span class="pre">src1</span></code>). This value determines the contribution of <code class="docutils literal notranslate"><span class="pre">src1</span></code> to the final result. A larger <code class="docutils literal notranslate"><span class="pre">alpha</span></code> value increases the influence of <code class="docutils literal notranslate"><span class="pre">src1</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">src2</span></code>: The second source image, which is the secondary input image for blending.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">beta</span></code>: The weight applied to the second source image (<code class="docutils literal notranslate"><span class="pre">src2</span></code>). This value determines the contribution of <code class="docutils literal notranslate"><span class="pre">src2</span></code> to the final result. A larger <code class="docutils literal notranslate"><span class="pre">beta</span></code> value increases the influence of <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gamma</span></code>: A scalar added to the weighted sum of the two source images. This value can be used to control the brightness or contrast of the resulting image.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The destination image, where the blended image is stored. The dimensions of this image should match the dimensions of the input images.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> function performs a linear combination of the two source images (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>) based on the specified weights <code class="docutils literal notranslate"><span class="pre">alpha</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code>, and then adds the scalar <code class="docutils literal notranslate"><span class="pre">gamma</span></code> to the resulting sum. The resulting blended image is written to the <code class="docutils literal notranslate"><span class="pre">dst</span></code> image <span id="id7">[<a class="reference internal" href="References.html#id24" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id25" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p>This function is commonly used for image fusion, creating special effects, adjusting image brightness and contrast, and other image processing tasks where combining two images with different weights is required. The <code class="docutils literal notranslate"><span class="pre">alpha</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code> values control the influence of each source image, and the <code class="docutils literal notranslate"><span class="pre">gamma</span></code> value can be used to control the overall brightness or contrast of the final image.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import necessary libraries</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>  <span class="c1"># Import numpy for array operations</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  <span class="c1"># Import matplotlib for visualization</span>
<span class="kn">import</span> <span class="nn">cv2</span>  <span class="c1"># Import OpenCV for image processing</span>

<span class="c1"># Create a copy of the Images dataset for augmentation</span>
<span class="n">augmented_images</span> <span class="o">=</span> <span class="n">Images</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="c1"># Method 1: Using cv2.addWeighted for Image Blending</span>
<span class="c1"># Blend the first two images in the &#39;Images&#39; array using a weighted sum</span>
<span class="c1"># The first image (Images[0]) is multiplied by 0.7, and the second image (Images[1]) is multiplied by 0.3</span>
<span class="c1"># The last parameter (0) specifies the scalar value added to the resulting image</span>
<span class="n">augmented_images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">addWeighted</span><span class="p">(</span><span class="n">Images</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.7</span><span class="p">,</span> <span class="n">Images</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># Method 2: Custom Image Blending</span>
<span class="c1"># Blend the first two images in the &#39;Images&#39; array using a custom weighted sum</span>
<span class="c1"># We use numpy for element-wise multiplication and addition, round the result, and convert to &#39;uint8&#39; data type</span>
<span class="c1"># This technique allows us to manually control the blending weights</span>
<span class="n">augmented_images</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="mf">0.7</span> <span class="o">*</span> <span class="n">Images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">Images</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>

<span class="c1"># Create a 1x2 grid of subplots for displaying the augmented images</span>
<span class="c1"># Set font properties and title size for the plot</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.family&#39;</span><span class="p">:</span> <span class="s1">&#39;Calibri&#39;</span><span class="p">,</span> <span class="s1">&#39;axes.titlesize&#39;</span><span class="p">:</span> <span class="mi">14</span><span class="p">})</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>  <span class="c1"># Create a figure with 1 row and 2 columns of subplots</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># Flatten the subplots for easy indexing</span>

<span class="c1"># Set the main title for the entire figure</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Image Blending&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># Iterate over the two augmented images</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">title</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;cv2.addWeighted&#39;</span><span class="p">,</span> <span class="s1">&#39;Custom Blend&#39;</span><span class="p">]):</span>
    <span class="c1"># Display the augmented image in the subplot</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">augmented_images</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c1"># Show the image in the current subplot</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Set the aspect ratio of the image</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>  <span class="c1"># Turn off axis labels and ticks for better visualization</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>  <span class="c1"># Set the title for the current subplot</span>
    
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>  <span class="c1"># Adjust layout to avoid overlapping</span>
<span class="c1"># Display the plot</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/b254331e88171403ede8b3c7688bcac143c1d8719e9d1d61cc9d53f1d222ff60.png" src="_images/b254331e88171403ede8b3c7688bcac143c1d8719e9d1d61cc9d53f1d222ff60.png" />
</div>
</div>
<p>This code demonstrates image blending using two different methods, and it showcases the results in a side-by-side comparison using subplots. Here’s a step-by-step explanation:</p>
<ol class="arabic simple">
<li><p>The code imports necessary libraries:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span></code> as <code class="docutils literal notranslate"><span class="pre">np</span></code>: A library for numerical computations in Python.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code> as <code class="docutils literal notranslate"><span class="pre">plt</span></code>: A library for creating visualizations in Python.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FontProperties</span></code> from <code class="docutils literal notranslate"><span class="pre">matplotlib.font_manager</span></code>: This allows us to customize font properties for the plot.</p></li>
</ul>
</li>
<li><p>A copy of the <code class="docutils literal notranslate"><span class="pre">Images</span></code> dataset is created for augmentation. This ensures that the original dataset remains unchanged during the blending process.</p></li>
<li><p>Method 1: Using <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> for Image Blending.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> is a function from OpenCV that blends two images based on specified weights and adds them together.</p></li>
<li><p>The first image from the <code class="docutils literal notranslate"><span class="pre">Images</span></code> dataset (<code class="docutils literal notranslate"><span class="pre">Images[0]</span></code>) is blended with the second image (<code class="docutils literal notranslate"><span class="pre">Images[1]</span></code>) using a weight of 0.7 for the first image and 0.3 for the second image. The third argument is a gamma value (0 in this case).</p></li>
<li><p>The result is stored in <code class="docutils literal notranslate"><span class="pre">augmented_images[0]</span></code>.</p></li>
</ul>
</li>
<li><p>Method 2: Custom Image Blending.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span></code> is used for element-wise multiplication and addition, followed by rounding the result to the nearest integer and converting it to ‘uint8’ data type.</p></li>
<li><p>The formula <code class="docutils literal notranslate"><span class="pre">(0.7</span> <span class="pre">*</span> <span class="pre">Images[0]</span> <span class="pre">+</span> <span class="pre">0.3</span> <span class="pre">*</span> <span class="pre">Images[1])</span></code> blends the two images with the specified weights.</p></li>
<li><p>The result is stored in <code class="docutils literal notranslate"><span class="pre">augmented_images[1]</span></code>.</p></li>
</ul>
</li>
<li><p>A 1x2 grid of subplots is created using <code class="docutils literal notranslate"><span class="pre">plt.subplots</span></code>. This is done to display the original image and the blended images side by side.</p></li>
<li><p>The title for the entire figure is set to ‘Image Blending’.</p></li>
<li><p>The code iterates over the two augmented images:</p>
<ul class="simple">
<li><p>For each image, it displays the image in the corresponding subplot (<code class="docutils literal notranslate"><span class="pre">ax[i]</span></code>).</p></li>
<li><p>Aspect ratio is set to 1 to avoid stretching.</p></li>
<li><p>Axes are turned off for cleaner visualization.</p></li>
<li><p>The title for each subplot is set based on the blending method used (<code class="docutils literal notranslate"><span class="pre">'cv2.addWeighted'</span></code> for the first image, and <code class="docutils literal notranslate"><span class="pre">'Custom</span> <span class="pre">Blend'</span></code> for the second image).</p></li>
</ul>
</li>
</ol>
<p>The result is a visualization that shows the original image and the outcomes of the two blending methods, making it easy to compare the effects of the different blending techniques.</p>
</div>
<div class="section" id="bitwise-operations-in-opencv">
<h2><span class="section-number">1.5. </span>Bitwise Operations in OpenCV<a class="headerlink" href="#bitwise-operations-in-opencv" title="Permalink to this headline">#</a></h2>
<p>Bitwise operations are fundamental operations in computer programming and image processing that manipulate individual bits within binary representations of data. These operations involve performing logical and mathematical operations at the bit level, which can be particularly useful in tasks such as image manipulation, data compression, encryption, and hardware-level operations. You can perform bitwise operations on integers and use these operations for image processing with libraries like OpenCV. Here’s a brief overview of how bitwise operations work in Python:</p>
<div class="figure align-left" id="id15">
<a class="reference internal image-reference" href="_images/bitwise_op.png"><img alt="_images/bitwise_op.png" src="_images/bitwise_op.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 1.1 </span><span class="caption-text">Examples of Bitwise Operations.</span><a class="headerlink" href="#id15" title="Permalink to this image">#</a></p>
</div>
<ol class="arabic simple">
<li><p><strong>Bitwise AND (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) and OR (<code class="docutils literal notranslate"><span class="pre">|</span></code>)</strong>:
You can use the <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> operator for bitwise AND and the <code class="docutils literal notranslate"><span class="pre">|</span></code> operator for bitwise OR. These operators compare corresponding bits of two integers and produce a new integer where each bit is the result of the corresponding bitwise operation.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Given integers</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">28</span>

<span class="c1"># Print the binary representation of a and b</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Binary for </span><span class="si">%i</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Binary for </span><span class="si">%i</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>

<span class="c1"># Bitwise AND operation</span>
<span class="n">result_and</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span>  <span class="c1"># Bitwise AND: 0001 (1 in decimal)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a &amp; b = </span><span class="si">%i</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result_and</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">result_and</span><span class="p">)))</span>

<span class="c1"># Bitwise OR operation</span>
<span class="n">result_or</span> <span class="o">=</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span>   <span class="c1"># Bitwise OR: 0111 (7 in decimal)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a | b = </span><span class="si">%i</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result_or</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">result_or</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Binary for 21 = 0b10101
Binary for 28 = 0b11100
a &amp; b = 20 (0b10100)
a | b = 29 (0b11101)
</pre></div>
</div>
</div>
</div>
<div class="important admonition">
<p class="admonition-title">Remark</p>
<p>To convert a number to its binary representation in Python, you can use the <code class="docutils literal notranslate"><span class="pre">bin()</span></code> function. This function takes an integer as input and returns a string that represents the binary value of that integer, with the “0b” prefix <span id="id8">[<a class="reference internal" href="References.html#id5" title="Python Software Foundation. Python 3.11.4 documentation. https://docs.python.org/, 2023. [Online; accessed 01-August-2023].">Python Software Foundation, 2023</a>]</span>.</p>
<p>Here’s an example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">number</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">binary_value</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">binary_value</span><span class="p">)</span>  <span class="c1"># Output: &#39;0b101010&#39;</span>
</pre></div>
</div>
<p>If you want to remove the “0b” prefix and get the binary representation as a plain string, you can use string slicing:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">number</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">binary_string</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">number</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">binary_string</span><span class="p">)</span>  <span class="c1"># Output: &#39;101010&#39;</span>
</pre></div>
</div>
<p>If you need to pad the binary representation with leading zeros to a certain length (e.g., 8 bits), you can use the <code class="docutils literal notranslate"><span class="pre">format()</span></code> function with the <code class="docutils literal notranslate"><span class="pre">'b'</span></code> format specifier:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">number</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">binary_padded</span> <span class="o">=</span> <span class="nb">format</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="s1">&#39;08b&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">binary_padded</span><span class="p">)</span>  <span class="c1"># Output: &#39;00101010&#39;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">'08b'</span></code> format specifier means:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'0'</span></code>: The character used for padding (leading zeros).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'8'</span></code>: The width of the output string (total length).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'b'</span></code>: Indicates binary representation.</p></li>
</ul>
<p>Futhermore, you can convert a binary string to an integer using the <code class="docutils literal notranslate"><span class="pre">int()</span></code> function with the base set to 2. Here’s an example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">binary_string</span> <span class="o">=</span> <span class="s2">&quot;1101&quot;</span>
<span class="n">integer_value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">binary_string</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Binary:&quot;</span><span class="p">,</span> <span class="n">binary_string</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Integer:&quot;</span><span class="p">,</span> <span class="n">integer_value</span><span class="p">)</span>
</pre></div>
</div>
<p>This code converts the binary string “1101” to the corresponding integer value, which is 13 in decimal representation. The <code class="docutils literal notranslate"><span class="pre">int()</span></code> function takes two arguments: the first argument is the string containing the binary representation, and the second argument specifies the base, which is 2 for binary. The resulting integer value is then printed.</p>
</div>
<ol class="arabic simple" start="2">
<li><p><strong>Bitwise XOR (<code class="docutils literal notranslate"><span class="pre">^</span></code>) and NOT (<code class="docutils literal notranslate"><span class="pre">~</span></code>)</strong>:
The <code class="docutils literal notranslate"><span class="pre">^</span></code> operator is used for bitwise XOR, which compares corresponding bits and produces a new integer with the XOR result. The <code class="docutils literal notranslate"><span class="pre">~</span></code> operator is used for bitwise NOT, which inverts all bits of an integer.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Given integers</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">28</span>

<span class="c1"># Print the binary representation of a and b</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Binary for </span><span class="si">%i</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Binary for </span><span class="si">%i</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>

<span class="c1"># Bitwise XOR operation</span>
<span class="n">result_xor</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a ^ b = </span><span class="si">%i</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result_xor</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">result_xor</span><span class="p">)))</span>

<span class="c1"># Bitwise NOT operation</span>
<span class="n">result_not</span> <span class="o">=</span> <span class="o">~</span><span class="n">a</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;~a  = </span><span class="si">%i</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result_not</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="n">result_not</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Binary for 21 = 0b10101
Binary for 28 = 0b11100
a ^ b = 9 (0b1001)
~a  = -22 (-0b10110)
</pre></div>
</div>
</div>
</div>
<div class="important admonition">
<p class="admonition-title">Remark</p>
<p>When you use the <code class="docutils literal notranslate"><span class="pre">bin()</span></code> function in Python, it returns a string that includes a negative sign (<code class="docutils literal notranslate"><span class="pre">-</span></code>) and the binary representation. This is consistent with the two’s complement representation used for signed integers.</p>
<p>Let’s break down the example to clarify:</p>
<ol class="arabic">
<li><p>Given: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">21</span></code>. The binary representation of <code class="docutils literal notranslate"><span class="pre">21</span></code> is <code class="docutils literal notranslate"><span class="pre">10101</span></code> (5 bits, assuming 32-bit representation).</p></li>
<li><p>Applying the bitwise NOT (<code class="docutils literal notranslate"><span class="pre">~</span></code>) operation to <code class="docutils literal notranslate"><span class="pre">21</span></code> inverts each bit: <code class="docutils literal notranslate"><span class="pre">01010</span></code>.</p></li>
<li><p>Now, let’s interpret this result as a signed integer:</p>
<ul class="simple">
<li><p>In binary, <code class="docutils literal notranslate"><span class="pre">01010</span></code> is the binary representation of the decimal value <code class="docutils literal notranslate"><span class="pre">10</span></code>. This is the positive interpretation.</p></li>
<li><p>However, in signed two’s complement representation, to get the negative value, you first invert all the bits and then add 1.</p></li>
</ul>
<p>Inverting <code class="docutils literal notranslate"><span class="pre">01010</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">10101</span>
</pre></div>
</div>
<p>Adding 1 to the inverted value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">10110</span>
</pre></div>
</div>
</li>
<li><p>The result is <code class="docutils literal notranslate"><span class="pre">-10110</span></code>. When you use the <code class="docutils literal notranslate"><span class="pre">bin()</span></code> function to convert this to a binary string, Python includes the negative sign (<code class="docutils literal notranslate"><span class="pre">-</span></code>) and the binary representation, resulting in <code class="docutils literal notranslate"><span class="pre">-0b10110</span></code>.</p></li>
</ol>
<p>So, it’s important to understand that the <code class="docutils literal notranslate"><span class="pre">~</span></code> operator does perform bitwise inversion, but when the result is interpreted as a signed integer (in two’s complement representation), the negative sign is included in the binary string representation. This is why you see <code class="docutils literal notranslate"><span class="pre">-0b10110</span></code> as the output when <code class="docutils literal notranslate"><span class="pre">~a</span></code> is <code class="docutils literal notranslate"><span class="pre">-22</span></code>.</p>
</div>
<p>These bitwise operations are fundamental building blocks in binary image manipulation and can be applied to individual pixel values when working with image data. When working with images in OpenCV, you can use these operations to perform tasks such as masking, image blending, and more by applying them to the pixel values of the images.</p>
<p>These operations are particularly efficient and are often used in low-level programming, such as optimizing memory usage, performing pixel-level operations in image processing, and implementing various data manipulation algorithms.</p>
<p>In image processing, bitwise operations can be used for tasks such as creating masks, extracting specific color channels, setting or clearing specific bits, and combining images using logical conditions. In hardware design, bitwise operations are essential for controlling individual bits in registers and memory-mapped devices.</p>
<p>OpenCV provides several essential bitwise operations for manipulating individual bits within arrays. These operations offer the ability to perform logical operations at the bit level, making them useful for various image processing tasks that involve binary data. Here’s an explanation of each bitwise operation along with links to their documentation <span id="id9">[<a class="reference internal" href="References.html#id24" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id25" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>:</p>
</div>
<div class="section" id="bitwise-and-operation-with-cv2-bitwise-and">
<h2><span class="section-number">1.6. </span>Bitwise AND Operation with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code><a class="headerlink" href="#bitwise-and-operation-with-cv2-bitwise-and" title="Permalink to this headline">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code> function in OpenCV is a versatile tool for performing element-wise bitwise conjunction (logical AND) operations between arrays. This function allows you to apply the AND operation between corresponding elements of two input arrays or an array and a scalar. The resulting array, <code class="docutils literal notranslate"><span class="pre">dst</span></code>, has the same size and data type as the input arrays, making it useful for a variety of image processing tasks <span id="id10">[<a class="reference internal" href="References.html#id24" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id25" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p><strong>Key Concepts:</strong></p>
<ol class="arabic">
<li><p><strong>Operation on Two Arrays (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code> with the same size):</strong></p>
<ul>
<li><p>When both input arrays (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>) have the same size, the function computes the logical AND operation between corresponding elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1(I) AND src2(I) if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>The operation is performed element-wise. Each element in the resulting array <code class="docutils literal notranslate"><span class="pre">dst</span></code> is the result of the logical AND operation between the corresponding elements in <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
<li><p>The optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> parameter allows you to selectively apply the operation based on the mask values. If <code class="docutils literal notranslate"><span class="pre">mask(I)</span></code> is non-zero, the operation is applied; otherwise, the corresponding element in <code class="docutils literal notranslate"><span class="pre">dst</span></code> remains unchanged.</p></li>
</ul>
</li>
<li><p><strong>Operation on an Array and a Scalar (<code class="docutils literal notranslate"><span class="pre">src2</span></code> as a scalar):</strong></p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">src2</span></code> is a scalar (a single value), the function computes the bitwise AND operation between each element of <code class="docutils literal notranslate"><span class="pre">src1</span></code> and the scalar value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1(I) AND src2 if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>If the number of elements in <code class="docutils literal notranslate"><span class="pre">src1</span></code> matches the number of channels in <code class="docutils literal notranslate"><span class="pre">src2</span></code>, the operation can be performed. The scalar is first converted to an array of the same type as <code class="docutils literal notranslate"><span class="pre">src1</span></code>.</p></li>
</ul>
</li>
<li><p><strong>Operation on a Scalar and an Array (<code class="docutils literal notranslate"><span class="pre">src1</span></code> as a scalar):</strong></p>
<ul>
<li><p>Similarly, if <code class="docutils literal notranslate"><span class="pre">src1</span></code> is a scalar, the function computes the bitwise AND operation between the scalar value and each element of <code class="docutils literal notranslate"><span class="pre">src2</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1 AND src2(I) if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>If the number of elements in <code class="docutils literal notranslate"><span class="pre">src2</span></code> matches the number of channels in <code class="docutils literal notranslate"><span class="pre">src1</span></code>, the scalar is first converted to an array of the same type as <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
</ul>
</li>
<li><p><strong>Handling Floating-Point Arrays and Multi-Channel Arrays:</strong></p>
<ul class="simple">
<li><p>For floating-point input arrays, the machine-specific bit representations (usually IEEE754-compliant) are used for the operation.</p></li>
<li><p>When dealing with multi-channel input arrays (e.g., a color image with separate channels), the operation is applied independently to each channel.</p></li>
</ul>
</li>
</ol>
<p><strong>Function Syntax</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">src1</span><span class="p">,</span> <span class="n">src2</span><span class="p">[,</span> <span class="n">dst</span><span class="p">[,</span> <span class="n">mask</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">dst</span>
</pre></div>
</div>
<p><strong>Description</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code> function is part of the OpenCV library in Python, and it performs element-wise bitwise AND operations between two input arrays <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>. An optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> can be provided to specify the region where the operation is applied. The result of the operation is stored in the output array <code class="docutils literal notranslate"><span class="pre">dst</span></code>.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src1</span></code>: The first input array (image) on which the bitwise AND operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">src2</span></code>: The second input array (image) on which the bitwise AND operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code> (optional): The output array to store the result of the operation. If not provided, the function creates a new array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mask</span></code> (optional): A mask specifying the region where the operation should be performed. The dimensions of the mask must match the dimensions of <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
</ul>
<p><strong>Return</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The output array containing the result of the bitwise AND operation between <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>. If <code class="docutils literal notranslate"><span class="pre">dst</span></code> is provided as an argument, the function stores the result in <code class="docutils literal notranslate"><span class="pre">dst</span></code>. Otherwise, a new array is created to hold the result.</p></li>
</ul>
<p><strong>Usage</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code> function is commonly used in image processing to perform bitwise AND operations on corresponding pixels of two images. This can be useful for tasks such as masking or extracting specific regions of interest (ROI) from an image based on a provided mask.</p>
<p>For more detailed information on <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code>, you can refer to the <a class="reference external" href="https://docs.opencv.org/2.4/modules/core/doc/operations_on_arrays.html#bitwise-and">OpenCV documentation</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create two sample images with different shapes</span>
<span class="n">Image1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image1</span><span class="p">[</span><span class="mi">50</span><span class="p">:</span><span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Blue region</span>

<span class="n">Image2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image2</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span> <span class="mi">150</span><span class="p">:</span><span class="mi">250</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Green region</span>

<span class="c1"># Perform a bitwise AND operation between the two images</span>
<span class="n">Result</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">Image1</span><span class="p">,</span> <span class="n">Image2</span><span class="p">)</span>

<span class="c1"># Create a subplot with three images for visualization</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1"># Display the first image on the first subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image1</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Image 1&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Display the second image on the second subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image2</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Image 2&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Display the result of the bitwise AND operation on the third subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Result</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Bitwise AND Result&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Set aspect ratio and turn off axes for all subplots</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/93a3b76a761cd3388d007660cd4cf470abf04dff6fb4d0b9b157bb0372695681.png" src="_images/93a3b76a761cd3388d007660cd4cf470abf04dff6fb4d0b9b157bb0372695681.png" />
</div>
</div>
<p>The provided code snippet generates three images and displays them using Matplotlib subplots. It uses the OpenCV library to perform a bitwise AND operation between two sample images, creating a new resulting image. Let’s break down the code step by step:</p>
<ol class="arabic simple">
<li><p><strong>Creating Sample Images:</strong>
The code creates two sample images with different shapes, both initialized as black images (all pixel values are set to zero). These images are represented as NumPy arrays with dimensions (200, 300, 3), where 200 is the height, 300 is the width, and 3 represents the three color channels (red, green, blue) for each pixel.</p>
<ul class="simple">
<li><p><strong>Image1:</strong> A blue region (pixels with blue color, [255, 0, 0]) is set within the region defined by [50:150, 100:200].</p></li>
<li><p><strong>Image2:</strong> A green region (pixels with green color, [0, 255, 0]) is set within the region defined by [100:200, 150:250].</p></li>
</ul>
</li>
<li><p><strong>Bitwise AND Operation:</strong>
The code performs a bitwise AND operation between Image1 and Image2 using OpenCV’s <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code> function. This operation combines the two images, preserving only the regions where both images have non-zero (i.e., colored) pixels. The result is stored in the “Result” variable.</p></li>
</ol>
</div>
<div class="section" id="element-wise-bitwise-not-with-cv2-bitwise-not">
<h2><span class="section-number">1.7. </span>Element-Wise Bitwise NOT with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code><a class="headerlink" href="#element-wise-bitwise-not-with-cv2-bitwise-not" title="Permalink to this headline">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code> function in OpenCV is a valuable tool for performing an element-wise bitwise NOT operation on an input array. This operation inverts every bit, effectively flipping 0s to 1s and 1s to 0s, in the binary representation of each element within the input array. The resulting array, <code class="docutils literal notranslate"><span class="pre">dst</span></code>, maintains the same size and data type as the input array, making it suitable for various image processing tasks <span id="id11">[<a class="reference internal" href="References.html#id24" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id25" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p><strong>Key Concepts:</strong></p>
<ol class="arabic">
<li><p><strong>Purpose:</strong>
The primary purpose of <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code> is to compute the bitwise NOT (bitwise inversion) of each element in the input array. This creates a corresponding output array with inverted bit values.</p></li>
<li><p><strong>Operation:</strong>
For each element in the input array <code class="docutils literal notranslate"><span class="pre">src</span></code>, the bitwise NOT operation is applied independently. Mathematically, the operation can be represented as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = ¬src(I)
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">dst(I)</span></code> is the value at the same position in the output array, and <code class="docutils literal notranslate"><span class="pre">src(I)</span></code> is the value in the input array.</p>
</li>
<li><p><strong>Handling Floating-Point Input:</strong>
If the input array is of floating-point type (e.g., single-precision or double-precision floating-point), the function uses the machine-specific bit representation of each floating-point element to perform the bitwise NOT operation. This representation typically adheres to the IEEE 754 standard for floating-point representation.</p></li>
<li><p><strong>Multi-Channel Arrays:</strong>
When dealing with multi-channel input arrays (e.g., a color image represented as separate channels), the operation is applied independently to each channel. Consequently, each channel’s bit values are inverted, resulting in a multi-channel output array.</p></li>
</ol>
<p><strong>Function Syntax</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">src</span><span class="p">[,</span> <span class="n">dst</span><span class="p">[,</span> <span class="n">mask</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">dst</span>
</pre></div>
</div>
<p><strong>Description</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code> function is a part of the OpenCV library in Python. It performs the element-wise bitwise negation operation (NOT operation) on the input array <code class="docutils literal notranslate"><span class="pre">src</span></code>. Additionally, it allows for an optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> to specify the region where the operation is to be applied. The result of the operation is stored in the output array <code class="docutils literal notranslate"><span class="pre">dst</span></code>.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src</span></code>: The input array (image) on which the bitwise NOT operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code> (optional): The output array used to store the result of the operation. If not provided, the function creates a new array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mask</span></code> (optional): An 8-bit, single-channel array that specifies elements of the output array to be modified. This mask parameter allows the selective application of the bitwise NOT operation to specific elements based on the mask values.</p></li>
</ul>
<p><strong>Return</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The output array containing the result of the bitwise NOT operation applied to the input <code class="docutils literal notranslate"><span class="pre">src</span></code>. If <code class="docutils literal notranslate"><span class="pre">dst</span></code> is provided as an argument, the function stores the result in <code class="docutils literal notranslate"><span class="pre">dst</span></code>. Otherwise, a new array is created to hold the result.</p></li>
</ul>
<p><strong>Usage</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code> function is commonly used in image processing to invert every bit (pixel value) of an image. This operation is useful for creating the complement of a binary image or for inverting a mask. By specifying a mask, you can control which region of the image is subject to the bitwise NOT operation.</p>
<p>For more detailed information on <code class="docutils literal notranslate"><span class="pre">bitwise_not</span></code>, you can refer to the <a class="reference external" href="https://docs.opencv.org/2.4/modules/core/doc/operations_on_arrays.html#bitwise-not">OpenCV documentation</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">io</span>

<span class="c1"># Load the GitHub logo from a URL</span>
<span class="n">Git</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s1">&#39;https://github.githubassets.com/images/modules/open_graph/github-mark.png&#39;</span><span class="p">)</span>

<span class="c1"># Define the scale factor for resizing (5% of the original size)</span>
<span class="n">scale</span> <span class="o">=</span> <span class="mf">0.05</span>

<span class="c1"># Resize the GitHub logo using OpenCV</span>
<span class="n">Git_resized</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">Git</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">Git</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)),</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">INTER_AREA</span><span class="p">)</span>

<span class="c1"># Invert the colors of the resized logo using bitwise NOT</span>
<span class="n">Git_resized</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">Git_resized</span><span class="p">)</span>

<span class="c1"># Get the first image from the dataset</span>
<span class="n">Img</span> <span class="o">=</span> <span class="n">Images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Create an empty mask with the same dimensions as Img</span>
<span class="n">Mask</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">Img</span>

<span class="c1"># Place the resized and inverted logo (Git_resized) onto the mask</span>
<span class="n">Mask</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="n">Git_resized</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">:</span> <span class="n">Git_resized</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Git_resized</span>

<span class="c1"># Add the mask with the logo to the original image (Img)</span>
<span class="n">Img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Img</span><span class="p">,</span> <span class="n">Mask</span><span class="p">)</span>

<span class="c1"># Apply a binary threshold to the &quot;Img&quot; image</span>
<span class="c1"># The threshold value is 130, and the maximum value after thresholding is 255</span>
<span class="c1"># The result is stored in the &quot;Out&quot; image</span>
<span class="n">_</span><span class="p">,</span> <span class="n">Out</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">Img</span><span class="p">,</span> <span class="mi">130</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">THRESH_BINARY</span><span class="p">)</span>

<span class="c1"># Show both the original &quot;Img&quot; image and the thresholded &quot;Out&quot; image</span>
<span class="c1"># Add titles to the images for clarity</span>
<span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">([</span><span class="n">Mask</span><span class="p">,</span> <span class="n">Img</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Logo&#39;</span><span class="p">,</span> <span class="s1">&#39;Image + Logo&#39;</span><span class="p">],</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;cv2.bitwise_not&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/cc40853d105d6c80315f44d20ab3d01b2ecd6d88de7a8aad6f61c35c7114f076.png" src="_images/cc40853d105d6c80315f44d20ab3d01b2ecd6d88de7a8aad6f61c35c7114f076.png" />
</div>
</div>
<p>This code loads the GitHub logo from a URL, resizes and inverts it, and then adds the resized logo to an image from a dataset. The final result is shown in a subplot, illustrating the original image with the added logo. The use of <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code> inverts the logo, and the logo is placed on the mask using slicing. The <code class="docutils literal notranslate"><span class="pre">cv2.add</span></code> function is used to combine the original image and the mask with the logo. The code also provides visualizations using matplotlib subplots for comparison.</p>
</div>
<div class="section" id="element-wise-bitwise-or-with-cv2-bitwise-or">
<h2><span class="section-number">1.8. </span>Element-Wise Bitwise OR with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code><a class="headerlink" href="#element-wise-bitwise-or-with-cv2-bitwise-or" title="Permalink to this headline">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code> function in OpenCV is a powerful tool for performing an element-wise bitwise disjunction (logical OR) operation on input arrays. This operation combines the binary representation of each element in the input arrays, producing a new array with the same size and data type as the input arrays. Here’s a detailed breakdown of how <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code> behaves <span id="id12">[<a class="reference internal" href="References.html#id24" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id25" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>:</p>
<p><strong>1. Operation on Two Arrays (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code> with the same size):</strong></p>
<ul>
<li><p>When both input arrays (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>) have the same size, the function computes the logical disjunction (bitwise OR) between corresponding elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1(I) OR src2(I) if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>The operation is performed element-wise. Each element in the resulting array <code class="docutils literal notranslate"><span class="pre">dst</span></code> is the result of the logical OR operation between the corresponding elements in <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
<li><p>The optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> parameter allows for selective application of the operation based on the mask values. If <code class="docutils literal notranslate"><span class="pre">mask(I)</span></code> is non-zero, the operation is applied; otherwise, the corresponding element in <code class="docutils literal notranslate"><span class="pre">dst</span></code> remains unchanged.</p></li>
</ul>
<p><strong>2. Operation on an Array and a Scalar (<code class="docutils literal notranslate"><span class="pre">src2</span></code> as a scalar):</strong></p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">src2</span></code> is a scalar (a single value), the function computes the bitwise OR operation between each element of <code class="docutils literal notranslate"><span class="pre">src1</span></code> and the scalar value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1(I) OR src2 if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>If the number of elements in <code class="docutils literal notranslate"><span class="pre">src1</span></code> matches the number of channels in <code class="docutils literal notranslate"><span class="pre">src2</span></code>, the operation can be performed. The scalar is first converted to an array of the same type as <code class="docutils literal notranslate"><span class="pre">src1</span></code>.</p></li>
</ul>
<p><strong>3. Operation on a Scalar and an Array (<code class="docutils literal notranslate"><span class="pre">src1</span></code> as a scalar):</strong></p>
<ul>
<li><p>Similarly, if <code class="docutils literal notranslate"><span class="pre">src1</span></code> is a scalar, the function computes the bitwise OR operation between the scalar value and each element of <code class="docutils literal notranslate"><span class="pre">src2</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1 OR src2(I) if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>If the number of elements in <code class="docutils literal notranslate"><span class="pre">src2</span></code> matches the number of channels in <code class="docutils literal notranslate"><span class="pre">src1</span></code>, the scalar is first converted to an array of the same type as <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
</ul>
<p><strong>4. Handling Floating-Point Arrays and Multi-Channel Arrays:</strong></p>
<ul class="simple">
<li><p>For floating-point input arrays, the machine-specific bit representations (usually IEEE754-compliant) are used for the operation.</p></li>
<li><p>If the input arrays are multi-channel (e.g., a color image with separate channels), the operation is applied independently to each channel.</p></li>
</ul>
<p><strong>Function Syntax</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">src1</span><span class="p">,</span> <span class="n">src2</span><span class="p">[,</span> <span class="n">dst</span><span class="p">[,</span> <span class="n">mask</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">dst</span>
</pre></div>
</div>
<p><strong>Description</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code> function is part of the OpenCV library in Python. It performs the element-wise bitwise disjunction (OR operation) between two input arrays <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>. An optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> can be provided to specify the region where the operation is to be applied. The result of the operation is stored in the output array <code class="docutils literal notranslate"><span class="pre">dst</span></code>.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src1</span></code>: The first input array (image) on which the bitwise OR operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">src2</span></code>: The second input array (image) on which the bitwise OR operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code> (optional): The output array used to store the result of the operation. If not provided, the function creates a new array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mask</span></code> (optional): A mask specifying the region where the operation should be performed. The dimensions of the mask must match the dimensions of <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
</ul>
<p><strong>Return</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The output array containing the result of the bitwise OR operation applied to the input <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>. If <code class="docutils literal notranslate"><span class="pre">dst</span></code> is provided as an argument, the function stores the result in <code class="docutils literal notranslate"><span class="pre">dst</span></code>. Otherwise, a new array is created to hold the result.</p></li>
</ul>
<p><strong>Usage</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code> function is commonly used in image processing to perform logical OR operations on corresponding pixels of two images. It’s often used to combine binary data or create masks. By providing a mask, you can control which regions of the input images are subject to the bitwise OR operation.</p>
<p>For further details on <code class="docutils literal notranslate"><span class="pre">bitwise_or</span></code>, refer to the <a class="reference external" href="https://docs.opencv.org/2.4/modules/core/doc/operations_on_arrays.html#bitwise-or">OpenCV documentation</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create two sample images with different shapes</span>
<span class="n">Image1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image1</span><span class="p">[</span><span class="mi">50</span><span class="p">:</span><span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Blue region</span>

<span class="n">Image2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image2</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span> <span class="mi">150</span><span class="p">:</span><span class="mi">250</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Green region</span>

<span class="c1"># Perform a bitwise OR operation between the two images</span>
<span class="n">Result</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">Image1</span><span class="p">,</span> <span class="n">Image2</span><span class="p">)</span>

<span class="c1"># Create a subplot with three images for visualization</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1"># Display the first image on the first subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image1</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Image 1&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Display the second image on the second subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image2</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Image 2&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Display the result of the bitwise OR operation on the third subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Result</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Bitwise OR Result&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Set aspect ratio and turn off axes for all subplots</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/32860d46e3a40a51bfce3b46f03743ae7d3a4dd59149a57a53dbb6ea13e71784.png" src="_images/32860d46e3a40a51bfce3b46f03743ae7d3a4dd59149a57a53dbb6ea13e71784.png" />
</div>
</div>
<p>The provided code snippet generates three images and displays them using Matplotlib subplots. It utilizes OpenCV’s bitwise OR operation to combine pixel values from two sample images. Let’s break down the code step by step:</p>
<ol class="arabic simple">
<li><p><strong>Creating Sample Images:</strong></p>
<ul class="simple">
<li><p>Two sample images, <code class="docutils literal notranslate"><span class="pre">Image1</span></code> and <code class="docutils literal notranslate"><span class="pre">Image2</span></code>, are created using NumPy. Both images have dimensions (200, 300, 3), which means they are 200 pixels in height, 300 pixels in width, and have 3 color channels (red, green, blue) for each pixel.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">Image1</span></code>, a blue region is created by assigning the value [255, 0, 0] (pure blue) to a specific rectangular region ([50:150, 100:200]) within the image.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">Image2</span></code>, a green region is created by assigning the value [0, 255, 0] (pure green) to a specific rectangular region ([100:200, 150:250]) within the image.</p></li>
</ul>
</li>
<li><p><strong>Bitwise OR Operation:</strong></p>
<ul class="simple">
<li><p>The code performs a bitwise OR operation between <code class="docutils literal notranslate"><span class="pre">Image1</span></code> and <code class="docutils literal notranslate"><span class="pre">Image2</span></code> using OpenCV’s <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code> function. This operation combines the two images by taking the maximum pixel value for each channel at corresponding pixel locations. The result is stored in the “Result” variable.</p></li>
</ul>
</li>
</ol>
</div>
<div class="section" id="element-wise-bitwise-xor-with-cv2-bitwise-xor">
<h2><span class="section-number">1.9. </span>Element-Wise Bitwise XOR with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code><a class="headerlink" href="#element-wise-bitwise-xor-with-cv2-bitwise-xor" title="Permalink to this headline">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code> function in OpenCV is a versatile tool for performing an element-wise bitwise exclusive OR (XOR) operation on input arrays. This operation combines the binary representation of each element in the input arrays, producing a new array with the same size and data type as the input arrays. Here’s a detailed breakdown of how <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code> behaves <span id="id13">[<a class="reference internal" href="References.html#id24" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id25" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>:</p>
<p><strong>1. Operation on Two Arrays (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code> with the same size):</strong></p>
<ul>
<li><p>When both input arrays (<code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>) have the same size, the function computes the logical exclusive OR (bitwise XOR) between corresponding elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1(I) XOR src2(I) if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>The operation is performed element-wise. Each element in the resulting array <code class="docutils literal notranslate"><span class="pre">dst</span></code> is the result of the logical XOR operation between the corresponding elements in <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
<li><p>The optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> parameter allows for selective application of the operation based on the mask values. If <code class="docutils literal notranslate"><span class="pre">mask(I)</span></code> is non-zero, the operation is applied; otherwise, the corresponding element in <code class="docutils literal notranslate"><span class="pre">dst</span></code> remains unchanged.</p></li>
</ul>
<p><strong>2. Operation on an Array and a Scalar (<code class="docutils literal notranslate"><span class="pre">src2</span></code> as a scalar):</strong></p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">src2</span></code> is a scalar (a single value), the function computes the bitwise XOR operation between each element of <code class="docutils literal notranslate"><span class="pre">src1</span></code> and the scalar value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1(I) XOR src2 if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>If the number of elements in <code class="docutils literal notranslate"><span class="pre">src1</span></code> matches the number of channels in <code class="docutils literal notranslate"><span class="pre">src2</span></code>, the operation can be performed. The scalar is first converted to an array of the same type as <code class="docutils literal notranslate"><span class="pre">src1</span></code>.</p></li>
</ul>
<p><strong>3. Operation on a Scalar and an Array (<code class="docutils literal notranslate"><span class="pre">src1</span></code> as a scalar):</strong></p>
<ul>
<li><p>Similarly, if <code class="docutils literal notranslate"><span class="pre">src1</span></code> is a scalar, the function computes the bitwise XOR operation between the scalar value and each element of <code class="docutils literal notranslate"><span class="pre">src2</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dst(I) = src1 XOR src2(I) if mask(I) ≠ 0
</pre></div>
</div>
</li>
<li><p>If the number of elements in <code class="docutils literal notranslate"><span class="pre">src2</span></code> matches the number of channels in <code class="docutils literal notranslate"><span class="pre">src1</span></code>, the scalar is first converted to an array of the same type as <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
</ul>
<p><strong>4. Handling Floating-Point Arrays and Multi-Channel Arrays:</strong></p>
<ul class="simple">
<li><p>For floating-point input arrays, the machine-specific bit representations (usually IEEE754-compliant) are used for the operation.</p></li>
<li><p>If the input arrays are multi-channel (e.g., a color image with separate channels), the operation is applied independently to each channel.</p></li>
</ul>
<p><strong>Function Syntax</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="n">src1</span><span class="p">,</span> <span class="n">src2</span><span class="p">[,</span> <span class="n">dst</span><span class="p">[,</span> <span class="n">mask</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">dst</span>
</pre></div>
</div>
<p><strong>Description</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code> function is part of the OpenCV library in Python. It performs the element-wise bitwise exclusive OR (XOR) operation between two input arrays <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>. An optional <code class="docutils literal notranslate"><span class="pre">mask</span></code> can be provided to specify the region where the operation is to be applied. The result of the operation is stored in the output array <code class="docutils literal notranslate"><span class="pre">dst</span></code>.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src1</span></code>: The first input array (image) on which the bitwise XOR operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">src2</span></code>: The second input array (image) on which the bitwise XOR operation is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code> (optional): The output array used to store the result of the operation. If not provided, the function creates a new array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mask</span></code> (optional): A mask specifying the region where the operation should be performed. The dimensions of the mask must match the dimensions of <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>.</p></li>
</ul>
<p><strong>Return</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The output array containing the result of the bitwise XOR operation between <code class="docutils literal notranslate"><span class="pre">src1</span></code> and <code class="docutils literal notranslate"><span class="pre">src2</span></code>. If <code class="docutils literal notranslate"><span class="pre">dst</span></code> is provided as an argument, the function stores the result in <code class="docutils literal notranslate"><span class="pre">dst</span></code>. Otherwise, a new array is created to hold the result.</p></li>
</ul>
<p><strong>Usage</strong>:
The <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code> function is commonly used in image processing to perform logical XOR operations on corresponding pixels of two images. It’s useful for tasks like creating binary patterns, detecting differences between images, and other operations that involve exclusive combinations of binary data. By providing a mask, you can control which regions of the input images are subject to the bitwise XOR operation.</p>
<p>By utilizing the <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code> function, you can manipulate images at the bit level, enabling a wide range of operations for binary data manipulation in various computer vision applications. Understanding these operations is valuable for various computer vision tasks involving binary representations.</p>
<p>For further details on <code class="docutils literal notranslate"><span class="pre">bitwise_xor</span></code>, refer to the <a class="reference external" href="https://docs.opencv.org/2.4/modules/core/doc/operations_on_arrays.html#bitwise-xor">OpenCV documentation</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create two sample images with different shapes</span>
<span class="n">Image1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image1</span><span class="p">[</span><span class="mi">50</span><span class="p">:</span><span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Blue region</span>

<span class="n">Image2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">Image2</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span> <span class="mi">150</span><span class="p">:</span><span class="mi">250</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Green region</span>

<span class="c1"># Perform a bitwise XOR operation between the two images</span>
<span class="n">Result</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="n">Image1</span><span class="p">,</span> <span class="n">Image2</span><span class="p">)</span>

<span class="c1"># Create a subplot with three images for visualization</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1"># Display the first image on the first subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image1</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Image 1&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Display the second image on the second subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Image2</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Image 2&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Display the result of the bitwise XOR operation on the third subplot</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Result</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Bitwise XOR Result&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Set aspect ratio and turn off axes for all subplots</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/e658ab39e8a920573f1cd15187f660ca507dc7d34feb6fe2e9fc92f617f7fe47.png" src="_images/e658ab39e8a920573f1cd15187f660ca507dc7d34feb6fe2e9fc92f617f7fe47.png" />
</div>
</div>
<p>Let’s break down the code step by step:</p>
<ol class="arabic simple">
<li><p><strong>Creating Sample Images:</strong></p>
<ul class="simple">
<li><p>Two sample images, <code class="docutils literal notranslate"><span class="pre">Image1</span></code> and <code class="docutils literal notranslate"><span class="pre">Image2</span></code>, are created using NumPy. Both images have dimensions (200, 300, 3), which means they are 200 pixels in height, 300 pixels in width, and have 3 color channels (red, green, blue) for each pixel.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">Image1</span></code>, a blue region is created by assigning the value [255, 0, 0] (pure blue) to a specific rectangular region ([50:150, 100:200]) within the image.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">Image2</span></code>, a green region is created by assigning the value [0, 255, 0] (pure green) to a specific rectangular region ([100:200, 150:250]) within the image.</p></li>
</ul>
</li>
<li><p><strong>Bitwise XOR Operation:</strong></p>
<ul class="simple">
<li><p>The code performs a bitwise XOR operation between <code class="docutils literal notranslate"><span class="pre">Image1</span></code> and <code class="docutils literal notranslate"><span class="pre">Image2</span></code> using OpenCV’s <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code> function. This operation combines the two images by applying the XOR operation to the pixel values for each channel at corresponding pixel locations. The result is stored in the “Result” variable</p></li>
</ul>
</li>
</ol>
<div class="tip admonition">
<p class="admonition-title">Summary</p>
<p><code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code>, <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code>, <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code>, and <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code> are fundamental bitwise operations provided by the OpenCV library for image processing. Here are the differences and similarities between these operations:</p>
<ol class="arabic simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and(src1,</span> <span class="pre">src2[,</span> <span class="pre">dst[,</span> <span class="pre">mask]])</span></code></strong>:</p>
<ul class="simple">
<li><p><strong>Function</strong>: Performs a bitwise AND operation between corresponding pixels of two input images (src1 and src2).</p></li>
<li><p><strong>Usage</strong>: This operation results in an output image where the corresponding pixels are retained if both corresponding pixels in the input images are non-zero.</p></li>
<li><p><strong>Similarity</strong>: Similar to the logical AND operation but operates at the bit level for each pixel in the images.</p></li>
</ul>
</li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not(src[,</span> <span class="pre">dst[,</span> <span class="pre">mask]])</span></code></strong>:</p>
<ul class="simple">
<li><p><strong>Function</strong>: Inverts every bit of the input image (src).</p></li>
<li><p><strong>Usage</strong>: This operation results in an output image where all the 1s (white pixels) in the input image become 0s (black pixels), and vice versa.</p></li>
<li><p><strong>Similarity</strong>: Similar to the logical NOT operation but operates at the bit level for each pixel in the image.</p></li>
</ul>
</li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or(src1,</span> <span class="pre">src2[,</span> <span class="pre">dst[,</span> <span class="pre">mask]])</span></code></strong>:</p>
<ul class="simple">
<li><p><strong>Function</strong>: Performs a bitwise OR operation between corresponding pixels of two input images (src1 and src2).</p></li>
<li><p><strong>Usage</strong>: This operation results in an output image where the corresponding pixels are retained if at least one of the corresponding pixels in the input images is non-zero.</p></li>
<li><p><strong>Similarity</strong>: Similar to the logical OR operation but operates at the bit level for each pixel in the images.</p></li>
</ul>
</li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor(src1,</span> <span class="pre">src2[,</span> <span class="pre">dst[,</span> <span class="pre">mask]])</span></code></strong>:</p>
<ul class="simple">
<li><p><strong>Function</strong>: Performs a bitwise XOR (exclusive OR) operation between corresponding pixels of two input images (src1 and src2).</p></li>
<li><p><strong>Usage</strong>: This operation results in an output image where the corresponding pixels are retained if the corresponding pixels in the input images are different (one is 0 and the other is 1).</p></li>
<li><p><strong>Similarity</strong>: Similar to the logical XOR operation but operates at the bit level for each pixel in the images.</p></li>
</ul>
</li>
</ol>
<p><strong>Differences</strong>:</p>
<ul class="simple">
<li><p>The primary difference lies in the specific bitwise operation each function performs (AND, NOT, OR, XOR) on the corresponding pixels.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">bitwise_and</span></code> and <code class="docutils literal notranslate"><span class="pre">bitwise_or</span></code> functions retain specific pixel combinations based on the logical AND and OR conditions, respectively.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">bitwise_not</span></code> function inverts the bits of the input image.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">bitwise_xor</span></code> function retains pixels only when there is a difference between the corresponding pixels in the input images.</p></li>
</ul>
<p><strong>Similarities</strong>:</p>
<ul class="simple">
<li><p>All these operations work at the bit level, meaning they operate on individual bits of the pixel values.</p></li>
<li><p>They are useful for various image processing tasks, including masking, combining regions, and altering specific aspects of images based on pixel values.</p></li>
<li><p>They allow for fine-grained control over pixel manipulation in image processing tasks.</p></li>
</ul>
</div>
</div>
<div class="section" id="colorspace-conversion-with-cv2-cvtcolor">
<h2><span class="section-number">1.10. </span>Colorspace Conversion with <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code><a class="headerlink" href="#colorspace-conversion-with-cv2-cvtcolor" title="Permalink to this headline">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code> function in the Python OpenCV library is a powerful tool for changing the colorspace of an input image or rearranging its image channels. It allows you to convert an input image (source) from one colorspace to another, based on a specified color conversion code. The resulting image can be stored in the output (destination) image, if provided, or a new image is created to hold the converted result <span id="id14">[<a class="reference internal" href="References.html#id24" title="G. Bradski. The OpenCV Library. Dr. Dobb's Journal of Software Tools, 2000.">Bradski, 2000</a>, <a class="reference internal" href="References.html#id25" title="OpenCV Developers. Opencv documentation. https://docs.opencv.org/4.x/index.html, 2023. [Online; accessed 01-August-2023].">OpenCV Developers, 2023</a>]</span>.</p>
<p>Here’s an in-depth explanation of the parameters and the purpose of this function:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src</span></code>: This parameter represents the input image (source) that you intend to convert. It should be a numpy array, effectively representing the image you want to transform.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">code</span></code>: The <code class="docutils literal notranslate"><span class="pre">code</span></code> parameter specifies the color conversion code or the type of transformation that defines how the input image’s colors will be converted. This code is an integer value corresponding to a specific colorspace conversion or channel rearrangement. For example, <code class="docutils literal notranslate"><span class="pre">cv2.COLOR_BGR2GRAY</span></code> indicates converting from the BGR colorspace to grayscale. The available conversion codes are defined in OpenCV’s documentation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst</span></code> (optional): The <code class="docutils literal notranslate"><span class="pre">dst</span></code> parameter serves as the output image (destination) where the result of the colorspace conversion will be stored. If this parameter is not provided, a new image will be created to store the converted result.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dstCn</span></code> (optional): The <code class="docutils literal notranslate"><span class="pre">dstCn</span></code> parameter specifies the number of channels in the destination image. It is used when you want to change the number of channels in the output image. If this parameter is not specified, it defaults to 0, and the number of channels is inferred based on the conversion code.</p></li>
</ul>
<p>Here’s the structure of the function signature:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">code</span><span class="p">[,</span> <span class="n">dst</span><span class="p">[,</span> <span class="n">dstCn</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">dst</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code> function provides a versatile way to transform images between various colorspace representations, such as RGB, grayscale, HSV, YUV, and more. It is a fundamental operation in image processing that enables you to adapt images to different processing techniques or to analyze them from various color perspectives.</p>
<p>For more detailed information and the list of available color conversion codes, you can refer to the <a class="reference external" href="https://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html#cvtcolor">OpenCV documentation on <code class="docutils literal notranslate"><span class="pre">cvtColor</span></code></a>. This function plays a crucial role in image manipulation and analysis, allowing you to work with images in different colorspaces, which is essential in various computer vision and image processing tasks.</p>
<div class="section" id="rgb-to-grayscale">
<h3><span class="section-number">1.10.1. </span>RGB to Grayscale<a class="headerlink" href="#rgb-to-grayscale" title="Permalink to this headline">#</a></h3>
<p>To convert an image from the RGB (Red, Green, Blue) color space to grayscale, you can use the <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code> function from the OpenCV library with the appropriate color conversion code. Here’s how to do it in Python:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Convert RGB to Grayscale</span>
<span class="n">gray_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">Images</span><span class="p">]</span>
<span class="n">inverted_gray_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">gray_images</span><span class="p">]</span>

<span class="c1"># Create titles for the images</span>
<span class="n">gray_titles</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> (Gray)&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">Names</span><span class="p">]</span>
<span class="n">inverted_gray_titles</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> (Inverted Gray)&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">Names</span><span class="p">]</span>

<span class="c1"># Plot the images</span>
<span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">(</span> <span class="n">gray_images</span><span class="p">,</span> <span class="n">gray_titles</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span> <span class="s1">&#39;RGB to Grayscale&#39;</span> <span class="p">,</span><span class="n">grayscale</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">(</span> <span class="n">inverted_gray_images</span><span class="p">,</span> <span class="n">inverted_gray_titles</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span> <span class="s1">&#39;RGB to Grayscale (Inverted)&#39;</span> <span class="p">,</span><span class="n">grayscale</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/95fa0602dc616b6a9c26069b9145c5c651d261911ab9ef4f23074d291e4600c9.png" src="_images/95fa0602dc616b6a9c26069b9145c5c651d261911ab9ef4f23074d291e4600c9.png" />
<img alt="_images/301c9a2194c6b4ef4890fbd5b87e1c36dcc757b56a21f1de630c0fbd95ee4afc.png" src="_images/301c9a2194c6b4ef4890fbd5b87e1c36dcc757b56a21f1de630c0fbd95ee4afc.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.font_manager</span> <span class="kn">import</span> <span class="n">FontProperties</span>

<span class="c1"># Load or obtain your Images and Names here</span>
<span class="c1"># Replace Images and Names with your actual image data and labels</span>

<span class="c1"># Define a bold font for image titles</span>
<span class="n">font</span> <span class="o">=</span> <span class="n">FontProperties</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>

<span class="c1"># Function to plot a set of images with titles</span>
<span class="k">def</span> <span class="nf">plot_images</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">titles</span><span class="p">,</span> <span class="n">suptitle</span><span class="p">):</span>
    <span class="n">num_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
    <span class="c1"># Create a figure and a row of subplots with the specified size</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_images</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># Flatten the subplot array for easier access</span>
    
    <span class="c1"># Iterate through images and titles</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_images</span><span class="p">):</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;gray&#39;</span><span class="p">)</span>  <span class="c1"># Display the image in grayscale</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>  <span class="c1"># Adjust aspect ratio to auto</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>  <span class="c1"># Turn off axis labels</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>  <span class="c1"># Set the image title</span>
    
    <span class="n">_</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>  <span class="c1"># Adjust spacing between subplots</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">suptitle</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>  <span class="c1"># Set the overall title</span>

<span class="c1"># Convert RGB to Grayscale</span>
<span class="n">gray_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">Images</span><span class="p">]</span>
<span class="n">inverted_gray_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">gray_images</span><span class="p">]</span>

<span class="c1"># Create titles for the images</span>
<span class="n">gray_titles</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> (Gray)&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">Names</span><span class="p">]</span>
<span class="n">inverted_gray_titles</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> (Inverted Gray)&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">Names</span><span class="p">]</span>

<span class="c1"># Plot the images</span>
<span class="n">plot_images</span><span class="p">(</span><span class="n">gray_images</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">gray_titles</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;RGB to Grayscale&#39;</span><span class="p">)</span>
<span class="n">plot_images</span><span class="p">(</span><span class="n">inverted_gray_images</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">inverted_gray_titles</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;RGB to Grayscale (Inverted)&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  <span class="c1"># Display the plotted images</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/c1bfcb756df0fafd2ca251439e7444a1f31edeeea65577c599f4f1bc184c7e20.png" src="_images/c1bfcb756df0fafd2ca251439e7444a1f31edeeea65577c599f4f1bc184c7e20.png" />
<img alt="_images/0198ad84f9555e323195bd672157fd1f9b4e848ba4752acd120c4b587b1bd296.png" src="_images/0198ad84f9555e323195bd672157fd1f9b4e848ba4752acd120c4b587b1bd296.png" />
</div>
</div>
<p>This code performs the following steps:</p>
<ol class="arabic simple">
<li><p><strong>Importing Libraries</strong>: It imports the necessary libraries for working with images and visualization, namely <code class="docutils literal notranslate"><span class="pre">cv2</span></code> (OpenCV) for image processing, and <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> for plotting images.</p></li>
<li><p><strong>Preparation</strong>: It includes comments instructing you to load or obtain the actual image data and labels (names) that you want to process and visualize. You need to replace the placeholders <code class="docutils literal notranslate"><span class="pre">Images</span></code> and <code class="docutils literal notranslate"><span class="pre">Names</span></code> with your actual image data and labels.</p></li>
<li><p><strong>Font Definition</strong>: It defines a bold font (<code class="docutils literal notranslate"><span class="pre">font</span></code>) to be used for image titles.</p></li>
<li><p><strong>Image Plotting Function</strong>: It defines a function called <code class="docutils literal notranslate"><span class="pre">plot_images</span></code> that takes a list of images, their corresponding titles, and an overall title for the set of images. This function creates a row of subplots with the specified size and displays the images in grayscale format, turning off axis labels, and setting the titles using the specified font.</p></li>
<li><p><strong>RGB to Grayscale Conversion</strong>: It converts a list of RGB images (presumably stored in the <code class="docutils literal notranslate"><span class="pre">Images</span></code> variable) to grayscale format using the OpenCV function <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor</span></code> with the conversion code <code class="docutils literal notranslate"><span class="pre">cv2.COLOR_BGR2GRAY</span></code>. The resulting grayscale images are stored in the <code class="docutils literal notranslate"><span class="pre">gray_images</span></code> variable.</p></li>
<li><p><strong>Inverted Grayscale Images</strong>: It creates a list of inverted grayscale images by applying the <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code> operation to each image in the <code class="docutils literal notranslate"><span class="pre">gray_images</span></code> list. The resulting images are stored in the <code class="docutils literal notranslate"><span class="pre">inverted_gray_images</span></code> variable.</p></li>
<li><p><strong>Title Creation</strong>: It generates titles for the grayscale and inverted grayscale images. These titles are based on the original names from the <code class="docutils literal notranslate"><span class="pre">Names</span></code> variable but with added labels indicating the type of processing.</p></li>
<li><p><strong>Image Plotting</strong>: It calls the <code class="docutils literal notranslate"><span class="pre">plot_images</span></code> function twice: once to display the first two grayscale images with their titles, and once to display the first two inverted grayscale images with their titles. The overall titles for these sets of images are “RGB to Grayscale” and “RGB to Grayscale (Inverted)”, respectively.</p></li>
<li><p><strong>Display</strong>: Finally, the code uses <code class="docutils literal notranslate"><span class="pre">plt.show()</span></code> to display the plotted images with their titles.</p></li>
</ol>
</div>
<div class="section" id="rgb-to-hsv">
<h3><span class="section-number">1.10.2. </span>RGB to HSV<a class="headerlink" href="#rgb-to-hsv" title="Permalink to this headline">#</a></h3>
<p>Converting an image from the RGB (Red, Green, Blue) color space to the HSV (Hue, Saturation, Value) color space is a common operation in image processing. The HSV color space separates the color information into three components: hue (the color itself), saturation (the intensity of the color), and value (the brightness). Here’s how to perform the RGB to HSV conversion using OpenCV in Python:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Convert Images from RGB to HSV color space</span>
<span class="n">augmented_images_hsv</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2HSV</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">Images</span><span class="p">]</span>

<span class="c1"># Display the augmented images in HSV color space</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ImShow</span><span class="p">(</span><span class="n">augmented_images_hsv</span><span class="p">,</span> <span class="n">Names</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;RGB to HSV&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/0546465ca405328faa04c1c13a1c2e55c961fe93859d0b822a9a6285b6941b6d.png" src="_images/0546465ca405328faa04c1c13a1c2e55c961fe93859d0b822a9a6285b6941b6d.png" />
</div>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="Getting_Started.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Getting Started with Python</p>
      </div>
    </a>
    <a class="right-next"
       href="CV_C2.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">2. </span>Geometric Transformations</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#sample-images">1.1. Sample Images</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#accessing-and-manipulating-pixel-values-in-images">1.2. Accessing and Manipulating Pixel Values in Images</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#adding-padding-exploring-border-types-in-opencv">1.3. Adding Padding: Exploring Border Types in OpenCV</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#image-blending-using-the-cv2-addweighted-function">1.4. Image Blending: Using the <code class="docutils literal notranslate"><span class="pre">cv2.addWeighted</span></code> Function</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bitwise-operations-in-opencv">1.5. Bitwise Operations in OpenCV</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bitwise-and-operation-with-cv2-bitwise-and">1.6. Bitwise AND Operation with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_and</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#element-wise-bitwise-not-with-cv2-bitwise-not">1.7. Element-Wise Bitwise NOT with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_not</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#element-wise-bitwise-or-with-cv2-bitwise-or">1.8. Element-Wise Bitwise OR with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_or</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#element-wise-bitwise-xor-with-cv2-bitwise-xor">1.9. Element-Wise Bitwise XOR with <code class="docutils literal notranslate"><span class="pre">cv2.bitwise_xor</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#colorspace-conversion-with-cv2-cvtcolor">1.10. Colorspace Conversion with <code class="docutils literal notranslate"><span class="pre">cv2.cvtColor()</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rgb-to-grayscale">1.10.1. RGB to Grayscale</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rgb-to-hsv">1.10.2. RGB to HSV</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Hatef Dastour
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>